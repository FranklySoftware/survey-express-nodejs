//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// If you are reading this, you are viewing the un-compressed, development version of the core v18 JS file.
// This file should NEVER, EVER, EVER be used on a production web site.
// It's HUGE and contains TONS of commented code and documentation comments.
// 65% of the file is comments, 35% is actual JS.
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////



/**

	Used for testing/timing events and optimizing JS code performance.
	<br />
	<br />This file is at the top of JS build file and simply starts a timer:
		
	window.v18JsStart = new Date().getTime();

	jstimer-end.js is at the end of the JS build file and uses this timestamp to test performance of key page items' rendering.

	@class Other IBM - jstimer-start

**/

window.v18JsStart = new Date().getTime();


;

/**

	Shim for console for older IEs and old browsers that don't support the full range of console functions.

**/
(function() {
	// Union of Chrome, Firefox, IE, Opera, and Safari console methods
	var methods = ["assert", "assert", "cd", "clear", "count", "countReset", "debug", "dir", "dirxml", "dirxml", "dirxml", "error", "error", "exception", "group", "group", "groupCollapsed", "groupCollapsed", "groupEnd", "info", "info", "log", "log", "markTimeline", "profile", "profileEnd", "profileEnd", "select", "table", "table", "time", "time", "timeEnd", "timeEnd", "timeEnd", "timeEnd", "timeEnd", "timeStamp", "timeline", "timelineEnd", "trace", "trace", "trace", "trace", "trace", "warn"],
		length = methods.length,
		console = window.console || {},
		method,
		noop = function() {};

	while (length--) {
		method = methods[length];
		// Define undefined methods as noops to prevent errors
		if (!console[method]) {
			console[method] = noop;
		}
	}
})();;

/**

	Modernizr script custom build v2.8.3. 
	<br />Used for feature detections.
	<br />Official documenation at <a href="http://modernizr.com/" target="_blank">http://modernizr.com/</a>.

	@module Modernizr
	@main Modernizr
	@class Modernizr

**/
/* Modernizr 2.8.3 (Custom Build) | MIT & BSD
 * Build: http://modernizr.com/download/#-fontface-backgroundsize-borderimage-borderradius-boxshadow-flexbox-flexboxlegacy-hsla-multiplebgs-opacity-rgba-textshadow-cssanimations-csscolumns-generatedcontent-cssgradients-cssreflections-csstransforms-csstransforms3d-csstransitions-applicationcache-canvas-canvastext-draganddrop-hashchange-history-audio-video-indexeddb-input-inputtypes-localstorage-postmessage-sessionstorage-websockets-websqldatabase-webworkers-geolocation-inlinesvg-smil-svg-svgclippaths-touch-webgl-mq-cssclasses-teststyles-testprop-testallprops-hasevent-prefixes-domprefixes-load
 */

/* jshint ignore:start */

;

window.Modernizr = (function( window, document, undefined ) {
    var version = '2.8.3',
    Modernizr = {},
    enableClasses = true,
    docElement = document.documentElement,
    mod = 'modernizr',
    modElem = document.createElement(mod),
    mStyle = modElem.style,
    inputElem  = document.createElement('input')  ,
    smile = ':)',
    toString = {}.toString,
    prefixes = ' -webkit- -moz- -o- -ms- '.split(' '),

    omPrefixes = 'Webkit Moz O ms',
    cssomPrefixes = omPrefixes.split(' '),
    domPrefixes = omPrefixes.toLowerCase().split(' '),
    ns = {'svg': 'http://www.w3.org/2000/svg'},
    tests = {},
    inputs = {},
    attrs = {},
    classes = [],
    slice = classes.slice,
    featureName, 

    injectElementWithStyles = function( rule, callback, nodes, testnames ) {
      var style, ret, node, docOverflow,
          div = document.createElement('div'),
                body = document.body,
                fakeBody = body || document.createElement('body');
      if ( parseInt(nodes, 10) ) {
                      while ( nodes-- ) {
              node = document.createElement('div');
              node.id = testnames ? testnames[nodes] : mod + (nodes + 1);
              div.appendChild(node);
          }
      }
                style = ['&#173;','<style id="s', mod, '">', rule, '</style>'].join('');
      div.id = mod;
          (body ? div : fakeBody).innerHTML += style;
      fakeBody.appendChild(div);
      if ( !body ) {
                fakeBody.style.background = '';
                fakeBody.style.overflow = 'hidden';
          docOverflow = docElement.style.overflow;
          docElement.style.overflow = 'hidden';
          docElement.appendChild(fakeBody);
      }
      ret = callback(div, rule);
        if ( !body ) {
          fakeBody.parentNode.removeChild(fakeBody);
          docElement.style.overflow = docOverflow;
      } else {
          div.parentNode.removeChild(div);
      }
      return !!ret;
    },
    testMediaQuery = function( mq ) {
      var matchMedia = window.matchMedia || window.msMatchMedia;
      if ( matchMedia ) {
        return matchMedia(mq) && matchMedia(mq).matches || false;
      }
      var bool;
      injectElementWithStyles('@media ' + mq + ' { #' + mod + ' { position: absolute; } }', function( node ) {
        bool = (window.getComputedStyle ?
                  getComputedStyle(node, null) :
                  node.currentStyle)['position'] == 'absolute';
      });
      return bool;
     },
 
    isEventSupported = (function() {
      var TAGNAMES = {
        'select': 'input', 'change': 'input',
        'submit': 'form', 'reset': 'form',
        'error': 'img', 'load': 'img', 'abort': 'img'
      };
      function isEventSupported( eventName, element ) {
        element = element || document.createElement(TAGNAMES[eventName] || 'div');
        eventName = 'on' + eventName;
            var isSupported = eventName in element;
        if ( !isSupported ) {
                if ( !element.setAttribute ) {
            element = document.createElement('div');
          }
          if ( element.setAttribute && element.removeAttribute ) {
            element.setAttribute(eventName, '');
            isSupported = is(element[eventName], 'function');
                    if ( !is(element[eventName], 'undefined') ) {
              element[eventName] = undefined;
            }
            element.removeAttribute(eventName);
          }
        }
        element = null;
        return isSupported;
      }
      return isEventSupported;
    })(),

    _hasOwnProperty = ({}).hasOwnProperty, hasOwnProp;
    if ( !is(_hasOwnProperty, 'undefined') && !is(_hasOwnProperty.call, 'undefined') ) {
      hasOwnProp = function (object, property) {
        return _hasOwnProperty.call(object, property);
      };
    }
    else {
      hasOwnProp = function (object, property) { 
        return ((property in object) && is(object.constructor.prototype[property], 'undefined'));
      };
    }

    if (!Function.prototype.bind) {
      Function.prototype.bind = function bind(that) {
        var target = this;
        if (typeof target != "function") {
            throw new TypeError();
        }
        var args = slice.call(arguments, 1),
            bound = function () {
            if (this instanceof bound) {
              var F = function(){};
              F.prototype = target.prototype;
              var self = new F();
              var result = target.apply(
                  self,
                  args.concat(slice.call(arguments))
              );
              if (Object(result) === result) {
                  return result;
              }
              return self;
            } else {
              return target.apply(
                  that,
                  args.concat(slice.call(arguments))
              );
            }
        };
        return bound;
      };
    }
    function setCss( str ) {
        mStyle.cssText = str;
    }
    function setCssAll( str1, str2 ) {
        return setCss(prefixes.join(str1 + ';') + ( str2 || '' ));
    }
    function is( obj, type ) {
        return typeof obj === type;
    }
    function contains( str, substr ) {
        return !!~('' + str).indexOf(substr);
    }
    function testProps( props, prefixed ) {
        for ( var i in props ) {
            var prop = props[i];
            if ( !contains(prop, "-") && mStyle[prop] !== undefined ) {
                return prefixed == 'pfx' ? prop : true;
            }
        }
        return false;
    }
    function testDOMProps( props, obj, elem ) {
        for ( var i in props ) {
            var item = obj[props[i]];
            if ( item !== undefined) {
                            if (elem === false) return props[i];
                            if (is(item, 'function')){
                                return item.bind(elem || obj);
                }
                            return item;
            }
        }
        return false;
    }
    function testPropsAll( prop, prefixed, elem ) {
        var ucProp  = prop.charAt(0).toUpperCase() + prop.slice(1),
            props   = (prop + ' ' + cssomPrefixes.join(ucProp + ' ') + ucProp).split(' ');
            if(is(prefixed, "string") || is(prefixed, "undefined")) {
          return testProps(props, prefixed);
            } else {
          props = (prop + ' ' + (domPrefixes).join(ucProp + ' ') + ucProp).split(' ');
          return testDOMProps(props, prefixed, elem);
        }
    }    tests['flexbox'] = function() {
      return testPropsAll('flexWrap');
    };

    tests['flexboxlegacy'] = function() {
        return testPropsAll('boxDirection');
    };

    tests['canvas'] = function() {
        var elem = document.createElement('canvas');
        return !!(elem.getContext && elem.getContext('2d'));
    };
    tests['canvastext'] = function() {
        return !!(Modernizr['canvas'] && is(document.createElement('canvas').getContext('2d').fillText, 'function'));
    };

    tests['webgl'] = function() {
        return !!window.WebGLRenderingContext;
    };

    tests['touch'] = function() {
        var bool;
        if(('ontouchstart' in window) || window.DocumentTouch && document instanceof DocumentTouch) {
          bool = true;
        } else {
          injectElementWithStyles(['@media (',prefixes.join('touch-enabled),('),mod,')','{#modernizr{top:9px;position:absolute}}'].join(''), function( node ) {
            bool = node.offsetTop === 9;
          });
        }
        return bool;
    };

    tests['geolocation'] = function() {
        return 'geolocation' in navigator;
    };

    tests['postmessage'] = function() {
      return !!window.postMessage;
    };

    tests['websqldatabase'] = function() {
      return !!window.openDatabase;
    };
    tests['indexedDB'] = function() {
      return !!testPropsAll("indexedDB", window);
    };
    tests['hashchange'] = function() {
      return isEventSupported('hashchange', window) && (document.documentMode === undefined || document.documentMode > 7);
    };
    tests['history'] = function() {
      return !!(window.history && history.pushState);
    };
    tests['draganddrop'] = function() {
        var div = document.createElement('div');
        return ('draggable' in div) || ('ondragstart' in div && 'ondrop' in div);
    };
    tests['websockets'] = function() {
        return 'WebSocket' in window || 'MozWebSocket' in window;
    };

    tests['rgba'] = function() {
        setCss('background-color:rgba(150,255,150,.5)');
        return contains(mStyle.backgroundColor, 'rgba');
    };
    tests['hsla'] = function() {
            setCss('background-color:hsla(120,40%,100%,.5)');
        return contains(mStyle.backgroundColor, 'rgba') || contains(mStyle.backgroundColor, 'hsla');
    };
    tests['multiplebgs'] = function() {
                setCss('background:url(https://),url(https://),red url(https://)');
            return (/(url\s*\(.*?){3}/).test(mStyle.background);
    };    tests['backgroundsize'] = function() {
        return testPropsAll('backgroundSize');
    };
    tests['borderimage'] = function() {
        return testPropsAll('borderImage');
    };

    tests['borderradius'] = function() {
        return testPropsAll('borderRadius');
    };
    tests['boxshadow'] = function() {
        return testPropsAll('boxShadow');
    };
    tests['textshadow'] = function() {
        return document.createElement('div').style.textShadow === '';
    };

    tests['opacity'] = function() {
                setCssAll('opacity:.55');
                    return (/^0.55$/).test(mStyle.opacity);
    };

    tests['cssanimations'] = function() {
        return testPropsAll('animationName');
    };

    tests['csscolumns'] = function() {
        return testPropsAll('columnCount');
    };

    tests['cssgradients'] = function() {
        var str1 = 'background-image:',
            str2 = 'gradient(linear,left top,right bottom,from(#9f9),to(white));',
            str3 = 'linear-gradient(left top,#9f9, white);';
        setCss(
                       (str1 + '-webkit- '.split(' ').join(str2 + str1) +
                       prefixes.join(str3 + str1)).slice(0, -str1.length)
        );
        return contains(mStyle.backgroundImage, 'gradient');
    };

    tests['cssreflections'] = function() {
        return testPropsAll('boxReflect');
    };

    tests['csstransforms'] = function() {
        return !!testPropsAll('transform');
    };

    tests['csstransforms3d'] = function() {
        var ret = !!testPropsAll('perspective');
                        if ( ret && 'webkitPerspective' in docElement.style ) {
                      injectElementWithStyles('@media (transform-3d),(-webkit-transform-3d){#modernizr{left:9px;position:absolute;height:3px;}}', function( node, rule ) {
            ret = node.offsetLeft === 9 && node.offsetHeight === 3;
          });
        }
        return ret;
    };

    tests['csstransitions'] = function() {
        return testPropsAll('transition');
    };

    tests['fontface'] = function() {
        var bool;
        injectElementWithStyles('@font-face {font-family:"font";src:url("https://")}', function( node, rule ) {
          var style = document.getElementById('smodernizr'),
              sheet = style.sheet || style.styleSheet,
              cssText = sheet ? (sheet.cssRules && sheet.cssRules[0] ? sheet.cssRules[0].cssText : sheet.cssText || '') : '';
          bool = /src/i.test(cssText) && cssText.indexOf(rule.split(' ')[0]) === 0;
        });
        return bool;
    };
    tests['generatedcontent'] = function() {
        var bool;
        injectElementWithStyles(['#',mod,'{font:0/0 a}#',mod,':after{content:"',smile,'";visibility:hidden;font:3px/1 a}'].join(''), function( node ) {
          bool = node.offsetHeight >= 3;
        });
        return bool;
    };
    tests['video'] = function() {
        var elem = document.createElement('video'),
            bool = false;
            try {
            if ( bool = !!elem.canPlayType ) {
                bool      = new Boolean(bool);
                bool.ogg  = elem.canPlayType('video/ogg; codecs="theora"')      .replace(/^no$/,'');
                            bool.h264 = elem.canPlayType('video/mp4; codecs="avc1.42E01E"') .replace(/^no$/,'');
                bool.webm = elem.canPlayType('video/webm; codecs="vp8, vorbis"').replace(/^no$/,'');
            }
        } catch(e) { }
        return bool;
    };
    tests['audio'] = function() {
        var elem = document.createElement('audio'),
            bool = false;
        try {
            if ( bool = !!elem.canPlayType ) {
                bool      = new Boolean(bool);
                bool.ogg  = elem.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/,'');
                bool.mp3  = elem.canPlayType('audio/mpeg;')               .replace(/^no$/,'');
                                                    bool.wav  = elem.canPlayType('audio/wav; codecs="1"')     .replace(/^no$/,'');
                bool.m4a  = ( elem.canPlayType('audio/x-m4a;')            ||
                              elem.canPlayType('audio/aac;'))             .replace(/^no$/,'');
            }
        } catch(e) { }
        return bool;
    };

    tests['localstorage'] = function() {
        try {
            localStorage.setItem(mod, mod);
            localStorage.removeItem(mod);
            return true;
        } catch(e) {
            return false;
        }
    };
    tests['sessionstorage'] = function() {
        try {
            sessionStorage.setItem(mod, mod);
            sessionStorage.removeItem(mod);
            return true;
        } catch(e) {
            return false;
        }
    };

    tests['webworkers'] = function() {
        return !!window.Worker;
    };

    tests['applicationcache'] = function() {
        return !!window.applicationCache;
    };

    tests['svg'] = function() {
        return !!document.createElementNS && !!document.createElementNS(ns.svg, 'svg').createSVGRect;
    };
    tests['inlinesvg'] = function() {
      var div = document.createElement('div');
      div.innerHTML = '<svg/>';
      return (div.firstChild && div.firstChild.namespaceURI) == ns.svg;
    };
    tests['smil'] = function() {
        return !!document.createElementNS && /SVGAnimate/.test(toString.call(document.createElementNS(ns.svg, 'animate')));
    };

    tests['svgclippaths'] = function() {
        return !!document.createElementNS && /SVGClipPath/.test(toString.call(document.createElementNS(ns.svg, 'clipPath')));
    };
    function webforms() {
                                            Modernizr['input'] = (function( props ) {
            for ( var i = 0, len = props.length; i < len; i++ ) {
                attrs[ props[i] ] = !!(props[i] in inputElem);
            }
            if (attrs.list){
                                  attrs.list = !!(document.createElement('datalist') && window.HTMLDataListElement);
            }
            return attrs;
        })('autocomplete autofocus list placeholder max min multiple pattern required step'.split(' '));
                            Modernizr['inputtypes'] = (function(props) {
            for ( var i = 0, bool, inputElemType, defaultView, len = props.length; i < len; i++ ) {
                inputElem.setAttribute('type', inputElemType = props[i]);
                bool = inputElem.type !== 'text';
                                                    if ( bool ) {
                    inputElem.value         = smile;
                    inputElem.style.cssText = 'position:absolute;visibility:hidden;';
                    if ( /^range$/.test(inputElemType) && inputElem.style.WebkitAppearance !== undefined ) {
                      docElement.appendChild(inputElem);
                      defaultView = document.defaultView;
                                        bool =  defaultView.getComputedStyle &&
                              defaultView.getComputedStyle(inputElem, null).WebkitAppearance !== 'textfield' &&
                                                                                  (inputElem.offsetHeight !== 0);
                      docElement.removeChild(inputElem);
                    } else if ( /^(search|tel)$/.test(inputElemType) ){
                                                                                    } else if ( /^(url|email)$/.test(inputElemType) ) {
                                        bool = inputElem.checkValidity && inputElem.checkValidity() === false;
                    } else {
                                        bool = inputElem.value != smile;
                    }
                }
                inputs[ props[i] ] = !!bool;
            }
            return inputs;
        })('search tel url email datetime date month week time datetime-local number range color'.split(' '));
        }
    for ( var feature in tests ) {
        if ( hasOwnProp(tests, feature) ) {
                                    featureName  = feature.toLowerCase();
            Modernizr[featureName] = tests[feature]();
            classes.push((Modernizr[featureName] ? '' : 'no-') + featureName);
        }
    }
    Modernizr.input || webforms();

     Modernizr.addTest = function ( feature, test ) {
       if ( typeof feature == 'object' ) {
         for ( var key in feature ) {
           if ( hasOwnProp( feature, key ) ) {
             Modernizr.addTest( key, feature[ key ] );
           }
         }
       } else {
         feature = feature.toLowerCase();
         if ( Modernizr[feature] !== undefined ) {
                                              return Modernizr;
         }
         test = typeof test == 'function' ? test() : test;
         if (typeof enableClasses !== "undefined" && enableClasses) {
           docElement.className += ' ' + (test ? '' : 'no-') + feature;
         }
         Modernizr[feature] = test;
       }
       return Modernizr; 
     };

    setCss('');
    modElem = inputElem = null;

    Modernizr._version      = version;
    Modernizr._prefixes     = prefixes;
    Modernizr._domPrefixes  = domPrefixes;
    Modernizr._cssomPrefixes  = cssomPrefixes;
    Modernizr.mq            = testMediaQuery;
    Modernizr.hasEvent      = isEventSupported;
    Modernizr.testProp      = function(prop){
        return testProps([prop]);
    };
    Modernizr.testAllProps  = testPropsAll;

    Modernizr.testStyles    = injectElementWithStyles;    docElement.className = docElement.className.replace(/(^|\s)no-js(\s|$)/, '$1$2') +
                                                    (enableClasses ? ' js ' + classes.join(' ') : '');
    return Modernizr;
})(this, this.document);
/*yepnope1.5.4|WTFPL*/
(function(a,b,c){function d(a){return"[object Function]"==o.call(a)}function e(a){return"string"==typeof a}function f(){}function g(a){return!a||"loaded"==a||"complete"==a||"uninitialized"==a}function h(){var a=p.shift();q=1,a?a.t?m(function(){("c"==a.t?B.injectCss:B.injectJs)(a.s,0,a.a,a.x,a.e,1)},0):(a(),h()):q=0}function i(a,c,d,e,f,i,j){function k(b){if(!o&&g(l.readyState)&&(u.r=o=1,!q&&h(),l.onload=l.onreadystatechange=null,b)){"img"!=a&&m(function(){t.removeChild(l)},50);for(var d in y[c])y[c].hasOwnProperty(d)&&y[c][d].onload()}}var j=j||B.errorTimeout,l=b.createElement(a),o=0,r=0,u={t:d,s:c,e:f,a:i,x:j};1===y[c]&&(r=1,y[c]=[]),"object"==a?l.data=c:(l.src=c,l.type=a),l.width=l.height="0",l.onerror=l.onload=l.onreadystatechange=function(){k.call(this,r)},p.splice(e,0,u),"img"!=a&&(r||2===y[c]?(t.insertBefore(l,s?null:n),m(k,j)):y[c].push(l))}function j(a,b,c,d,f){return q=0,b=b||"j",e(a)?i("c"==b?v:u,a,b,this.i++,c,d,f):(p.splice(this.i++,0,a),1==p.length&&h()),this}function k(){var a=B;return a.loader={load:j,i:0},a}var l=b.documentElement,m=a.setTimeout,n=b.getElementsByTagName("script")[0],o={}.toString,p=[],q=0,r="MozAppearance"in l.style,s=r&&!!b.createRange().compareNode,t=s?l:n.parentNode,l=a.opera&&"[object Opera]"==o.call(a.opera),l=!!b.attachEvent&&!l,u=r?"object":l?"script":"img",v=l?"script":u,w=Array.isArray||function(a){return"[object Array]"==o.call(a)},x=[],y={},z={timeout:function(a,b){return b.length&&(a.timeout=b[0]),a}},A,B;B=function(a){function b(a){var a=a.split("!"),b=x.length,c=a.pop(),d=a.length,c={url:c,origUrl:c,prefixes:a},e,f,g;for(f=0;f<d;f++)g=a[f].split("="),(e=z[g.shift()])&&(c=e(c,g));for(f=0;f<b;f++)c=x[f](c);return c}function g(a,e,f,g,h){var i=b(a),j=i.autoCallback;i.url.split(".").pop().split("?").shift(),i.bypass||(e&&(e=d(e)?e:e[a]||e[g]||e[a.split("/").pop().split("?")[0]]),i.instead?i.instead(a,e,f,g,h):(y[i.url]?i.noexec=!0:y[i.url]=1,f.load(i.url,i.forceCSS||!i.forceJS&&"css"==i.url.split(".").pop().split("?").shift()?"c":c,i.noexec,i.attrs,i.timeout),(d(e)||d(j))&&f.load(function(){k(),e&&e(i.origUrl,h,g),j&&j(i.origUrl,h,g),y[i.url]=2})))}function h(a,b){function c(a,c){if(a){if(e(a))c||(j=function(){var a=[].slice.call(arguments);k.apply(this,a),l()}),g(a,j,b,0,h);else if(Object(a)===a)for(n in m=function(){var b=0,c;for(c in a)a.hasOwnProperty(c)&&b++;return b}(),a)a.hasOwnProperty(n)&&(!c&&!--m&&(d(j)?j=function(){var a=[].slice.call(arguments);k.apply(this,a),l()}:j[n]=function(a){return function(){var b=[].slice.call(arguments);a&&a.apply(this,b),l()}}(k[n])),g(a[n],j,b,n,h))}else!c&&l()}var h=!!a.test,i=a.load||a.both,j=a.callback||f,k=j,l=a.complete||f,m,n;c(h?a.yep:a.nope,!!i),i&&c(i)}var i,j,l=this.yepnope.loader;if(e(a))g(a,0,l,0);else if(w(a))for(i=0;i<a.length;i++)j=a[i],e(j)?g(j,0,l,0):w(j)?B(j):Object(j)===j&&h(j,l);else Object(a)===a&&h(a,l)},B.addPrefix=function(a,b){z[a]=b},B.addFilter=function(a){x.push(a)},B.errorTimeout=1e4,null==b.readyState&&b.addEventListener&&(b.readyState="loading",b.addEventListener("DOMContentLoaded",A=function(){b.removeEventListener("DOMContentLoaded",A,0),b.readyState="complete"},0)),a.yepnope=k(),a.yepnope.executeStack=h,a.yepnope.injectJs=function(a,c,d,e,i,j){var k=b.createElement("script"),l,o,e=e||B.errorTimeout;k.src=a;for(o in d)k.setAttribute(o,d[o]);c=j?h:c||f,k.onreadystatechange=k.onload=function(){!l&&g(k.readyState)&&(l=1,c(),k.onload=k.onreadystatechange=null)},m(function(){l||(l=1,c(1))},e),i?k.onload():n.parentNode.insertBefore(k,n)},a.yepnope.injectCss=function(a,c,d,e,g,i){var e=b.createElement("link"),j,c=i?h:c||f;e.href=a,e.rel="stylesheet",e.type="text/css";for(j in d)e.setAttribute(j,d[j]);g||(n.parentNode.insertBefore(e,n),m(c,0))}})(this,document);
Modernizr.load=function(){yepnope.apply(window,[].slice.call(arguments,0));};
;


/* jshint ignore:end */;

/* jshint ignore:start */
/**

	jQuery 1.11.1 script + a custom fix. 
	<br />Used for IBM core JS foundation.
	<br />Official documentation at <a href="http://jquery.com/" target="_blank">http://jquery.com/</a>.

	@module jQuery
	@main jQuery
	@class jQuery

**/
/**

	SANTELIA: IMPORTANT NOTE: 
		This is jQuery 1.11.1 but with a patch for IE7.
		
		Line 8094 has to be wrapped in a try/catch, else JS no workie in IE7.
		Was:  
			ret.value = value += "";
		Is now: 
			try {
				ret.value = value += "";
			}
			catch( e ) {}

**/

/*!
 * jQuery JavaScript Library v1.11.1
 * http://jquery.com/
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 *
 * Copyright 2005, 2014 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2014-05-01T17:42Z
 */

(function( global, factory ) {

    if ( typeof module === "object" && typeof module.exports === "object" ) {
        // For CommonJS and CommonJS-like environments where a proper window is present,
        // execute the factory and get jQuery
        // For environments that do not inherently posses a window with a document
        // (such as Node.js), expose a jQuery-making factory as module.exports
        // This accentuates the need for the creation of a real window
        // e.g. var jQuery = require("jquery")(window);
        // See ticket #14549 for more info
        module.exports = global.document ?
            factory( global, true ) :
            function( w ) {
                if ( !w.document ) {
                    throw new Error( "jQuery requires a window with a document" );
                }
                return factory( w );
            };
    } else {
        factory( global );
    }

// Pass this if window is not defined yet
}(typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Can't do this because several apps including ASP.NET trace
// the stack via arguments.caller.callee and Firefox dies if
// you try to trace through "use strict" call chains. (#13335)
// Support: Firefox 18+
//

var deletedIds = [];

var slice = deletedIds.slice;

var concat = deletedIds.concat;

var push = deletedIds.push;

var indexOf = deletedIds.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var support = {};



var
    version = "1.11.1",

    // Define a local copy of jQuery
    jQuery = function( selector, context ) {
        // The jQuery object is actually just the init constructor 'enhanced'
        // Need init if jQuery is called (just allow error to be thrown if not included)
        return new jQuery.fn.init( selector, context );
    },

    // Support: Android<4.1, IE<9
    // Make sure we trim BOM and NBSP
    rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

    // Matches dashed string for camelizing
    rmsPrefix = /^-ms-/,
    rdashAlpha = /-([\da-z])/gi,

    // Used by jQuery.camelCase as callback to replace()
    fcamelCase = function( all, letter ) {
        return letter.toUpperCase();
    };

jQuery.fn = jQuery.prototype = {
    // The current version of jQuery being used
    jquery: version,

    constructor: jQuery,

    // Start with an empty selector
    selector: "",

    // The default length of a jQuery object is 0
    length: 0,

    toArray: function() {
        return slice.call( this );
    },

    // Get the Nth element in the matched element set OR
    // Get the whole matched element set as a clean array
    get: function( num ) {
        return num != null ?

            // Return just the one element from the set
            ( num < 0 ? this[ num + this.length ] : this[ num ] ) :

            // Return all the elements in a clean array
            slice.call( this );
    },

    // Take an array of elements and push it onto the stack
    // (returning the new matched element set)
    pushStack: function( elems ) {

        // Build a new jQuery matched element set
        var ret = jQuery.merge( this.constructor(), elems );

        // Add the old object onto the stack (as a reference)
        ret.prevObject = this;
        ret.context = this.context;

        // Return the newly-formed element set
        return ret;
    },

    // Execute a callback for every element in the matched set.
    // (You can seed the arguments with an array of args, but this is
    // only used internally.)
    each: function( callback, args ) {
        return jQuery.each( this, callback, args );
    },

    map: function( callback ) {
        return this.pushStack( jQuery.map(this, function( elem, i ) {
            return callback.call( elem, i, elem );
        }));
    },

    slice: function() {
        return this.pushStack( slice.apply( this, arguments ) );
    },

    first: function() {
        return this.eq( 0 );
    },

    last: function() {
        return this.eq( -1 );
    },

    eq: function( i ) {
        var len = this.length,
            j = +i + ( i < 0 ? len : 0 );
        return this.pushStack( j >= 0 && j < len ? [ this[j] ] : [] );
    },

    end: function() {
        return this.prevObject || this.constructor(null);
    },

    // For internal use only.
    // Behaves like an Array's method, not like a jQuery method.
    push: push,
    sort: deletedIds.sort,
    splice: deletedIds.splice
};

jQuery.extend = jQuery.fn.extend = function() {
    var src, copyIsArray, copy, name, options, clone,
        target = arguments[0] || {},
        i = 1,
        length = arguments.length,
        deep = false;

    // Handle a deep copy situation
    if ( typeof target === "boolean" ) {
        deep = target;

        // skip the boolean and the target
        target = arguments[ i ] || {};
        i++;
    }

    // Handle case when target is a string or something (possible in deep copy)
    if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
        target = {};
    }

    // extend jQuery itself if only one argument is passed
    if ( i === length ) {
        target = this;
        i--;
    }

    for ( ; i < length; i++ ) {
        // Only deal with non-null/undefined values
        if ( (options = arguments[ i ]) != null ) {
            // Extend the base object
            for ( name in options ) {
                src = target[ name ];
                copy = options[ name ];

                // Prevent never-ending loop
                if ( target === copy ) {
                    continue;
                }

                // Recurse if we're merging plain objects or arrays
                if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
                    if ( copyIsArray ) {
                        copyIsArray = false;
                        clone = src && jQuery.isArray(src) ? src : [];

                    } else {
                        clone = src && jQuery.isPlainObject(src) ? src : {};
                    }

                    // Never move original objects, clone them
                    target[ name ] = jQuery.extend( deep, clone, copy );

                // Don't bring in undefined values
                } else if ( copy !== undefined ) {
                    target[ name ] = copy;
                }
            }
        }
    }

    // Return the modified object
    return target;
};

jQuery.extend({
    // Unique for each copy of jQuery on the page
    expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

    // Assume jQuery is ready without the ready module
    isReady: true,

    error: function( msg ) {
        throw new Error( msg );
    },

    noop: function() {},

    // See test/unit/core.js for details concerning isFunction.
    // Since version 1.3, DOM methods and functions like alert
    // aren't supported. They return false on IE (#2968).
    isFunction: function( obj ) {
        return jQuery.type(obj) === "function";
    },

    isArray: Array.isArray || function( obj ) {
        return jQuery.type(obj) === "array";
    },

    isWindow: function( obj ) {
        /* jshint eqeqeq: false */
        return obj != null && obj == obj.window;
    },

    isNumeric: function( obj ) {
        // parseFloat NaNs numeric-cast false positives (null|true|false|"")
        // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
        // subtraction forces infinities to NaN
        return !jQuery.isArray( obj ) && obj - parseFloat( obj ) >= 0;
    },

    isEmptyObject: function( obj ) {
        var name;
        for ( name in obj ) {
            return false;
        }
        return true;
    },

    isPlainObject: function( obj ) {
        var key;

        // Must be an Object.
        // Because of IE, we also have to check the presence of the constructor property.
        // Make sure that DOM nodes and window objects don't pass through, as well
        if ( !obj || jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
            return false;
        }

        try {
            // Not own constructor property must be Object
            if ( obj.constructor &&
                !hasOwn.call(obj, "constructor") &&
                !hasOwn.call(obj.constructor.prototype, "isPrototypeOf") ) {
                return false;
            }
        } catch ( e ) {
            // IE8,9 Will throw exceptions on certain host objects #9897
            return false;
        }

        // Support: IE<9
        // Handle iteration over inherited properties before own properties.
        if ( support.ownLast ) {
            for ( key in obj ) {
                return hasOwn.call( obj, key );
            }
        }

        // Own properties are enumerated firstly, so to speed up,
        // if last one is own, then all properties are own.
        for ( key in obj ) {}

        return key === undefined || hasOwn.call( obj, key );
    },

    type: function( obj ) {
        if ( obj == null ) {
            return obj + "";
        }
        return typeof obj === "object" || typeof obj === "function" ?
            class2type[ toString.call(obj) ] || "object" :
            typeof obj;
    },

    // Evaluates a script in a global context
    // Workarounds based on findings by Jim Driscoll
    // http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context
    globalEval: function( data ) {
        if ( data && jQuery.trim( data ) ) {
            // We use execScript on Internet Explorer
            // We use an anonymous function so that context is window
            // rather than jQuery in Firefox
            ( window.execScript || function( data ) {
                window[ "eval" ].call( window, data );
            } )( data );
        }
    },

    // Convert dashed to camelCase; used by the css and data modules
    // Microsoft forgot to hump their vendor prefix (#9572)
    camelCase: function( string ) {
        return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
    },

    nodeName: function( elem, name ) {
        return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
    },

    // args is for internal usage only
    each: function( obj, callback, args ) {
        var value,
            i = 0,
            length = obj.length,
            isArray = isArraylike( obj );

        if ( args ) {
            if ( isArray ) {
                for ( ; i < length; i++ ) {
                    value = callback.apply( obj[ i ], args );

                    if ( value === false ) {
                        break;
                    }
                }
            } else {
                for ( i in obj ) {
                    value = callback.apply( obj[ i ], args );

                    if ( value === false ) {
                        break;
                    }
                }
            }

        // A special, fast, case for the most common use of each
        } else {
            if ( isArray ) {
                for ( ; i < length; i++ ) {
                    value = callback.call( obj[ i ], i, obj[ i ] );

                    if ( value === false ) {
                        break;
                    }
                }
            } else {
                for ( i in obj ) {
                    value = callback.call( obj[ i ], i, obj[ i ] );

                    if ( value === false ) {
                        break;
                    }
                }
            }
        }

        return obj;
    },

    // Support: Android<4.1, IE<9
    trim: function( text ) {
        return text == null ?
            "" :
            ( text + "" ).replace( rtrim, "" );
    },

    // results is for internal usage only
    makeArray: function( arr, results ) {
        var ret = results || [];

        if ( arr != null ) {
            if ( isArraylike( Object(arr) ) ) {
                jQuery.merge( ret,
                    typeof arr === "string" ?
                    [ arr ] : arr
                );
            } else {
                push.call( ret, arr );
            }
        }

        return ret;
    },

    inArray: function( elem, arr, i ) {
        var len;

        if ( arr ) {
            if ( indexOf ) {
                return indexOf.call( arr, elem, i );
            }

            len = arr.length;
            i = i ? i < 0 ? Math.max( 0, len + i ) : i : 0;

            for ( ; i < len; i++ ) {
                // Skip accessing in sparse arrays
                if ( i in arr && arr[ i ] === elem ) {
                    return i;
                }
            }
        }

        return -1;
    },

    merge: function( first, second ) {
        var len = +second.length,
            j = 0,
            i = first.length;

        while ( j < len ) {
            first[ i++ ] = second[ j++ ];
        }

        // Support: IE<9
        // Workaround casting of .length to NaN on otherwise arraylike objects (e.g., NodeLists)
        if ( len !== len ) {
            while ( second[j] !== undefined ) {
                first[ i++ ] = second[ j++ ];
            }
        }

        first.length = i;

        return first;
    },

    grep: function( elems, callback, invert ) {
        var callbackInverse,
            matches = [],
            i = 0,
            length = elems.length,
            callbackExpect = !invert;

        // Go through the array, only saving the items
        // that pass the validator function
        for ( ; i < length; i++ ) {
            callbackInverse = !callback( elems[ i ], i );
            if ( callbackInverse !== callbackExpect ) {
                matches.push( elems[ i ] );
            }
        }

        return matches;
    },

    // arg is for internal usage only
    map: function( elems, callback, arg ) {
        var value,
            i = 0,
            length = elems.length,
            isArray = isArraylike( elems ),
            ret = [];

        // Go through the array, translating each of the items to their new values
        if ( isArray ) {
            for ( ; i < length; i++ ) {
                value = callback( elems[ i ], i, arg );

                if ( value != null ) {
                    ret.push( value );
                }
            }

        // Go through every key on the object,
        } else {
            for ( i in elems ) {
                value = callback( elems[ i ], i, arg );

                if ( value != null ) {
                    ret.push( value );
                }
            }
        }

        // Flatten any nested arrays
        return concat.apply( [], ret );
    },

    // A global GUID counter for objects
    guid: 1,

    // Bind a function to a context, optionally partially applying any
    // arguments.
    proxy: function( fn, context ) {
        var args, proxy, tmp;

        if ( typeof context === "string" ) {
            tmp = fn[ context ];
            context = fn;
            fn = tmp;
        }

        // Quick check to determine if target is callable, in the spec
        // this throws a TypeError, but we will just return undefined.
        if ( !jQuery.isFunction( fn ) ) {
            return undefined;
        }

        // Simulated bind
        args = slice.call( arguments, 2 );
        proxy = function() {
            return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
        };

        // Set the guid of unique handler to the same of original handler, so it can be removed
        proxy.guid = fn.guid = fn.guid || jQuery.guid++;

        return proxy;
    },

    now: function() {
        return +( new Date() );
    },

    // jQuery.support is not used in Core but other projects attach their
    // properties to it so it needs to exist.
    support: support
});

// Populate the class2type map
jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {
    class2type[ "[object " + name + "]" ] = name.toLowerCase();
});

function isArraylike( obj ) {
    var length = obj.length,
        type = jQuery.type( obj );

    if ( type === "function" || jQuery.isWindow( obj ) ) {
        return false;
    }

    if ( obj.nodeType === 1 && length ) {
        return true;
    }

    return type === "array" || length === 0 ||
        typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v1.10.19
 * http://sizzlejs.com/
 *
 * Copyright 2013 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2014-04-18
 */
(function( window ) {

var i,
    support,
    Expr,
    getText,
    isXML,
    tokenize,
    compile,
    select,
    outermostContext,
    sortInput,
    hasDuplicate,

    // Local document vars
    setDocument,
    document,
    docElem,
    documentIsHTML,
    rbuggyQSA,
    rbuggyMatches,
    matches,
    contains,

    // Instance-specific data
    expando = "sizzle" + -(new Date()),
    preferredDoc = window.document,
    dirruns = 0,
    done = 0,
    classCache = createCache(),
    tokenCache = createCache(),
    compilerCache = createCache(),
    sortOrder = function( a, b ) {
        if ( a === b ) {
            hasDuplicate = true;
        }
        return 0;
    },

    // General-purpose constants
    strundefined = typeof undefined,
    MAX_NEGATIVE = 1 << 31,

    // Instance methods
    hasOwn = ({}).hasOwnProperty,
    arr = [],
    pop = arr.pop,
    push_native = arr.push,
    push = arr.push,
    slice = arr.slice,
    // Use a stripped-down indexOf if we can't use a native one
    indexOf = arr.indexOf || function( elem ) {
        var i = 0,
            len = this.length;
        for ( ; i < len; i++ ) {
            if ( this[i] === elem ) {
                return i;
            }
        }
        return -1;
    },

    booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

    // Regular expressions

    // Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
    whitespace = "[\\x20\\t\\r\\n\\f]",
    // http://www.w3.org/TR/css3-syntax/#characters
    characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",

    // Loosely modeled on CSS identifier characters
    // An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors
    // Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
    identifier = characterEncoding.replace( "w", "w#" ),

    // Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
    attributes = "\\[" + whitespace + "*(" + characterEncoding + ")(?:" + whitespace +
        // Operator (capture 2)
        "*([*^$|!~]?=)" + whitespace +
        // "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
        "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
        "*\\]",

    pseudos = ":(" + characterEncoding + ")(?:\\((" +
        // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
        // 1. quoted (capture 3; capture 4 or capture 5)
        "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
        // 2. simple (capture 6)
        "((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
        // 3. anything else (capture 2)
        ".*" +
        ")\\)|)",

    // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
    rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

    rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
    rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

    rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

    rpseudo = new RegExp( pseudos ),
    ridentifier = new RegExp( "^" + identifier + "$" ),

    matchExpr = {
        "ID": new RegExp( "^#(" + characterEncoding + ")" ),
        "CLASS": new RegExp( "^\\.(" + characterEncoding + ")" ),
        "TAG": new RegExp( "^(" + characterEncoding.replace( "w", "w*" ) + ")" ),
        "ATTR": new RegExp( "^" + attributes ),
        "PSEUDO": new RegExp( "^" + pseudos ),
        "CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
            "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
            "*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
        "bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
        // For use in libraries implementing .is()
        // We use this for POS matching in `select`
        "needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
            whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
    },

    rinputs = /^(?:input|select|textarea|button)$/i,
    rheader = /^h\d$/i,

    rnative = /^[^{]+\{\s*\[native \w/,

    // Easily-parseable/retrievable ID or TAG or CLASS selectors
    rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

    rsibling = /[+~]/,
    rescape = /'|\\/g,

    // CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
    runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
    funescape = function( _, escaped, escapedWhitespace ) {
        var high = "0x" + escaped - 0x10000;
        // NaN means non-codepoint
        // Support: Firefox<24
        // Workaround erroneous numeric interpretation of +"0x"
        return high !== high || escapedWhitespace ?
            escaped :
            high < 0 ?
                // BMP codepoint
                String.fromCharCode( high + 0x10000 ) :
                // Supplemental Plane codepoint (surrogate pair)
                String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
    };

// Optimize for push.apply( _, NodeList )
try {
    push.apply(
        (arr = slice.call( preferredDoc.childNodes )),
        preferredDoc.childNodes
    );
    // Support: Android<4.0
    // Detect silently failing push.apply
    arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
    push = { apply: arr.length ?

        // Leverage slice if possible
        function( target, els ) {
            push_native.apply( target, slice.call(els) );
        } :

        // Support: IE<9
        // Otherwise append directly
        function( target, els ) {
            var j = target.length,
                i = 0;
            // Can't trust NodeList.length
            while ( (target[j++] = els[i++]) ) {}
            target.length = j - 1;
        }
    };
}

function Sizzle( selector, context, results, seed ) {
    var match, elem, m, nodeType,
        // QSA vars
        i, groups, old, nid, newContext, newSelector;

    if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
        setDocument( context );
    }

    context = context || document;
    results = results || [];

    if ( !selector || typeof selector !== "string" ) {
        return results;
    }

    if ( (nodeType = context.nodeType) !== 1 && nodeType !== 9 ) {
        return [];
    }

    if ( documentIsHTML && !seed ) {

        // Shortcuts
        if ( (match = rquickExpr.exec( selector )) ) {
            // Speed-up: Sizzle("#ID")
            if ( (m = match[1]) ) {
                if ( nodeType === 9 ) {
                    elem = context.getElementById( m );
                    // Check parentNode to catch when Blackberry 4.6 returns
                    // nodes that are no longer in the document (jQuery #6963)
                    if ( elem && elem.parentNode ) {
                        // Handle the case where IE, Opera, and Webkit return items
                        // by name instead of ID
                        if ( elem.id === m ) {
                            results.push( elem );
                            return results;
                        }
                    } else {
                        return results;
                    }
                } else {
                    // Context is not a document
                    if ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&
                        contains( context, elem ) && elem.id === m ) {
                        results.push( elem );
                        return results;
                    }
                }

            // Speed-up: Sizzle("TAG")
            } else if ( match[2] ) {
                push.apply( results, context.getElementsByTagName( selector ) );
                return results;

            // Speed-up: Sizzle(".CLASS")
            } else if ( (m = match[3]) && support.getElementsByClassName && context.getElementsByClassName ) {
                push.apply( results, context.getElementsByClassName( m ) );
                return results;
            }
        }

        // QSA path
        if ( support.qsa && (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {
            nid = old = expando;
            newContext = context;
            newSelector = nodeType === 9 && selector;

            // qSA works strangely on Element-rooted queries
            // We can work around this by specifying an extra ID on the root
            // and working up from there (Thanks to Andrew Dupont for the technique)
            // IE 8 doesn't work on object elements
            if ( nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
                groups = tokenize( selector );

                if ( (old = context.getAttribute("id")) ) {
                    nid = old.replace( rescape, "\\$&" );
                } else {
                    context.setAttribute( "id", nid );
                }
                nid = "[id='" + nid + "'] ";

                i = groups.length;
                while ( i-- ) {
                    groups[i] = nid + toSelector( groups[i] );
                }
                newContext = rsibling.test( selector ) && testContext( context.parentNode ) || context;
                newSelector = groups.join(",");
            }

            if ( newSelector ) {
                try {
                    push.apply( results,
                        newContext.querySelectorAll( newSelector )
                    );
                    return results;
                } catch(qsaError) {
                } finally {
                    if ( !old ) {
                        context.removeAttribute("id");
                    }
                }
            }
        }
    }

    // All others
    return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {Function(string, Object)} Returns the Object data after storing it on itself with
 *  property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *  deleting the oldest entry
 */
function createCache() {
    var keys = [];

    function cache( key, value ) {
        // Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
        if ( keys.push( key + " " ) > Expr.cacheLength ) {
            // Only keep the most recent entries
            delete cache[ keys.shift() ];
        }
        return (cache[ key + " " ] = value);
    }
    return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
    fn[ expando ] = true;
    return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created div and expects a boolean result
 */
function assert( fn ) {
    var div = document.createElement("div");

    try {
        return !!fn( div );
    } catch (e) {
        return false;
    } finally {
        // Remove from its parent by default
        if ( div.parentNode ) {
            div.parentNode.removeChild( div );
        }
        // release memory in IE
        div = null;
    }
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
    var arr = attrs.split("|"),
        i = attrs.length;

    while ( i-- ) {
        Expr.attrHandle[ arr[i] ] = handler;
    }
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
    var cur = b && a,
        diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
            ( ~b.sourceIndex || MAX_NEGATIVE ) -
            ( ~a.sourceIndex || MAX_NEGATIVE );

    // Use IE sourceIndex if available on both nodes
    if ( diff ) {
        return diff;
    }

    // Check if b follows a
    if ( cur ) {
        while ( (cur = cur.nextSibling) ) {
            if ( cur === b ) {
                return -1;
            }
        }
    }

    return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
    return function( elem ) {
        var name = elem.nodeName.toLowerCase();
        return name === "input" && elem.type === type;
    };
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
    return function( elem ) {
        var name = elem.nodeName.toLowerCase();
        return (name === "input" || name === "button") && elem.type === type;
    };
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
    return markFunction(function( argument ) {
        argument = +argument;
        return markFunction(function( seed, matches ) {
            var j,
                matchIndexes = fn( [], seed.length, argument ),
                i = matchIndexes.length;

            // Match elements found at the specified indexes
            while ( i-- ) {
                if ( seed[ (j = matchIndexes[i]) ] ) {
                    seed[j] = !(matches[j] = seed[j]);
                }
            }
        });
    });
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
    return context && typeof context.getElementsByTagName !== strundefined && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
    // documentElement is verified for cases where it doesn't yet exist
    // (such as loading iframes in IE - #4833)
    var documentElement = elem && (elem.ownerDocument || elem).documentElement;
    return documentElement ? documentElement.nodeName !== "HTML" : false;
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
    var hasCompare,
        doc = node ? node.ownerDocument || node : preferredDoc,
        parent = doc.defaultView;

    // If no document and documentElement is available, return
    if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
        return document;
    }

    // Set our document
    document = doc;
    docElem = doc.documentElement;

    // Support tests
    documentIsHTML = !isXML( doc );

    // Support: IE>8
    // If iframe document is assigned to "document" variable and if iframe has been reloaded,
    // IE will throw "permission denied" error when accessing "document" variable, see jQuery #13936
    // IE6-8 do not support the defaultView property so parent will be undefined
    if ( parent && parent !== parent.top ) {
        // IE11 does not have attachEvent, so all must suffer
        if ( parent.addEventListener ) {
            parent.addEventListener( "unload", function() {
                setDocument();
            }, false );
        } else if ( parent.attachEvent ) {
            parent.attachEvent( "onunload", function() {
                setDocument();
            });
        }
    }

    /* Attributes
    ---------------------------------------------------------------------- */

    // Support: IE<8
    // Verify that getAttribute really returns attributes and not properties (excepting IE8 booleans)
    support.attributes = assert(function( div ) {
        div.className = "i";
        return !div.getAttribute("className");
    });

    /* getElement(s)By*
    ---------------------------------------------------------------------- */

    // Check if getElementsByTagName("*") returns only elements
    support.getElementsByTagName = assert(function( div ) {
        div.appendChild( doc.createComment("") );
        return !div.getElementsByTagName("*").length;
    });

    // Check if getElementsByClassName can be trusted
    support.getElementsByClassName = rnative.test( doc.getElementsByClassName ) && assert(function( div ) {
        div.innerHTML = "<div class='a'></div><div class='a i'></div>";

        // Support: Safari<4
        // Catch class over-caching
        div.firstChild.className = "i";
        // Support: Opera<10
        // Catch gEBCN failure to find non-leading classes
        return div.getElementsByClassName("i").length === 2;
    });

    // Support: IE<10
    // Check if getElementById returns elements by name
    // The broken getElementById methods don't pick up programatically-set names,
    // so use a roundabout getElementsByName test
    support.getById = assert(function( div ) {
        docElem.appendChild( div ).id = expando;
        return !doc.getElementsByName || !doc.getElementsByName( expando ).length;
    });

    // ID find and filter
    if ( support.getById ) {
        Expr.find["ID"] = function( id, context ) {
            if ( typeof context.getElementById !== strundefined && documentIsHTML ) {
                var m = context.getElementById( id );
                // Check parentNode to catch when Blackberry 4.6 returns
                // nodes that are no longer in the document #6963
                return m && m.parentNode ? [ m ] : [];
            }
        };
        Expr.filter["ID"] = function( id ) {
            var attrId = id.replace( runescape, funescape );
            return function( elem ) {
                return elem.getAttribute("id") === attrId;
            };
        };
    } else {
        // Support: IE6/7
        // getElementById is not reliable as a find shortcut
        delete Expr.find["ID"];

        Expr.filter["ID"] =  function( id ) {
            var attrId = id.replace( runescape, funescape );
            return function( elem ) {
                var node = typeof elem.getAttributeNode !== strundefined && elem.getAttributeNode("id");
                return node && node.value === attrId;
            };
        };
    }

    // Tag
    Expr.find["TAG"] = support.getElementsByTagName ?
        function( tag, context ) {
            if ( typeof context.getElementsByTagName !== strundefined ) {
                return context.getElementsByTagName( tag );
            }
        } :
        function( tag, context ) {
            var elem,
                tmp = [],
                i = 0,
                results = context.getElementsByTagName( tag );

            // Filter out possible comments
            if ( tag === "*" ) {
                while ( (elem = results[i++]) ) {
                    if ( elem.nodeType === 1 ) {
                        tmp.push( elem );
                    }
                }

                return tmp;
            }
            return results;
        };

    // Class
    Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
        if ( typeof context.getElementsByClassName !== strundefined && documentIsHTML ) {
            return context.getElementsByClassName( className );
        }
    };

    /* QSA/matchesSelector
    ---------------------------------------------------------------------- */

    // QSA and matchesSelector support

    // matchesSelector(:active) reports false when true (IE9/Opera 11.5)
    rbuggyMatches = [];

    // qSa(:focus) reports false when true (Chrome 21)
    // We allow this because of a bug in IE8/9 that throws an error
    // whenever `document.activeElement` is accessed on an iframe
    // So, we allow :focus to pass through QSA all the time to avoid the IE error
    // See http://bugs.jquery.com/ticket/13378
    rbuggyQSA = [];

    if ( (support.qsa = rnative.test( doc.querySelectorAll )) ) {
        // Build QSA regex
        // Regex strategy adopted from Diego Perini
        assert(function( div ) {
            // Select is set to empty string on purpose
            // This is to test IE's treatment of not explicitly
            // setting a boolean content attribute,
            // since its presence should be enough
            // http://bugs.jquery.com/ticket/12359
            div.innerHTML = "<select msallowclip=''><option selected=''></option></select>";

            // Support: IE8, Opera 11-12.16
            // Nothing should be selected when empty strings follow ^= or $= or *=
            // The test attribute must be unknown in Opera but "safe" for WinRT
            // http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
            if ( div.querySelectorAll("[msallowclip^='']").length ) {
                rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
            }

            // Support: IE8
            // Boolean attributes and "value" are not treated correctly
            if ( !div.querySelectorAll("[selected]").length ) {
                rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
            }

            // Webkit/Opera - :checked should return selected option elements
            // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
            // IE8 throws error here and will not see later tests
            if ( !div.querySelectorAll(":checked").length ) {
                rbuggyQSA.push(":checked");
            }
        });

        assert(function( div ) {
            // Support: Windows 8 Native Apps
            // The type and name attributes are restricted during .innerHTML assignment
            var input = doc.createElement("input");
            input.setAttribute( "type", "hidden" );
            div.appendChild( input ).setAttribute( "name", "D" );

            // Support: IE8
            // Enforce case-sensitivity of name attribute
            if ( div.querySelectorAll("[name=d]").length ) {
                rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
            }

            // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
            // IE8 throws error here and will not see later tests
            if ( !div.querySelectorAll(":enabled").length ) {
                rbuggyQSA.push( ":enabled", ":disabled" );
            }

            // Opera 10-11 does not throw on post-comma invalid pseudos
            div.querySelectorAll("*,:x");
            rbuggyQSA.push(",.*:");
        });
    }

    if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
        docElem.webkitMatchesSelector ||
        docElem.mozMatchesSelector ||
        docElem.oMatchesSelector ||
        docElem.msMatchesSelector) )) ) {

        assert(function( div ) {
            // Check to see if it's possible to do matchesSelector
            // on a disconnected node (IE 9)
            support.disconnectedMatch = matches.call( div, "div" );

            // This should fail with an exception
            // Gecko does not error, returns false instead
            matches.call( div, "[s!='']:x" );
            rbuggyMatches.push( "!=", pseudos );
        });
    }

    rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
    rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

    /* Contains
    ---------------------------------------------------------------------- */
    hasCompare = rnative.test( docElem.compareDocumentPosition );

    // Element contains another
    // Purposefully does not implement inclusive descendent
    // As in, an element does not contain itself
    contains = hasCompare || rnative.test( docElem.contains ) ?
        function( a, b ) {
            var adown = a.nodeType === 9 ? a.documentElement : a,
                bup = b && b.parentNode;
            return a === bup || !!( bup && bup.nodeType === 1 && (
                adown.contains ?
                    adown.contains( bup ) :
                    a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
            ));
        } :
        function( a, b ) {
            if ( b ) {
                while ( (b = b.parentNode) ) {
                    if ( b === a ) {
                        return true;
                    }
                }
            }
            return false;
        };

    /* Sorting
    ---------------------------------------------------------------------- */

    // Document order sorting
    sortOrder = hasCompare ?
    function( a, b ) {

        // Flag for duplicate removal
        if ( a === b ) {
            hasDuplicate = true;
            return 0;
        }

        // Sort on method existence if only one input has compareDocumentPosition
        var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
        if ( compare ) {
            return compare;
        }

        // Calculate position if both inputs belong to the same document
        compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
            a.compareDocumentPosition( b ) :

            // Otherwise we know they are disconnected
            1;

        // Disconnected nodes
        if ( compare & 1 ||
            (!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

            // Choose the first element that is related to our preferred document
            if ( a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
                return -1;
            }
            if ( b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
                return 1;
            }

            // Maintain original order
            return sortInput ?
                ( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :
                0;
        }

        return compare & 4 ? -1 : 1;
    } :
    function( a, b ) {
        // Exit early if the nodes are identical
        if ( a === b ) {
            hasDuplicate = true;
            return 0;
        }

        var cur,
            i = 0,
            aup = a.parentNode,
            bup = b.parentNode,
            ap = [ a ],
            bp = [ b ];

        // Parentless nodes are either documents or disconnected
        if ( !aup || !bup ) {
            return a === doc ? -1 :
                b === doc ? 1 :
                aup ? -1 :
                bup ? 1 :
                sortInput ?
                ( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :
                0;

        // If the nodes are siblings, we can do a quick check
        } else if ( aup === bup ) {
            return siblingCheck( a, b );
        }

        // Otherwise we need full lists of their ancestors for comparison
        cur = a;
        while ( (cur = cur.parentNode) ) {
            ap.unshift( cur );
        }
        cur = b;
        while ( (cur = cur.parentNode) ) {
            bp.unshift( cur );
        }

        // Walk down the tree looking for a discrepancy
        while ( ap[i] === bp[i] ) {
            i++;
        }

        return i ?
            // Do a sibling check if the nodes have a common ancestor
            siblingCheck( ap[i], bp[i] ) :

            // Otherwise nodes in our document sort first
            ap[i] === preferredDoc ? -1 :
            bp[i] === preferredDoc ? 1 :
            0;
    };

    return doc;
};

Sizzle.matches = function( expr, elements ) {
    return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
    // Set document vars if needed
    if ( ( elem.ownerDocument || elem ) !== document ) {
        setDocument( elem );
    }

    // Make sure that attribute selectors are quoted
    expr = expr.replace( rattributeQuotes, "='$1']" );

    if ( support.matchesSelector && documentIsHTML &&
        ( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
        ( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

        try {
            var ret = matches.call( elem, expr );

            // IE 9's matchesSelector returns false on disconnected nodes
            if ( ret || support.disconnectedMatch ||
                    // As well, disconnected nodes are said to be in a document
                    // fragment in IE 9
                    elem.document && elem.document.nodeType !== 11 ) {
                return ret;
            }
        } catch(e) {}
    }

    return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {
    // Set document vars if needed
    if ( ( context.ownerDocument || context ) !== document ) {
        setDocument( context );
    }
    return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {
    // Set document vars if needed
    if ( ( elem.ownerDocument || elem ) !== document ) {
        setDocument( elem );
    }

    var fn = Expr.attrHandle[ name.toLowerCase() ],
        // Don't get fooled by Object.prototype properties (jQuery #13807)
        val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
            fn( elem, name, !documentIsHTML ) :
            undefined;

    return val !== undefined ?
        val :
        support.attributes || !documentIsHTML ?
            elem.getAttribute( name ) :
            (val = elem.getAttributeNode(name)) && val.specified ?
                val.value :
                null;
};

Sizzle.error = function( msg ) {
    throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
    var elem,
        duplicates = [],
        j = 0,
        i = 0;

    // Unless we *know* we can detect duplicates, assume their presence
    hasDuplicate = !support.detectDuplicates;
    sortInput = !support.sortStable && results.slice( 0 );
    results.sort( sortOrder );

    if ( hasDuplicate ) {
        while ( (elem = results[i++]) ) {
            if ( elem === results[ i ] ) {
                j = duplicates.push( i );
            }
        }
        while ( j-- ) {
            results.splice( duplicates[ j ], 1 );
        }
    }

    // Clear input after sorting to release objects
    // See https://github.com/jquery/sizzle/pull/225
    sortInput = null;

    return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
    var node,
        ret = "",
        i = 0,
        nodeType = elem.nodeType;

    if ( !nodeType ) {
        // If no nodeType, this is expected to be an array
        while ( (node = elem[i++]) ) {
            // Do not traverse comment nodes
            ret += getText( node );
        }
    } else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
        // Use textContent for elements
        // innerText usage removed for consistency of new lines (jQuery #11153)
        if ( typeof elem.textContent === "string" ) {
            return elem.textContent;
        } else {
            // Traverse its children
            for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
                ret += getText( elem );
            }
        }
    } else if ( nodeType === 3 || nodeType === 4 ) {
        return elem.nodeValue;
    }
    // Do not include comment or processing instruction nodes

    return ret;
};

Expr = Sizzle.selectors = {

    // Can be adjusted by the user
    cacheLength: 50,

    createPseudo: markFunction,

    match: matchExpr,

    attrHandle: {},

    find: {},

    relative: {
        ">": { dir: "parentNode", first: true },
        " ": { dir: "parentNode" },
        "+": { dir: "previousSibling", first: true },
        "~": { dir: "previousSibling" }
    },

    preFilter: {
        "ATTR": function( match ) {
            match[1] = match[1].replace( runescape, funescape );

            // Move the given value to match[3] whether quoted or unquoted
            match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

            if ( match[2] === "~=" ) {
                match[3] = " " + match[3] + " ";
            }

            return match.slice( 0, 4 );
        },

        "CHILD": function( match ) {
            /* matches from matchExpr["CHILD"]
                1 type (only|nth|...)
                2 what (child|of-type)
                3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
                4 xn-component of xn+y argument ([+-]?\d*n|)
                5 sign of xn-component
                6 x of xn-component
                7 sign of y-component
                8 y of y-component
            */
            match[1] = match[1].toLowerCase();

            if ( match[1].slice( 0, 3 ) === "nth" ) {
                // nth-* requires argument
                if ( !match[3] ) {
                    Sizzle.error( match[0] );
                }

                // numeric x and y parameters for Expr.filter.CHILD
                // remember that false/true cast respectively to 0/1
                match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
                match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

            // other types prohibit arguments
            } else if ( match[3] ) {
                Sizzle.error( match[0] );
            }

            return match;
        },

        "PSEUDO": function( match ) {
            var excess,
                unquoted = !match[6] && match[2];

            if ( matchExpr["CHILD"].test( match[0] ) ) {
                return null;
            }

            // Accept quoted arguments as-is
            if ( match[3] ) {
                match[2] = match[4] || match[5] || "";

            // Strip excess characters from unquoted arguments
            } else if ( unquoted && rpseudo.test( unquoted ) &&
                // Get excess from tokenize (recursively)
                (excess = tokenize( unquoted, true )) &&
                // advance to the next closing parenthesis
                (excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

                // excess is a negative index
                match[0] = match[0].slice( 0, excess );
                match[2] = unquoted.slice( 0, excess );
            }

            // Return only captures needed by the pseudo filter method (type and argument)
            return match.slice( 0, 3 );
        }
    },

    filter: {

        "TAG": function( nodeNameSelector ) {
            var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
            return nodeNameSelector === "*" ?
                function() { return true; } :
                function( elem ) {
                    return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
                };
        },

        "CLASS": function( className ) {
            var pattern = classCache[ className + " " ];

            return pattern ||
                (pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
                classCache( className, function( elem ) {
                    return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== strundefined && elem.getAttribute("class") || "" );
                });
        },

        "ATTR": function( name, operator, check ) {
            return function( elem ) {
                var result = Sizzle.attr( elem, name );

                if ( result == null ) {
                    return operator === "!=";
                }
                if ( !operator ) {
                    return true;
                }

                result += "";

                return operator === "=" ? result === check :
                    operator === "!=" ? result !== check :
                    operator === "^=" ? check && result.indexOf( check ) === 0 :
                    operator === "*=" ? check && result.indexOf( check ) > -1 :
                    operator === "$=" ? check && result.slice( -check.length ) === check :
                    operator === "~=" ? ( " " + result + " " ).indexOf( check ) > -1 :
                    operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
                    false;
            };
        },

        "CHILD": function( type, what, argument, first, last ) {
            var simple = type.slice( 0, 3 ) !== "nth",
                forward = type.slice( -4 ) !== "last",
                ofType = what === "of-type";

            return first === 1 && last === 0 ?

                // Shortcut for :nth-*(n)
                function( elem ) {
                    return !!elem.parentNode;
                } :

                function( elem, context, xml ) {
                    var cache, outerCache, node, diff, nodeIndex, start,
                        dir = simple !== forward ? "nextSibling" : "previousSibling",
                        parent = elem.parentNode,
                        name = ofType && elem.nodeName.toLowerCase(),
                        useCache = !xml && !ofType;

                    if ( parent ) {

                        // :(first|last|only)-(child|of-type)
                        if ( simple ) {
                            while ( dir ) {
                                node = elem;
                                while ( (node = node[ dir ]) ) {
                                    if ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) {
                                        return false;
                                    }
                                }
                                // Reverse direction for :only-* (if we haven't yet done so)
                                start = dir = type === "only" && !start && "nextSibling";
                            }
                            return true;
                        }

                        start = [ forward ? parent.firstChild : parent.lastChild ];

                        // non-xml :nth-child(...) stores cache data on `parent`
                        if ( forward && useCache ) {
                            // Seek `elem` from a previously-cached index
                            outerCache = parent[ expando ] || (parent[ expando ] = {});
                            cache = outerCache[ type ] || [];
                            nodeIndex = cache[0] === dirruns && cache[1];
                            diff = cache[0] === dirruns && cache[2];
                            node = nodeIndex && parent.childNodes[ nodeIndex ];

                            while ( (node = ++nodeIndex && node && node[ dir ] ||

                                // Fallback to seeking `elem` from the start
                                (diff = nodeIndex = 0) || start.pop()) ) {

                                // When found, cache indexes on `parent` and break
                                if ( node.nodeType === 1 && ++diff && node === elem ) {
                                    outerCache[ type ] = [ dirruns, nodeIndex, diff ];
                                    break;
                                }
                            }

                        // Use previously-cached element index if available
                        } else if ( useCache && (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) && cache[0] === dirruns ) {
                            diff = cache[1];

                        // xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)
                        } else {
                            // Use the same loop as above to seek `elem` from the start
                            while ( (node = ++nodeIndex && node && node[ dir ] ||
                                (diff = nodeIndex = 0) || start.pop()) ) {

                                if ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) && ++diff ) {
                                    // Cache the index of each encountered element
                                    if ( useCache ) {
                                        (node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ];
                                    }

                                    if ( node === elem ) {
                                        break;
                                    }
                                }
                            }
                        }

                        // Incorporate the offset, then check against cycle size
                        diff -= last;
                        return diff === first || ( diff % first === 0 && diff / first >= 0 );
                    }
                };
        },

        "PSEUDO": function( pseudo, argument ) {
            // pseudo-class names are case-insensitive
            // http://www.w3.org/TR/selectors/#pseudo-classes
            // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
            // Remember that setFilters inherits from pseudos
            var args,
                fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
                    Sizzle.error( "unsupported pseudo: " + pseudo );

            // The user may use createPseudo to indicate that
            // arguments are needed to create the filter function
            // just as Sizzle does
            if ( fn[ expando ] ) {
                return fn( argument );
            }

            // But maintain support for old signatures
            if ( fn.length > 1 ) {
                args = [ pseudo, pseudo, "", argument ];
                return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
                    markFunction(function( seed, matches ) {
                        var idx,
                            matched = fn( seed, argument ),
                            i = matched.length;
                        while ( i-- ) {
                            idx = indexOf.call( seed, matched[i] );
                            seed[ idx ] = !( matches[ idx ] = matched[i] );
                        }
                    }) :
                    function( elem ) {
                        return fn( elem, 0, args );
                    };
            }

            return fn;
        }
    },

    pseudos: {
        // Potentially complex pseudos
        "not": markFunction(function( selector ) {
            // Trim the selector passed to compile
            // to avoid treating leading and trailing
            // spaces as combinators
            var input = [],
                results = [],
                matcher = compile( selector.replace( rtrim, "$1" ) );

            return matcher[ expando ] ?
                markFunction(function( seed, matches, context, xml ) {
                    var elem,
                        unmatched = matcher( seed, null, xml, [] ),
                        i = seed.length;

                    // Match elements unmatched by `matcher`
                    while ( i-- ) {
                        if ( (elem = unmatched[i]) ) {
                            seed[i] = !(matches[i] = elem);
                        }
                    }
                }) :
                function( elem, context, xml ) {
                    input[0] = elem;
                    matcher( input, null, xml, results );
                    return !results.pop();
                };
        }),

        "has": markFunction(function( selector ) {
            return function( elem ) {
                return Sizzle( selector, elem ).length > 0;
            };
        }),

        "contains": markFunction(function( text ) {
            return function( elem ) {
                return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
            };
        }),

        // "Whether an element is represented by a :lang() selector
        // is based solely on the element's language value
        // being equal to the identifier C,
        // or beginning with the identifier C immediately followed by "-".
        // The matching of C against the element's language value is performed case-insensitively.
        // The identifier C does not have to be a valid language name."
        // http://www.w3.org/TR/selectors/#lang-pseudo
        "lang": markFunction( function( lang ) {
            // lang value must be a valid identifier
            if ( !ridentifier.test(lang || "") ) {
                Sizzle.error( "unsupported lang: " + lang );
            }
            lang = lang.replace( runescape, funescape ).toLowerCase();
            return function( elem ) {
                var elemLang;
                do {
                    if ( (elemLang = documentIsHTML ?
                        elem.lang :
                        elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

                        elemLang = elemLang.toLowerCase();
                        return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
                    }
                } while ( (elem = elem.parentNode) && elem.nodeType === 1 );
                return false;
            };
        }),

        // Miscellaneous
        "target": function( elem ) {
            var hash = window.location && window.location.hash;
            return hash && hash.slice( 1 ) === elem.id;
        },

        "root": function( elem ) {
            return elem === docElem;
        },

        "focus": function( elem ) {
            return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
        },

        // Boolean properties
        "enabled": function( elem ) {
            return elem.disabled === false;
        },

        "disabled": function( elem ) {
            return elem.disabled === true;
        },

        "checked": function( elem ) {
            // In CSS3, :checked should return both checked and selected elements
            // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
            var nodeName = elem.nodeName.toLowerCase();
            return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
        },

        "selected": function( elem ) {
            // Accessing this property makes selected-by-default
            // options in Safari work properly
            if ( elem.parentNode ) {
                elem.parentNode.selectedIndex;
            }

            return elem.selected === true;
        },

        // Contents
        "empty": function( elem ) {
            // http://www.w3.org/TR/selectors/#empty-pseudo
            // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
            //   but not by others (comment: 8; processing instruction: 7; etc.)
            // nodeType < 6 works because attributes (2) do not appear as children
            for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
                if ( elem.nodeType < 6 ) {
                    return false;
                }
            }
            return true;
        },

        "parent": function( elem ) {
            return !Expr.pseudos["empty"]( elem );
        },

        // Element/input types
        "header": function( elem ) {
            return rheader.test( elem.nodeName );
        },

        "input": function( elem ) {
            return rinputs.test( elem.nodeName );
        },

        "button": function( elem ) {
            var name = elem.nodeName.toLowerCase();
            return name === "input" && elem.type === "button" || name === "button";
        },

        "text": function( elem ) {
            var attr;
            return elem.nodeName.toLowerCase() === "input" &&
                elem.type === "text" &&

                // Support: IE<8
                // New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
                ( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
        },

        // Position-in-collection
        "first": createPositionalPseudo(function() {
            return [ 0 ];
        }),

        "last": createPositionalPseudo(function( matchIndexes, length ) {
            return [ length - 1 ];
        }),

        "eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
            return [ argument < 0 ? argument + length : argument ];
        }),

        "even": createPositionalPseudo(function( matchIndexes, length ) {
            var i = 0;
            for ( ; i < length; i += 2 ) {
                matchIndexes.push( i );
            }
            return matchIndexes;
        }),

        "odd": createPositionalPseudo(function( matchIndexes, length ) {
            var i = 1;
            for ( ; i < length; i += 2 ) {
                matchIndexes.push( i );
            }
            return matchIndexes;
        }),

        "lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
            var i = argument < 0 ? argument + length : argument;
            for ( ; --i >= 0; ) {
                matchIndexes.push( i );
            }
            return matchIndexes;
        }),

        "gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
            var i = argument < 0 ? argument + length : argument;
            for ( ; ++i < length; ) {
                matchIndexes.push( i );
            }
            return matchIndexes;
        })
    }
};

Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
    Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
    Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
    var matched, match, tokens, type,
        soFar, groups, preFilters,
        cached = tokenCache[ selector + " " ];

    if ( cached ) {
        return parseOnly ? 0 : cached.slice( 0 );
    }

    soFar = selector;
    groups = [];
    preFilters = Expr.preFilter;

    while ( soFar ) {

        // Comma and first run
        if ( !matched || (match = rcomma.exec( soFar )) ) {
            if ( match ) {
                // Don't consume trailing commas as valid
                soFar = soFar.slice( match[0].length ) || soFar;
            }
            groups.push( (tokens = []) );
        }

        matched = false;

        // Combinators
        if ( (match = rcombinators.exec( soFar )) ) {
            matched = match.shift();
            tokens.push({
                value: matched,
                // Cast descendant combinators to space
                type: match[0].replace( rtrim, " " )
            });
            soFar = soFar.slice( matched.length );
        }

        // Filters
        for ( type in Expr.filter ) {
            if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
                (match = preFilters[ type ]( match ))) ) {
                matched = match.shift();
                tokens.push({
                    value: matched,
                    type: type,
                    matches: match
                });
                soFar = soFar.slice( matched.length );
            }
        }

        if ( !matched ) {
            break;
        }
    }

    // Return the length of the invalid excess
    // if we're just parsing
    // Otherwise, throw an error or return tokens
    return parseOnly ?
        soFar.length :
        soFar ?
            Sizzle.error( selector ) :
            // Cache the tokens
            tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
    var i = 0,
        len = tokens.length,
        selector = "";
    for ( ; i < len; i++ ) {
        selector += tokens[i].value;
    }
    return selector;
}

function addCombinator( matcher, combinator, base ) {
    var dir = combinator.dir,
        checkNonElements = base && dir === "parentNode",
        doneName = done++;

    return combinator.first ?
        // Check against closest ancestor/preceding element
        function( elem, context, xml ) {
            while ( (elem = elem[ dir ]) ) {
                if ( elem.nodeType === 1 || checkNonElements ) {
                    return matcher( elem, context, xml );
                }
            }
        } :

        // Check against all ancestor/preceding elements
        function( elem, context, xml ) {
            var oldCache, outerCache,
                newCache = [ dirruns, doneName ];

            // We can't set arbitrary data on XML nodes, so they don't benefit from dir caching
            if ( xml ) {
                while ( (elem = elem[ dir ]) ) {
                    if ( elem.nodeType === 1 || checkNonElements ) {
                        if ( matcher( elem, context, xml ) ) {
                            return true;
                        }
                    }
                }
            } else {
                while ( (elem = elem[ dir ]) ) {
                    if ( elem.nodeType === 1 || checkNonElements ) {
                        outerCache = elem[ expando ] || (elem[ expando ] = {});
                        if ( (oldCache = outerCache[ dir ]) &&
                            oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

                            // Assign to newCache so results back-propagate to previous elements
                            return (newCache[ 2 ] = oldCache[ 2 ]);
                        } else {
                            // Reuse newcache so results back-propagate to previous elements
                            outerCache[ dir ] = newCache;

                            // A match means we're done; a fail means we have to keep checking
                            if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
                                return true;
                            }
                        }
                    }
                }
            }
        };
}

function elementMatcher( matchers ) {
    return matchers.length > 1 ?
        function( elem, context, xml ) {
            var i = matchers.length;
            while ( i-- ) {
                if ( !matchers[i]( elem, context, xml ) ) {
                    return false;
                }
            }
            return true;
        } :
        matchers[0];
}

function multipleContexts( selector, contexts, results ) {
    var i = 0,
        len = contexts.length;
    for ( ; i < len; i++ ) {
        Sizzle( selector, contexts[i], results );
    }
    return results;
}

function condense( unmatched, map, filter, context, xml ) {
    var elem,
        newUnmatched = [],
        i = 0,
        len = unmatched.length,
        mapped = map != null;

    for ( ; i < len; i++ ) {
        if ( (elem = unmatched[i]) ) {
            if ( !filter || filter( elem, context, xml ) ) {
                newUnmatched.push( elem );
                if ( mapped ) {
                    map.push( i );
                }
            }
        }
    }

    return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
    if ( postFilter && !postFilter[ expando ] ) {
        postFilter = setMatcher( postFilter );
    }
    if ( postFinder && !postFinder[ expando ] ) {
        postFinder = setMatcher( postFinder, postSelector );
    }
    return markFunction(function( seed, results, context, xml ) {
        var temp, i, elem,
            preMap = [],
            postMap = [],
            preexisting = results.length,

            // Get initial elements from seed or context
            elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

            // Prefilter to get matcher input, preserving a map for seed-results synchronization
            matcherIn = preFilter && ( seed || !selector ) ?
                condense( elems, preMap, preFilter, context, xml ) :
                elems,

            matcherOut = matcher ?
                // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
                postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

                    // ...intermediate processing is necessary
                    [] :

                    // ...otherwise use results directly
                    results :
                matcherIn;

        // Find primary matches
        if ( matcher ) {
            matcher( matcherIn, matcherOut, context, xml );
        }

        // Apply postFilter
        if ( postFilter ) {
            temp = condense( matcherOut, postMap );
            postFilter( temp, [], context, xml );

            // Un-match failing elements by moving them back to matcherIn
            i = temp.length;
            while ( i-- ) {
                if ( (elem = temp[i]) ) {
                    matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
                }
            }
        }

        if ( seed ) {
            if ( postFinder || preFilter ) {
                if ( postFinder ) {
                    // Get the final matcherOut by condensing this intermediate into postFinder contexts
                    temp = [];
                    i = matcherOut.length;
                    while ( i-- ) {
                        if ( (elem = matcherOut[i]) ) {
                            // Restore matcherIn since elem is not yet a final match
                            temp.push( (matcherIn[i] = elem) );
                        }
                    }
                    postFinder( null, (matcherOut = []), temp, xml );
                }

                // Move matched elements from seed to results to keep them synchronized
                i = matcherOut.length;
                while ( i-- ) {
                    if ( (elem = matcherOut[i]) &&
                        (temp = postFinder ? indexOf.call( seed, elem ) : preMap[i]) > -1 ) {

                        seed[temp] = !(results[temp] = elem);
                    }
                }
            }

        // Add elements to results, through postFinder if defined
        } else {
            matcherOut = condense(
                matcherOut === results ?
                    matcherOut.splice( preexisting, matcherOut.length ) :
                    matcherOut
            );
            if ( postFinder ) {
                postFinder( null, results, matcherOut, xml );
            } else {
                push.apply( results, matcherOut );
            }
        }
    });
}

function matcherFromTokens( tokens ) {
    var checkContext, matcher, j,
        len = tokens.length,
        leadingRelative = Expr.relative[ tokens[0].type ],
        implicitRelative = leadingRelative || Expr.relative[" "],
        i = leadingRelative ? 1 : 0,

        // The foundational matcher ensures that elements are reachable from top-level context(s)
        matchContext = addCombinator( function( elem ) {
            return elem === checkContext;
        }, implicitRelative, true ),
        matchAnyContext = addCombinator( function( elem ) {
            return indexOf.call( checkContext, elem ) > -1;
        }, implicitRelative, true ),
        matchers = [ function( elem, context, xml ) {
            return ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
                (checkContext = context).nodeType ?
                    matchContext( elem, context, xml ) :
                    matchAnyContext( elem, context, xml ) );
        } ];

    for ( ; i < len; i++ ) {
        if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
            matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
        } else {
            matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

            // Return special upon seeing a positional matcher
            if ( matcher[ expando ] ) {
                // Find the next relative operator (if any) for proper handling
                j = ++i;
                for ( ; j < len; j++ ) {
                    if ( Expr.relative[ tokens[j].type ] ) {
                        break;
                    }
                }
                return setMatcher(
                    i > 1 && elementMatcher( matchers ),
                    i > 1 && toSelector(
                        // If the preceding token was a descendant combinator, insert an implicit any-element `*`
                        tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
                    ).replace( rtrim, "$1" ),
                    matcher,
                    i < j && matcherFromTokens( tokens.slice( i, j ) ),
                    j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
                    j < len && toSelector( tokens )
                );
            }
            matchers.push( matcher );
        }
    }

    return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
    var bySet = setMatchers.length > 0,
        byElement = elementMatchers.length > 0,
        superMatcher = function( seed, context, xml, results, outermost ) {
            var elem, j, matcher,
                matchedCount = 0,
                i = "0",
                unmatched = seed && [],
                setMatched = [],
                contextBackup = outermostContext,
                // We must always have either seed elements or outermost context
                elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
                // Use integer dirruns iff this is the outermost matcher
                dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
                len = elems.length;

            if ( outermost ) {
                outermostContext = context !== document && context;
            }

            // Add elements passing elementMatchers directly to results
            // Keep `i` a string if there are no elements so `matchedCount` will be "00" below
            // Support: IE<9, Safari
            // Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
            for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
                if ( byElement && elem ) {
                    j = 0;
                    while ( (matcher = elementMatchers[j++]) ) {
                        if ( matcher( elem, context, xml ) ) {
                            results.push( elem );
                            break;
                        }
                    }
                    if ( outermost ) {
                        dirruns = dirrunsUnique;
                    }
                }

                // Track unmatched elements for set filters
                if ( bySet ) {
                    // They will have gone through all possible matchers
                    if ( (elem = !matcher && elem) ) {
                        matchedCount--;
                    }

                    // Lengthen the array for every element, matched or not
                    if ( seed ) {
                        unmatched.push( elem );
                    }
                }
            }

            // Apply set filters to unmatched elements
            matchedCount += i;
            if ( bySet && i !== matchedCount ) {
                j = 0;
                while ( (matcher = setMatchers[j++]) ) {
                    matcher( unmatched, setMatched, context, xml );
                }

                if ( seed ) {
                    // Reintegrate element matches to eliminate the need for sorting
                    if ( matchedCount > 0 ) {
                        while ( i-- ) {
                            if ( !(unmatched[i] || setMatched[i]) ) {
                                setMatched[i] = pop.call( results );
                            }
                        }
                    }

                    // Discard index placeholder values to get only actual matches
                    setMatched = condense( setMatched );
                }

                // Add matches to results
                push.apply( results, setMatched );

                // Seedless set matches succeeding multiple successful matchers stipulate sorting
                if ( outermost && !seed && setMatched.length > 0 &&
                    ( matchedCount + setMatchers.length ) > 1 ) {

                    Sizzle.uniqueSort( results );
                }
            }

            // Override manipulation of globals by nested matchers
            if ( outermost ) {
                dirruns = dirrunsUnique;
                outermostContext = contextBackup;
            }

            return unmatched;
        };

    return bySet ?
        markFunction( superMatcher ) :
        superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
    var i,
        setMatchers = [],
        elementMatchers = [],
        cached = compilerCache[ selector + " " ];

    if ( !cached ) {
        // Generate a function of recursive functions that can be used to check each element
        if ( !match ) {
            match = tokenize( selector );
        }
        i = match.length;
        while ( i-- ) {
            cached = matcherFromTokens( match[i] );
            if ( cached[ expando ] ) {
                setMatchers.push( cached );
            } else {
                elementMatchers.push( cached );
            }
        }

        // Cache the compiled function
        cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

        // Save selector and tokenization
        cached.selector = selector;
    }
    return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
    var i, tokens, token, type, find,
        compiled = typeof selector === "function" && selector,
        match = !seed && tokenize( (selector = compiled.selector || selector) );

    results = results || [];

    // Try to minimize operations if there is no seed and only one group
    if ( match.length === 1 ) {

        // Take a shortcut and set the context if the root selector is an ID
        tokens = match[0] = match[0].slice( 0 );
        if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
                support.getById && context.nodeType === 9 && documentIsHTML &&
                Expr.relative[ tokens[1].type ] ) {

            context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
            if ( !context ) {
                return results;

            // Precompiled matchers will still verify ancestry, so step up a level
            } else if ( compiled ) {
                context = context.parentNode;
            }

            selector = selector.slice( tokens.shift().value.length );
        }

        // Fetch a seed set for right-to-left matching
        i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
        while ( i-- ) {
            token = tokens[i];

            // Abort if we hit a combinator
            if ( Expr.relative[ (type = token.type) ] ) {
                break;
            }
            if ( (find = Expr.find[ type ]) ) {
                // Search, expanding context for leading sibling combinators
                if ( (seed = find(
                    token.matches[0].replace( runescape, funescape ),
                    rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
                )) ) {

                    // If seed is empty or no tokens remain, we can return early
                    tokens.splice( i, 1 );
                    selector = seed.length && toSelector( tokens );
                    if ( !selector ) {
                        push.apply( results, seed );
                        return results;
                    }

                    break;
                }
            }
        }
    }

    // Compile and execute a filtering function if one is not provided
    // Provide `match` to avoid retokenization if we modified the selector above
    ( compiled || compile( selector, match ) )(
        seed,
        context,
        !documentIsHTML,
        results,
        rsibling.test( selector ) && testContext( context.parentNode ) || context
    );
    return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

// Support: Chrome<14
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert(function( div1 ) {
    // Should return 1, but returns 4 (following)
    return div1.compareDocumentPosition( document.createElement("div") ) & 1;
});

// Support: IE<8
// Prevent attribute/property "interpolation"
// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert(function( div ) {
    div.innerHTML = "<a href='#'></a>";
    return div.firstChild.getAttribute("href") === "#" ;
}) ) {
    addHandle( "type|href|height|width", function( elem, name, isXML ) {
        if ( !isXML ) {
            return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
        }
    });
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert(function( div ) {
    div.innerHTML = "<input/>";
    div.firstChild.setAttribute( "value", "" );
    return div.firstChild.getAttribute( "value" ) === "";
}) ) {
    addHandle( "value", function( elem, name, isXML ) {
        if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
            return elem.defaultValue;
        }
    });
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert(function( div ) {
    return div.getAttribute("disabled") == null;
}) ) {
    addHandle( booleans, function( elem, name, isXML ) {
        var val;
        if ( !isXML ) {
            return elem[ name ] === true ? name.toLowerCase() :
                    (val = elem.getAttributeNode( name )) && val.specified ?
                    val.value :
                null;
        }
    });
}

return Sizzle;

})( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;
jQuery.expr[":"] = jQuery.expr.pseudos;
jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;



var rneedsContext = jQuery.expr.match.needsContext;

var rsingleTag = (/^<(\w+)\s*\/?>(?:<\/\1>|)$/);



var risSimple = /^.[^:#\[\.,]*$/;

// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
    if ( jQuery.isFunction( qualifier ) ) {
        return jQuery.grep( elements, function( elem, i ) {
            /* jshint -W018 */
            return !!qualifier.call( elem, i, elem ) !== not;
        });

    }

    if ( qualifier.nodeType ) {
        return jQuery.grep( elements, function( elem ) {
            return ( elem === qualifier ) !== not;
        });

    }

    if ( typeof qualifier === "string" ) {
        if ( risSimple.test( qualifier ) ) {
            return jQuery.filter( qualifier, elements, not );
        }

        qualifier = jQuery.filter( qualifier, elements );
    }

    return jQuery.grep( elements, function( elem ) {
        return ( jQuery.inArray( elem, qualifier ) >= 0 ) !== not;
    });
}

jQuery.filter = function( expr, elems, not ) {
    var elem = elems[ 0 ];

    if ( not ) {
        expr = ":not(" + expr + ")";
    }

    return elems.length === 1 && elem.nodeType === 1 ?
        jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :
        jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
            return elem.nodeType === 1;
        }));
};

jQuery.fn.extend({
    find: function( selector ) {
        var i,
            ret = [],
            self = this,
            len = self.length;

        if ( typeof selector !== "string" ) {
            return this.pushStack( jQuery( selector ).filter(function() {
                for ( i = 0; i < len; i++ ) {
                    if ( jQuery.contains( self[ i ], this ) ) {
                        return true;
                    }
                }
            }) );
        }

        for ( i = 0; i < len; i++ ) {
            jQuery.find( selector, self[ i ], ret );
        }

        // Needed because $( selector, context ) becomes $( context ).find( selector )
        ret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );
        ret.selector = this.selector ? this.selector + " " + selector : selector;
        return ret;
    },
    filter: function( selector ) {
        return this.pushStack( winnow(this, selector || [], false) );
    },
    not: function( selector ) {
        return this.pushStack( winnow(this, selector || [], true) );
    },
    is: function( selector ) {
        return !!winnow(
            this,

            // If this is a positional/relative selector, check membership in the returned set
            // so $("p:first").is("p:last") won't return true for a doc with two "p".
            typeof selector === "string" && rneedsContext.test( selector ) ?
                jQuery( selector ) :
                selector || [],
            false
        ).length;
    }
});


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

    // Use the correct document accordingly with window argument (sandbox)
    document = window.document,

    // A simple way to check for HTML strings
    // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
    // Strict HTML recognition (#11290: must start with <)
    rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,

    init = jQuery.fn.init = function( selector, context ) {
        var match, elem;

        // HANDLE: $(""), $(null), $(undefined), $(false)
        if ( !selector ) {
            return this;
        }

        // Handle HTML strings
        if ( typeof selector === "string" ) {
            if ( selector.charAt(0) === "<" && selector.charAt( selector.length - 1 ) === ">" && selector.length >= 3 ) {
                // Assume that strings that start and end with <> are HTML and skip the regex check
                match = [ null, selector, null ];

            } else {
                match = rquickExpr.exec( selector );
            }

            // Match html or make sure no context is specified for #id
            if ( match && (match[1] || !context) ) {

                // HANDLE: $(html) -> $(array)
                if ( match[1] ) {
                    context = context instanceof jQuery ? context[0] : context;

                    // scripts is true for back-compat
                    // Intentionally let the error be thrown if parseHTML is not present
                    jQuery.merge( this, jQuery.parseHTML(
                        match[1],
                        context && context.nodeType ? context.ownerDocument || context : document,
                        true
                    ) );

                    // HANDLE: $(html, props)
                    if ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {
                        for ( match in context ) {
                            // Properties of context are called as methods if possible
                            if ( jQuery.isFunction( this[ match ] ) ) {
                                this[ match ]( context[ match ] );

                            // ...and otherwise set as attributes
                            } else {
                                this.attr( match, context[ match ] );
                            }
                        }
                    }

                    return this;

                // HANDLE: $(#id)
                } else {
                    elem = document.getElementById( match[2] );

                    // Check parentNode to catch when Blackberry 4.6 returns
                    // nodes that are no longer in the document #6963
                    if ( elem && elem.parentNode ) {
                        // Handle the case where IE and Opera return items
                        // by name instead of ID
                        if ( elem.id !== match[2] ) {
                            return rootjQuery.find( selector );
                        }

                        // Otherwise, we inject the element directly into the jQuery object
                        this.length = 1;
                        this[0] = elem;
                    }

                    this.context = document;
                    this.selector = selector;
                    return this;
                }

            // HANDLE: $(expr, $(...))
            } else if ( !context || context.jquery ) {
                return ( context || rootjQuery ).find( selector );

            // HANDLE: $(expr, context)
            // (which is just equivalent to: $(context).find(expr)
            } else {
                return this.constructor( context ).find( selector );
            }

        // HANDLE: $(DOMElement)
        } else if ( selector.nodeType ) {
            this.context = this[0] = selector;
            this.length = 1;
            return this;

        // HANDLE: $(function)
        // Shortcut for document ready
        } else if ( jQuery.isFunction( selector ) ) {
            return typeof rootjQuery.ready !== "undefined" ?
                rootjQuery.ready( selector ) :
                // Execute immediately if ready is not present
                selector( jQuery );
        }

        if ( selector.selector !== undefined ) {
            this.selector = selector.selector;
            this.context = selector.context;
        }

        return jQuery.makeArray( selector, this );
    };

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,
    // methods guaranteed to produce a unique set when starting from a unique set
    guaranteedUnique = {
        children: true,
        contents: true,
        next: true,
        prev: true
    };

jQuery.extend({
    dir: function( elem, dir, until ) {
        var matched = [],
            cur = elem[ dir ];

        while ( cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery( cur ).is( until )) ) {
            if ( cur.nodeType === 1 ) {
                matched.push( cur );
            }
            cur = cur[dir];
        }
        return matched;
    },

    sibling: function( n, elem ) {
        var r = [];

        for ( ; n; n = n.nextSibling ) {
            if ( n.nodeType === 1 && n !== elem ) {
                r.push( n );
            }
        }

        return r;
    }
});

jQuery.fn.extend({
    has: function( target ) {
        var i,
            targets = jQuery( target, this ),
            len = targets.length;

        return this.filter(function() {
            for ( i = 0; i < len; i++ ) {
                if ( jQuery.contains( this, targets[i] ) ) {
                    return true;
                }
            }
        });
    },

    closest: function( selectors, context ) {
        var cur,
            i = 0,
            l = this.length,
            matched = [],
            pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?
                jQuery( selectors, context || this.context ) :
                0;

        for ( ; i < l; i++ ) {
            for ( cur = this[i]; cur && cur !== context; cur = cur.parentNode ) {
                // Always skip document fragments
                if ( cur.nodeType < 11 && (pos ?
                    pos.index(cur) > -1 :

                    // Don't pass non-elements to Sizzle
                    cur.nodeType === 1 &&
                        jQuery.find.matchesSelector(cur, selectors)) ) {

                    matched.push( cur );
                    break;
                }
            }
        }

        return this.pushStack( matched.length > 1 ? jQuery.unique( matched ) : matched );
    },

    // Determine the position of an element within
    // the matched set of elements
    index: function( elem ) {

        // No argument, return index in parent
        if ( !elem ) {
            return ( this[0] && this[0].parentNode ) ? this.first().prevAll().length : -1;
        }

        // index in selector
        if ( typeof elem === "string" ) {
            return jQuery.inArray( this[0], jQuery( elem ) );
        }

        // Locate the position of the desired element
        return jQuery.inArray(
            // If it receives a jQuery object, the first element is used
            elem.jquery ? elem[0] : elem, this );
    },

    add: function( selector, context ) {
        return this.pushStack(
            jQuery.unique(
                jQuery.merge( this.get(), jQuery( selector, context ) )
            )
        );
    },

    addBack: function( selector ) {
        return this.add( selector == null ?
            this.prevObject : this.prevObject.filter(selector)
        );
    }
});

function sibling( cur, dir ) {
    do {
        cur = cur[ dir ];
    } while ( cur && cur.nodeType !== 1 );

    return cur;
}

jQuery.each({
    parent: function( elem ) {
        var parent = elem.parentNode;
        return parent && parent.nodeType !== 11 ? parent : null;
    },
    parents: function( elem ) {
        return jQuery.dir( elem, "parentNode" );
    },
    parentsUntil: function( elem, i, until ) {
        return jQuery.dir( elem, "parentNode", until );
    },
    next: function( elem ) {
        return sibling( elem, "nextSibling" );
    },
    prev: function( elem ) {
        return sibling( elem, "previousSibling" );
    },
    nextAll: function( elem ) {
        return jQuery.dir( elem, "nextSibling" );
    },
    prevAll: function( elem ) {
        return jQuery.dir( elem, "previousSibling" );
    },
    nextUntil: function( elem, i, until ) {
        return jQuery.dir( elem, "nextSibling", until );
    },
    prevUntil: function( elem, i, until ) {
        return jQuery.dir( elem, "previousSibling", until );
    },
    siblings: function( elem ) {
        return jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );
    },
    children: function( elem ) {
        return jQuery.sibling( elem.firstChild );
    },
    contents: function( elem ) {
        return jQuery.nodeName( elem, "iframe" ) ?
            elem.contentDocument || elem.contentWindow.document :
            jQuery.merge( [], elem.childNodes );
    }
}, function( name, fn ) {
    jQuery.fn[ name ] = function( until, selector ) {
        var ret = jQuery.map( this, fn, until );

        if ( name.slice( -5 ) !== "Until" ) {
            selector = until;
        }

        if ( selector && typeof selector === "string" ) {
            ret = jQuery.filter( selector, ret );
        }

        if ( this.length > 1 ) {
            // Remove duplicates
            if ( !guaranteedUnique[ name ] ) {
                ret = jQuery.unique( ret );
            }

            // Reverse order for parents* and prev-derivatives
            if ( rparentsprev.test( name ) ) {
                ret = ret.reverse();
            }
        }

        return this.pushStack( ret );
    };
});
var rnotwhite = (/\S+/g);



// String to Object options format cache
var optionsCache = {};

// Convert String-formatted options into Object-formatted ones and store in cache
function createOptions( options ) {
    var object = optionsCache[ options ] = {};
    jQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {
        object[ flag ] = true;
    });
    return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *  options: an optional list of space-separated options that will change how
 *          the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *  once:           will ensure the callback list can only be fired once (like a Deferred)
 *
 *  memory:         will keep track of previous values and will call any callback added
 *                  after the list has been fired right away with the latest "memorized"
 *                  values (like a Deferred)
 *
 *  unique:         will ensure a callback can only be added once (no duplicate in the list)
 *
 *  stopOnFalse:    interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

    // Convert options from String-formatted to Object-formatted if needed
    // (we check in cache first)
    options = typeof options === "string" ?
        ( optionsCache[ options ] || createOptions( options ) ) :
        jQuery.extend( {}, options );

    var // Flag to know if list is currently firing
        firing,
        // Last fire value (for non-forgettable lists)
        memory,
        // Flag to know if list was already fired
        fired,
        // End of the loop when firing
        firingLength,
        // Index of currently firing callback (modified by remove if needed)
        firingIndex,
        // First callback to fire (used internally by add and fireWith)
        firingStart,
        // Actual callback list
        list = [],
        // Stack of fire calls for repeatable lists
        stack = !options.once && [],
        // Fire callbacks
        fire = function( data ) {
            memory = options.memory && data;
            fired = true;
            firingIndex = firingStart || 0;
            firingStart = 0;
            firingLength = list.length;
            firing = true;
            for ( ; list && firingIndex < firingLength; firingIndex++ ) {
                if ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {
                    memory = false; // To prevent further calls using add
                    break;
                }
            }
            firing = false;
            if ( list ) {
                if ( stack ) {
                    if ( stack.length ) {
                        fire( stack.shift() );
                    }
                } else if ( memory ) {
                    list = [];
                } else {
                    self.disable();
                }
            }
        },
        // Actual Callbacks object
        self = {
            // Add a callback or a collection of callbacks to the list
            add: function() {
                if ( list ) {
                    // First, we save the current length
                    var start = list.length;
                    (function add( args ) {
                        jQuery.each( args, function( _, arg ) {
                            var type = jQuery.type( arg );
                            if ( type === "function" ) {
                                if ( !options.unique || !self.has( arg ) ) {
                                    list.push( arg );
                                }
                            } else if ( arg && arg.length && type !== "string" ) {
                                // Inspect recursively
                                add( arg );
                            }
                        });
                    })( arguments );
                    // Do we need to add the callbacks to the
                    // current firing batch?
                    if ( firing ) {
                        firingLength = list.length;
                    // With memory, if we're not firing then
                    // we should call right away
                    } else if ( memory ) {
                        firingStart = start;
                        fire( memory );
                    }
                }
                return this;
            },
            // Remove a callback from the list
            remove: function() {
                if ( list ) {
                    jQuery.each( arguments, function( _, arg ) {
                        var index;
                        while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
                            list.splice( index, 1 );
                            // Handle firing indexes
                            if ( firing ) {
                                if ( index <= firingLength ) {
                                    firingLength--;
                                }
                                if ( index <= firingIndex ) {
                                    firingIndex--;
                                }
                            }
                        }
                    });
                }
                return this;
            },
            // Check if a given callback is in the list.
            // If no argument is given, return whether or not list has callbacks attached.
            has: function( fn ) {
                return fn ? jQuery.inArray( fn, list ) > -1 : !!( list && list.length );
            },
            // Remove all callbacks from the list
            empty: function() {
                list = [];
                firingLength = 0;
                return this;
            },
            // Have the list do nothing anymore
            disable: function() {
                list = stack = memory = undefined;
                return this;
            },
            // Is it disabled?
            disabled: function() {
                return !list;
            },
            // Lock the list in its current state
            lock: function() {
                stack = undefined;
                if ( !memory ) {
                    self.disable();
                }
                return this;
            },
            // Is it locked?
            locked: function() {
                return !stack;
            },
            // Call all callbacks with the given context and arguments
            fireWith: function( context, args ) {
                if ( list && ( !fired || stack ) ) {
                    args = args || [];
                    args = [ context, args.slice ? args.slice() : args ];
                    if ( firing ) {
                        stack.push( args );
                    } else {
                        fire( args );
                    }
                }
                return this;
            },
            // Call all the callbacks with the given arguments
            fire: function() {
                self.fireWith( this, arguments );
                return this;
            },
            // To know if the callbacks have already been called at least once
            fired: function() {
                return !!fired;
            }
        };

    return self;
};


jQuery.extend({

    Deferred: function( func ) {
        var tuples = [
                // action, add listener, listener list, final state
                [ "resolve", "done", jQuery.Callbacks("once memory"), "resolved" ],
                [ "reject", "fail", jQuery.Callbacks("once memory"), "rejected" ],
                [ "notify", "progress", jQuery.Callbacks("memory") ]
            ],
            state = "pending",
            promise = {
                state: function() {
                    return state;
                },
                always: function() {
                    deferred.done( arguments ).fail( arguments );
                    return this;
                },
                then: function( /* fnDone, fnFail, fnProgress */ ) {
                    var fns = arguments;
                    return jQuery.Deferred(function( newDefer ) {
                        jQuery.each( tuples, function( i, tuple ) {
                            var fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];
                            // deferred[ done | fail | progress ] for forwarding actions to newDefer
                            deferred[ tuple[1] ](function() {
                                var returned = fn && fn.apply( this, arguments );
                                if ( returned && jQuery.isFunction( returned.promise ) ) {
                                    returned.promise()
                                        .done( newDefer.resolve )
                                        .fail( newDefer.reject )
                                        .progress( newDefer.notify );
                                } else {
                                    newDefer[ tuple[ 0 ] + "With" ]( this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments );
                                }
                            });
                        });
                        fns = null;
                    }).promise();
                },
                // Get a promise for this deferred
                // If obj is provided, the promise aspect is added to the object
                promise: function( obj ) {
                    return obj != null ? jQuery.extend( obj, promise ) : promise;
                }
            },
            deferred = {};

        // Keep pipe for back-compat
        promise.pipe = promise.then;

        // Add list-specific methods
        jQuery.each( tuples, function( i, tuple ) {
            var list = tuple[ 2 ],
                stateString = tuple[ 3 ];

            // promise[ done | fail | progress ] = list.add
            promise[ tuple[1] ] = list.add;

            // Handle state
            if ( stateString ) {
                list.add(function() {
                    // state = [ resolved | rejected ]
                    state = stateString;

                // [ reject_list | resolve_list ].disable; progress_list.lock
                }, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
            }

            // deferred[ resolve | reject | notify ]
            deferred[ tuple[0] ] = function() {
                deferred[ tuple[0] + "With" ]( this === deferred ? promise : this, arguments );
                return this;
            };
            deferred[ tuple[0] + "With" ] = list.fireWith;
        });

        // Make the deferred a promise
        promise.promise( deferred );

        // Call given func if any
        if ( func ) {
            func.call( deferred, deferred );
        }

        // All done!
        return deferred;
    },

    // Deferred helper
    when: function( subordinate /* , ..., subordinateN */ ) {
        var i = 0,
            resolveValues = slice.call( arguments ),
            length = resolveValues.length,

            // the count of uncompleted subordinates
            remaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,

            // the master Deferred. If resolveValues consist of only a single Deferred, just use that.
            deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

            // Update function for both resolve and progress values
            updateFunc = function( i, contexts, values ) {
                return function( value ) {
                    contexts[ i ] = this;
                    values[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
                    if ( values === progressValues ) {
                        deferred.notifyWith( contexts, values );

                    } else if ( !(--remaining) ) {
                        deferred.resolveWith( contexts, values );
                    }
                };
            },

            progressValues, progressContexts, resolveContexts;

        // add listeners to Deferred subordinates; treat others as resolved
        if ( length > 1 ) {
            progressValues = new Array( length );
            progressContexts = new Array( length );
            resolveContexts = new Array( length );
            for ( ; i < length; i++ ) {
                if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
                    resolveValues[ i ].promise()
                        .done( updateFunc( i, resolveContexts, resolveValues ) )
                        .fail( deferred.reject )
                        .progress( updateFunc( i, progressContexts, progressValues ) );
                } else {
                    --remaining;
                }
            }
        }

        // if we're not waiting on anything, resolve the master
        if ( !remaining ) {
            deferred.resolveWith( resolveContexts, resolveValues );
        }

        return deferred.promise();
    }
});


// The deferred used on DOM ready
var readyList;

jQuery.fn.ready = function( fn ) {
    // Add the callback
    jQuery.ready.promise().done( fn );

    return this;
};

jQuery.extend({
    // Is the DOM ready to be used? Set to true once it occurs.
    isReady: false,

    // A counter to track how many items to wait for before
    // the ready event fires. See #6781
    readyWait: 1,

    // Hold (or release) the ready event
    holdReady: function( hold ) {
        if ( hold ) {
            jQuery.readyWait++;
        } else {
            jQuery.ready( true );
        }
    },

    // Handle when the DOM is ready
    ready: function( wait ) {

        // Abort if there are pending holds or we're already ready
        if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
            return;
        }

        // Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
        if ( !document.body ) {
            return setTimeout( jQuery.ready );
        }

        // Remember that the DOM is ready
        jQuery.isReady = true;

        // If a normal DOM Ready event fired, decrement, and wait if need be
        if ( wait !== true && --jQuery.readyWait > 0 ) {
            return;
        }

        // If there are functions bound, to execute
        readyList.resolveWith( document, [ jQuery ] );

        // Trigger any bound ready events
        if ( jQuery.fn.triggerHandler ) {
            jQuery( document ).triggerHandler( "ready" );
            jQuery( document ).off( "ready" );
        }
    }
});

/**
 * Clean-up method for dom ready events
 */
function detach() {
    if ( document.addEventListener ) {
        document.removeEventListener( "DOMContentLoaded", completed, false );
        window.removeEventListener( "load", completed, false );

    } else {
        document.detachEvent( "onreadystatechange", completed );
        window.detachEvent( "onload", completed );
    }
}

/**
 * The ready event handler and self cleanup method
 */
function completed() {
    // readyState === "complete" is good enough for us to call the dom ready in oldIE
    if ( document.addEventListener || event.type === "load" || document.readyState === "complete" ) {
        detach();
        jQuery.ready();
    }
}

jQuery.ready.promise = function( obj ) {
    if ( !readyList ) {

        readyList = jQuery.Deferred();

        // Catch cases where $(document).ready() is called after the browser event has already occurred.
        // we once tried to use readyState "interactive" here, but it caused issues like the one
        // discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15
        if ( document.readyState === "complete" ) {
            // Handle it asynchronously to allow scripts the opportunity to delay ready
            setTimeout( jQuery.ready );

        // Standards-based browsers support DOMContentLoaded
        } else if ( document.addEventListener ) {
            // Use the handy event callback
            document.addEventListener( "DOMContentLoaded", completed, false );

            // A fallback to window.onload, that will always work
            window.addEventListener( "load", completed, false );

        // If IE event model is used
        } else {
            // Ensure firing before onload, maybe late but safe also for iframes
            document.attachEvent( "onreadystatechange", completed );

            // A fallback to window.onload, that will always work
            window.attachEvent( "onload", completed );

            // If IE and not a frame
            // continually check to see if the document is ready
            var top = false;

            try {
                top = window.frameElement == null && document.documentElement;
            } catch(e) {}

            if ( top && top.doScroll ) {
                (function doScrollCheck() {
                    if ( !jQuery.isReady ) {

                        try {
                            // Use the trick by Diego Perini
                            // http://javascript.nwbox.com/IEContentLoaded/
                            top.doScroll("left");
                        } catch(e) {
                            return setTimeout( doScrollCheck, 50 );
                        }

                        // detach all dom ready events
                        detach();

                        // and execute any waiting functions
                        jQuery.ready();
                    }
                })();
            }
        }
    }
    return readyList.promise( obj );
};


var strundefined = typeof undefined;



// Support: IE<9
// Iteration over object's inherited properties before its own
var i;
for ( i in jQuery( support ) ) {
    break;
}
support.ownLast = i !== "0";

// Note: most support tests are defined in their respective modules.
// false until the test is run
support.inlineBlockNeedsLayout = false;

// Execute ASAP in case we need to set body.style.zoom
jQuery(function() {
    // Minified: var a,b,c,d
    var val, div, body, container;

    body = document.getElementsByTagName( "body" )[ 0 ];
    if ( !body || !body.style ) {
        // Return for frameset docs that don't have a body
        return;
    }

    // Setup
    div = document.createElement( "div" );
    container = document.createElement( "div" );
    container.style.cssText = "position:absolute;border:0;width:0;height:0;top:0;left:-9999px";
    body.appendChild( container ).appendChild( div );

    if ( typeof div.style.zoom !== strundefined ) {
        // Support: IE<8
        // Check if natively block-level elements act like inline-block
        // elements when setting their display to 'inline' and giving
        // them layout
        div.style.cssText = "display:inline;margin:0;border:0;padding:1px;width:1px;zoom:1";

        support.inlineBlockNeedsLayout = val = div.offsetWidth === 3;
        if ( val ) {
            // Prevent IE 6 from affecting layout for positioned elements #11048
            // Prevent IE from shrinking the body in IE 7 mode #12869
            // Support: IE<8
            body.style.zoom = 1;
        }
    }

    body.removeChild( container );
});




(function() {
    var div = document.createElement( "div" );

    // Execute the test only if not already executed in another module.
    if (support.deleteExpando == null) {
        // Support: IE<9
        support.deleteExpando = true;
        try {
            delete div.test;
        } catch( e ) {
            support.deleteExpando = false;
        }
    }

    // Null elements to avoid leaks in IE.
    div = null;
})();


/**
 * Determines whether an object can have data
 */
jQuery.acceptData = function( elem ) {
    var noData = jQuery.noData[ (elem.nodeName + " ").toLowerCase() ],
        nodeType = +elem.nodeType || 1;

    // Do not set data on non-element DOM nodes because it will not be cleared (#8335).
    return nodeType !== 1 && nodeType !== 9 ?
        false :

        // Nodes accept data unless otherwise specified; rejection can be conditional
        !noData || noData !== true && elem.getAttribute("classid") === noData;
};


var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
    rmultiDash = /([A-Z])/g;

function dataAttr( elem, key, data ) {
    // If nothing was found internally, try to fetch any
    // data from the HTML5 data-* attribute
    if ( data === undefined && elem.nodeType === 1 ) {

        var name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();

        data = elem.getAttribute( name );

        if ( typeof data === "string" ) {
            try {
                data = data === "true" ? true :
                    data === "false" ? false :
                    data === "null" ? null :
                    // Only convert to a number if it doesn't change the string
                    +data + "" === data ? +data :
                    rbrace.test( data ) ? jQuery.parseJSON( data ) :
                    data;
            } catch( e ) {}

            // Make sure we set the data so it isn't changed later
            jQuery.data( elem, key, data );

        } else {
            data = undefined;
        }
    }

    return data;
}

// checks a cache object for emptiness
function isEmptyDataObject( obj ) {
    var name;
    for ( name in obj ) {

        // if the public data object is empty, the private is still empty
        if ( name === "data" && jQuery.isEmptyObject( obj[name] ) ) {
            continue;
        }
        if ( name !== "toJSON" ) {
            return false;
        }
    }

    return true;
}

function internalData( elem, name, data, pvt /* Internal Use Only */ ) {
    if ( !jQuery.acceptData( elem ) ) {
        return;
    }

    var ret, thisCache,
        internalKey = jQuery.expando,

        // We have to handle DOM nodes and JS objects differently because IE6-7
        // can't GC object references properly across the DOM-JS boundary
        isNode = elem.nodeType,

        // Only DOM nodes need the global jQuery cache; JS object data is
        // attached directly to the object so GC can occur automatically
        cache = isNode ? jQuery.cache : elem,

        // Only defining an ID for JS objects if its cache already exists allows
        // the code to shortcut on the same path as a DOM node with no cache
        id = isNode ? elem[ internalKey ] : elem[ internalKey ] && internalKey;

    // Avoid doing any more work than we need to when trying to get data on an
    // object that has no data at all
    if ( (!id || !cache[id] || (!pvt && !cache[id].data)) && data === undefined && typeof name === "string" ) {
        return;
    }

    if ( !id ) {
        // Only DOM nodes need a new unique ID for each element since their data
        // ends up in the global cache
        if ( isNode ) {
            id = elem[ internalKey ] = deletedIds.pop() || jQuery.guid++;
        } else {
            id = internalKey;
        }
    }

    if ( !cache[ id ] ) {
        // Avoid exposing jQuery metadata on plain JS objects when the object
        // is serialized using JSON.stringify
        cache[ id ] = isNode ? {} : { toJSON: jQuery.noop };
    }

    // An object can be passed to jQuery.data instead of a key/value pair; this gets
    // shallow copied over onto the existing cache
    if ( typeof name === "object" || typeof name === "function" ) {
        if ( pvt ) {
            cache[ id ] = jQuery.extend( cache[ id ], name );
        } else {
            cache[ id ].data = jQuery.extend( cache[ id ].data, name );
        }
    }

    thisCache = cache[ id ];

    // jQuery data() is stored in a separate object inside the object's internal data
    // cache in order to avoid key collisions between internal data and user-defined
    // data.
    if ( !pvt ) {
        if ( !thisCache.data ) {
            thisCache.data = {};
        }

        thisCache = thisCache.data;
    }

    if ( data !== undefined ) {
        thisCache[ jQuery.camelCase( name ) ] = data;
    }

    // Check for both converted-to-camel and non-converted data property names
    // If a data property was specified
    if ( typeof name === "string" ) {

        // First Try to find as-is property data
        ret = thisCache[ name ];

        // Test for null|undefined property data
        if ( ret == null ) {

            // Try to find the camelCased property
            ret = thisCache[ jQuery.camelCase( name ) ];
        }
    } else {
        ret = thisCache;
    }

    return ret;
}

function internalRemoveData( elem, name, pvt ) {
    if ( !jQuery.acceptData( elem ) ) {
        return;
    }

    var thisCache, i,
        isNode = elem.nodeType,

        // See jQuery.data for more information
        cache = isNode ? jQuery.cache : elem,
        id = isNode ? elem[ jQuery.expando ] : jQuery.expando;

    // If there is already no cache entry for this object, there is no
    // purpose in continuing
    if ( !cache[ id ] ) {
        return;
    }

    if ( name ) {

        thisCache = pvt ? cache[ id ] : cache[ id ].data;

        if ( thisCache ) {

            // Support array or space separated string names for data keys
            if ( !jQuery.isArray( name ) ) {

                // try the string as a key before any manipulation
                if ( name in thisCache ) {
                    name = [ name ];
                } else {

                    // split the camel cased version by spaces unless a key with the spaces exists
                    name = jQuery.camelCase( name );
                    if ( name in thisCache ) {
                        name = [ name ];
                    } else {
                        name = name.split(" ");
                    }
                }
            } else {
                // If "name" is an array of keys...
                // When data is initially created, via ("key", "val") signature,
                // keys will be converted to camelCase.
                // Since there is no way to tell _how_ a key was added, remove
                // both plain key and camelCase key. #12786
                // This will only penalize the array argument path.
                name = name.concat( jQuery.map( name, jQuery.camelCase ) );
            }

            i = name.length;
            while ( i-- ) {
                delete thisCache[ name[i] ];
            }

            // If there is no data left in the cache, we want to continue
            // and let the cache object itself get destroyed
            if ( pvt ? !isEmptyDataObject(thisCache) : !jQuery.isEmptyObject(thisCache) ) {
                return;
            }
        }
    }

    // See jQuery.data for more information
    if ( !pvt ) {
        delete cache[ id ].data;

        // Don't destroy the parent cache unless the internal data object
        // had been the only thing left in it
        if ( !isEmptyDataObject( cache[ id ] ) ) {
            return;
        }
    }

    // Destroy the cache
    if ( isNode ) {
        jQuery.cleanData( [ elem ], true );

    // Use delete when supported for expandos or `cache` is not a window per isWindow (#10080)
    /* jshint eqeqeq: false */
    } else if ( support.deleteExpando || cache != cache.window ) {
        /* jshint eqeqeq: true */
        delete cache[ id ];

    // When all else fails, null
    } else {
        cache[ id ] = null;
    }
}

jQuery.extend({
    cache: {},

    // The following elements (space-suffixed to avoid Object.prototype collisions)
    // throw uncatchable exceptions if you attempt to set expando properties
    noData: {
        "applet ": true,
        "embed ": true,
        // ...but Flash objects (which have this classid) *can* handle expandos
        "object ": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"
    },

    hasData: function( elem ) {
        elem = elem.nodeType ? jQuery.cache[ elem[jQuery.expando] ] : elem[ jQuery.expando ];
        return !!elem && !isEmptyDataObject( elem );
    },

    data: function( elem, name, data ) {
        return internalData( elem, name, data );
    },

    removeData: function( elem, name ) {
        return internalRemoveData( elem, name );
    },

    // For internal use only.
    _data: function( elem, name, data ) {
        return internalData( elem, name, data, true );
    },

    _removeData: function( elem, name ) {
        return internalRemoveData( elem, name, true );
    }
});

jQuery.fn.extend({
    data: function( key, value ) {
        var i, name, data,
            elem = this[0],
            attrs = elem && elem.attributes;

        // Special expections of .data basically thwart jQuery.access,
        // so implement the relevant behavior ourselves

        // Gets all values
        if ( key === undefined ) {
            if ( this.length ) {
                data = jQuery.data( elem );

                if ( elem.nodeType === 1 && !jQuery._data( elem, "parsedAttrs" ) ) {
                    i = attrs.length;
                    while ( i-- ) {

                        // Support: IE11+
                        // The attrs elements can be null (#14894)
                        if ( attrs[ i ] ) {
                            name = attrs[ i ].name;
                            if ( name.indexOf( "data-" ) === 0 ) {
                                name = jQuery.camelCase( name.slice(5) );
                                dataAttr( elem, name, data[ name ] );
                            }
                        }
                    }
                    jQuery._data( elem, "parsedAttrs", true );
                }
            }

            return data;
        }

        // Sets multiple values
        if ( typeof key === "object" ) {
            return this.each(function() {
                jQuery.data( this, key );
            });
        }

        return arguments.length > 1 ?

            // Sets one value
            this.each(function() {
                jQuery.data( this, key, value );
            }) :

            // Gets one value
            // Try to fetch any internally stored data first
            elem ? dataAttr( elem, key, jQuery.data( elem, key ) ) : undefined;
    },

    removeData: function( key ) {
        return this.each(function() {
            jQuery.removeData( this, key );
        });
    }
});


jQuery.extend({
    queue: function( elem, type, data ) {
        var queue;

        if ( elem ) {
            type = ( type || "fx" ) + "queue";
            queue = jQuery._data( elem, type );

            // Speed up dequeue by getting out quickly if this is just a lookup
            if ( data ) {
                if ( !queue || jQuery.isArray(data) ) {
                    queue = jQuery._data( elem, type, jQuery.makeArray(data) );
                } else {
                    queue.push( data );
                }
            }
            return queue || [];
        }
    },

    dequeue: function( elem, type ) {
        type = type || "fx";

        var queue = jQuery.queue( elem, type ),
            startLength = queue.length,
            fn = queue.shift(),
            hooks = jQuery._queueHooks( elem, type ),
            next = function() {
                jQuery.dequeue( elem, type );
            };

        // If the fx queue is dequeued, always remove the progress sentinel
        if ( fn === "inprogress" ) {
            fn = queue.shift();
            startLength--;
        }

        if ( fn ) {

            // Add a progress sentinel to prevent the fx queue from being
            // automatically dequeued
            if ( type === "fx" ) {
                queue.unshift( "inprogress" );
            }

            // clear up the last queue stop function
            delete hooks.stop;
            fn.call( elem, next, hooks );
        }

        if ( !startLength && hooks ) {
            hooks.empty.fire();
        }
    },

    // not intended for public consumption - generates a queueHooks object, or returns the current one
    _queueHooks: function( elem, type ) {
        var key = type + "queueHooks";
        return jQuery._data( elem, key ) || jQuery._data( elem, key, {
            empty: jQuery.Callbacks("once memory").add(function() {
                jQuery._removeData( elem, type + "queue" );
                jQuery._removeData( elem, key );
            })
        });
    }
});

jQuery.fn.extend({
    queue: function( type, data ) {
        var setter = 2;

        if ( typeof type !== "string" ) {
            data = type;
            type = "fx";
            setter--;
        }

        if ( arguments.length < setter ) {
            return jQuery.queue( this[0], type );
        }

        return data === undefined ?
            this :
            this.each(function() {
                var queue = jQuery.queue( this, type, data );

                // ensure a hooks for this queue
                jQuery._queueHooks( this, type );

                if ( type === "fx" && queue[0] !== "inprogress" ) {
                    jQuery.dequeue( this, type );
                }
            });
    },
    dequeue: function( type ) {
        return this.each(function() {
            jQuery.dequeue( this, type );
        });
    },
    clearQueue: function( type ) {
        return this.queue( type || "fx", [] );
    },
    // Get a promise resolved when queues of a certain type
    // are emptied (fx is the type by default)
    promise: function( type, obj ) {
        var tmp,
            count = 1,
            defer = jQuery.Deferred(),
            elements = this,
            i = this.length,
            resolve = function() {
                if ( !( --count ) ) {
                    defer.resolveWith( elements, [ elements ] );
                }
            };

        if ( typeof type !== "string" ) {
            obj = type;
            type = undefined;
        }
        type = type || "fx";

        while ( i-- ) {
            tmp = jQuery._data( elements[ i ], type + "queueHooks" );
            if ( tmp && tmp.empty ) {
                count++;
                tmp.empty.add( resolve );
            }
        }
        resolve();
        return defer.promise( obj );
    }
});
var pnum = (/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/).source;

var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var isHidden = function( elem, el ) {
        // isHidden might be called from jQuery#filter function;
        // in that case, element will be second argument
        elem = el || elem;
        return jQuery.css( elem, "display" ) === "none" || !jQuery.contains( elem.ownerDocument, elem );
    };



// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = jQuery.access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
    var i = 0,
        length = elems.length,
        bulk = key == null;

    // Sets many values
    if ( jQuery.type( key ) === "object" ) {
        chainable = true;
        for ( i in key ) {
            jQuery.access( elems, fn, i, key[i], true, emptyGet, raw );
        }

    // Sets one value
    } else if ( value !== undefined ) {
        chainable = true;

        if ( !jQuery.isFunction( value ) ) {
            raw = true;
        }

        if ( bulk ) {
            // Bulk operations run against the entire set
            if ( raw ) {
                fn.call( elems, value );
                fn = null;

            // ...except when executing function values
            } else {
                bulk = fn;
                fn = function( elem, key, value ) {
                    return bulk.call( jQuery( elem ), value );
                };
            }
        }

        if ( fn ) {
            for ( ; i < length; i++ ) {
                fn( elems[i], key, raw ? value : value.call( elems[i], i, fn( elems[i], key ) ) );
            }
        }
    }

    return chainable ?
        elems :

        // Gets
        bulk ?
            fn.call( elems ) :
            length ? fn( elems[0], key ) : emptyGet;
};
var rcheckableType = (/^(?:checkbox|radio)$/i);



(function() {
    // Minified: var a,b,c
    var input = document.createElement( "input" ),
        div = document.createElement( "div" ),
        fragment = document.createDocumentFragment();

    // Setup
    div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";

    // IE strips leading whitespace when .innerHTML is used
    support.leadingWhitespace = div.firstChild.nodeType === 3;

    // Make sure that tbody elements aren't automatically inserted
    // IE will insert them into empty tables
    support.tbody = !div.getElementsByTagName( "tbody" ).length;

    // Make sure that link elements get serialized correctly by innerHTML
    // This requires a wrapper element in IE
    support.htmlSerialize = !!div.getElementsByTagName( "link" ).length;

    // Makes sure cloning an html5 element does not cause problems
    // Where outerHTML is undefined, this still works
    support.html5Clone =
        document.createElement( "nav" ).cloneNode( true ).outerHTML !== "<:nav></:nav>";

    // Check if a disconnected checkbox will retain its checked
    // value of true after appended to the DOM (IE6/7)
    input.type = "checkbox";
    input.checked = true;
    fragment.appendChild( input );
    support.appendChecked = input.checked;

    // Make sure textarea (and checkbox) defaultValue is properly cloned
    // Support: IE6-IE11+
    div.innerHTML = "<textarea>x</textarea>";
    support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;

    // #11217 - WebKit loses check when the name is after the checked attribute
    fragment.appendChild( div );
    div.innerHTML = "<input type='radio' checked='checked' name='t'/>";

    // Support: Safari 5.1, iOS 5.1, Android 4.x, Android 2.3
    // old WebKit doesn't clone checked state correctly in fragments
    support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

    // Support: IE<9
    // Opera does not clone events (and typeof div.attachEvent === undefined).
    // IE9-10 clones events bound via attachEvent, but they don't trigger with .click()
    support.noCloneEvent = true;
    if ( div.attachEvent ) {
        div.attachEvent( "onclick", function() {
            support.noCloneEvent = false;
        });

        div.cloneNode( true ).click();
    }

    // Execute the test only if not already executed in another module.
    if (support.deleteExpando == null) {
        // Support: IE<9
        support.deleteExpando = true;
        try {
            delete div.test;
        } catch( e ) {
            support.deleteExpando = false;
        }
    }
})();


(function() {
    var i, eventName,
        div = document.createElement( "div" );

    // Support: IE<9 (lack submit/change bubble), Firefox 23+ (lack focusin event)
    for ( i in { submit: true, change: true, focusin: true }) {
        eventName = "on" + i;

        if ( !(support[ i + "Bubbles" ] = eventName in window) ) {
            // Beware of CSP restrictions (https://developer.mozilla.org/en/Security/CSP)
            div.setAttribute( eventName, "t" );
            support[ i + "Bubbles" ] = div.attributes[ eventName ].expando === false;
        }
    }

    // Null elements to avoid leaks in IE.
    div = null;
})();


var rformElems = /^(?:input|select|textarea)$/i,
    rkeyEvent = /^key/,
    rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/,
    rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
    rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;

function returnTrue() {
    return true;
}

function returnFalse() {
    return false;
}

function safeActiveElement() {
    try {
        return document.activeElement;
    } catch ( err ) { }
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

    global: {},

    add: function( elem, types, handler, data, selector ) {
        var tmp, events, t, handleObjIn,
            special, eventHandle, handleObj,
            handlers, type, namespaces, origType,
            elemData = jQuery._data( elem );

        // Don't attach events to noData or text/comment nodes (but allow plain objects)
        if ( !elemData ) {
            return;
        }

        // Caller can pass in an object of custom data in lieu of the handler
        if ( handler.handler ) {
            handleObjIn = handler;
            handler = handleObjIn.handler;
            selector = handleObjIn.selector;
        }

        // Make sure that the handler has a unique ID, used to find/remove it later
        if ( !handler.guid ) {
            handler.guid = jQuery.guid++;
        }

        // Init the element's event structure and main handler, if this is the first
        if ( !(events = elemData.events) ) {
            events = elemData.events = {};
        }
        if ( !(eventHandle = elemData.handle) ) {
            eventHandle = elemData.handle = function( e ) {
                // Discard the second event of a jQuery.event.trigger() and
                // when an event is called after a page has unloaded
                return typeof jQuery !== strundefined && (!e || jQuery.event.triggered !== e.type) ?
                    jQuery.event.dispatch.apply( eventHandle.elem, arguments ) :
                    undefined;
            };
            // Add elem as a property of the handle fn to prevent a memory leak with IE non-native events
            eventHandle.elem = elem;
        }

        // Handle multiple events separated by a space
        types = ( types || "" ).match( rnotwhite ) || [ "" ];
        t = types.length;
        while ( t-- ) {
            tmp = rtypenamespace.exec( types[t] ) || [];
            type = origType = tmp[1];
            namespaces = ( tmp[2] || "" ).split( "." ).sort();

            // There *must* be a type, no attaching namespace-only handlers
            if ( !type ) {
                continue;
            }

            // If event changes its type, use the special event handlers for the changed type
            special = jQuery.event.special[ type ] || {};

            // If selector defined, determine special event api type, otherwise given type
            type = ( selector ? special.delegateType : special.bindType ) || type;

            // Update special based on newly reset type
            special = jQuery.event.special[ type ] || {};

            // handleObj is passed to all event handlers
            handleObj = jQuery.extend({
                type: type,
                origType: origType,
                data: data,
                handler: handler,
                guid: handler.guid,
                selector: selector,
                needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
                namespace: namespaces.join(".")
            }, handleObjIn );

            // Init the event handler queue if we're the first
            if ( !(handlers = events[ type ]) ) {
                handlers = events[ type ] = [];
                handlers.delegateCount = 0;

                // Only use addEventListener/attachEvent if the special events handler returns false
                if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
                    // Bind the global event handler to the element
                    if ( elem.addEventListener ) {
                        elem.addEventListener( type, eventHandle, false );

                    } else if ( elem.attachEvent ) {
                        elem.attachEvent( "on" + type, eventHandle );
                    }
                }
            }

            if ( special.add ) {
                special.add.call( elem, handleObj );

                if ( !handleObj.handler.guid ) {
                    handleObj.handler.guid = handler.guid;
                }
            }

            // Add to the element's handler list, delegates in front
            if ( selector ) {
                handlers.splice( handlers.delegateCount++, 0, handleObj );
            } else {
                handlers.push( handleObj );
            }

            // Keep track of which events have ever been used, for event optimization
            jQuery.event.global[ type ] = true;
        }

        // Nullify elem to prevent memory leaks in IE
        elem = null;
    },

    // Detach an event or set of events from an element
    remove: function( elem, types, handler, selector, mappedTypes ) {
        var j, handleObj, tmp,
            origCount, t, events,
            special, handlers, type,
            namespaces, origType,
            elemData = jQuery.hasData( elem ) && jQuery._data( elem );

        if ( !elemData || !(events = elemData.events) ) {
            return;
        }

        // Once for each type.namespace in types; type may be omitted
        types = ( types || "" ).match( rnotwhite ) || [ "" ];
        t = types.length;
        while ( t-- ) {
            tmp = rtypenamespace.exec( types[t] ) || [];
            type = origType = tmp[1];
            namespaces = ( tmp[2] || "" ).split( "." ).sort();

            // Unbind all events (on this namespace, if provided) for the element
            if ( !type ) {
                for ( type in events ) {
                    jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
                }
                continue;
            }

            special = jQuery.event.special[ type ] || {};
            type = ( selector ? special.delegateType : special.bindType ) || type;
            handlers = events[ type ] || [];
            tmp = tmp[2] && new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" );

            // Remove matching events
            origCount = j = handlers.length;
            while ( j-- ) {
                handleObj = handlers[ j ];

                if ( ( mappedTypes || origType === handleObj.origType ) &&
                    ( !handler || handler.guid === handleObj.guid ) &&
                    ( !tmp || tmp.test( handleObj.namespace ) ) &&
                    ( !selector || selector === handleObj.selector || selector === "**" && handleObj.selector ) ) {
                    handlers.splice( j, 1 );

                    if ( handleObj.selector ) {
                        handlers.delegateCount--;
                    }
                    if ( special.remove ) {
                        special.remove.call( elem, handleObj );
                    }
                }
            }

            // Remove generic event handler if we removed something and no more handlers exist
            // (avoids potential for endless recursion during removal of special event handlers)
            if ( origCount && !handlers.length ) {
                if ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
                    jQuery.removeEvent( elem, type, elemData.handle );
                }

                delete events[ type ];
            }
        }

        // Remove the expando if it's no longer used
        if ( jQuery.isEmptyObject( events ) ) {
            delete elemData.handle;

            // removeData also checks for emptiness and clears the expando if empty
            // so use it instead of delete
            jQuery._removeData( elem, "events" );
        }
    },

    trigger: function( event, data, elem, onlyHandlers ) {
        var handle, ontype, cur,
            bubbleType, special, tmp, i,
            eventPath = [ elem || document ],
            type = hasOwn.call( event, "type" ) ? event.type : event,
            namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split(".") : [];

        cur = tmp = elem = elem || document;

        // Don't do events on text and comment nodes
        if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
            return;
        }

        // focus/blur morphs to focusin/out; ensure we're not firing them right now
        if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
            return;
        }

        if ( type.indexOf(".") >= 0 ) {
            // Namespaced trigger; create a regexp to match event type in handle()
            namespaces = type.split(".");
            type = namespaces.shift();
            namespaces.sort();
        }
        ontype = type.indexOf(":") < 0 && "on" + type;

        // Caller can pass in a jQuery.Event object, Object, or just an event type string
        event = event[ jQuery.expando ] ?
            event :
            new jQuery.Event( type, typeof event === "object" && event );

        // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
        event.isTrigger = onlyHandlers ? 2 : 3;
        event.namespace = namespaces.join(".");
        event.namespace_re = event.namespace ?
            new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" ) :
            null;

        // Clean up the event in case it is being reused
        event.result = undefined;
        if ( !event.target ) {
            event.target = elem;
        }

        // Clone any incoming data and prepend the event, creating the handler arg list
        data = data == null ?
            [ event ] :
            jQuery.makeArray( data, [ event ] );

        // Allow special events to draw outside the lines
        special = jQuery.event.special[ type ] || {};
        if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
            return;
        }

        // Determine event propagation path in advance, per W3C events spec (#9951)
        // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
        if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

            bubbleType = special.delegateType || type;
            if ( !rfocusMorph.test( bubbleType + type ) ) {
                cur = cur.parentNode;
            }
            for ( ; cur; cur = cur.parentNode ) {
                eventPath.push( cur );
                tmp = cur;
            }

            // Only add window if we got to document (e.g., not plain obj or detached DOM)
            if ( tmp === (elem.ownerDocument || document) ) {
                eventPath.push( tmp.defaultView || tmp.parentWindow || window );
            }
        }

        // Fire handlers on the event path
        i = 0;
        while ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) {

            event.type = i > 1 ?
                bubbleType :
                special.bindType || type;

            // jQuery handler
            handle = ( jQuery._data( cur, "events" ) || {} )[ event.type ] && jQuery._data( cur, "handle" );
            if ( handle ) {
                handle.apply( cur, data );
            }

            // Native handler
            handle = ontype && cur[ ontype ];
            if ( handle && handle.apply && jQuery.acceptData( cur ) ) {
                event.result = handle.apply( cur, data );
                if ( event.result === false ) {
                    event.preventDefault();
                }
            }
        }
        event.type = type;

        // If nobody prevented the default action, do it now
        if ( !onlyHandlers && !event.isDefaultPrevented() ) {

            if ( (!special._default || special._default.apply( eventPath.pop(), data ) === false) &&
                jQuery.acceptData( elem ) ) {

                // Call a native DOM method on the target with the same name name as the event.
                // Can't use an .isFunction() check here because IE6/7 fails that test.
                // Don't do default actions on window, that's where global variables be (#6170)
                if ( ontype && elem[ type ] && !jQuery.isWindow( elem ) ) {

                    // Don't re-trigger an onFOO event when we call its FOO() method
                    tmp = elem[ ontype ];

                    if ( tmp ) {
                        elem[ ontype ] = null;
                    }

                    // Prevent re-triggering of the same event, since we already bubbled it above
                    jQuery.event.triggered = type;
                    try {
                        elem[ type ]();
                    } catch ( e ) {
                        // IE<9 dies on focus/blur to hidden element (#1486,#12518)
                        // only reproducible on winXP IE8 native, not IE9 in IE8 mode
                    }
                    jQuery.event.triggered = undefined;

                    if ( tmp ) {
                        elem[ ontype ] = tmp;
                    }
                }
            }
        }

        return event.result;
    },

    dispatch: function( event ) {

        // Make a writable jQuery.Event from the native event object
        event = jQuery.event.fix( event );

        var i, ret, handleObj, matched, j,
            handlerQueue = [],
            args = slice.call( arguments ),
            handlers = ( jQuery._data( this, "events" ) || {} )[ event.type ] || [],
            special = jQuery.event.special[ event.type ] || {};

        // Use the fix-ed jQuery.Event rather than the (read-only) native event
        args[0] = event;
        event.delegateTarget = this;

        // Call the preDispatch hook for the mapped type, and let it bail if desired
        if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
            return;
        }

        // Determine handlers
        handlerQueue = jQuery.event.handlers.call( this, event, handlers );

        // Run delegates first; they may want to stop propagation beneath us
        i = 0;
        while ( (matched = handlerQueue[ i++ ]) && !event.isPropagationStopped() ) {
            event.currentTarget = matched.elem;

            j = 0;
            while ( (handleObj = matched.handlers[ j++ ]) && !event.isImmediatePropagationStopped() ) {

                // Triggered event must either 1) have no namespace, or
                // 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).
                if ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {

                    event.handleObj = handleObj;
                    event.data = handleObj.data;

                    ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
                            .apply( matched.elem, args );

                    if ( ret !== undefined ) {
                        if ( (event.result = ret) === false ) {
                            event.preventDefault();
                            event.stopPropagation();
                        }
                    }
                }
            }
        }

        // Call the postDispatch hook for the mapped type
        if ( special.postDispatch ) {
            special.postDispatch.call( this, event );
        }

        return event.result;
    },

    handlers: function( event, handlers ) {
        var sel, handleObj, matches, i,
            handlerQueue = [],
            delegateCount = handlers.delegateCount,
            cur = event.target;

        // Find delegate handlers
        // Black-hole SVG <use> instance trees (#13180)
        // Avoid non-left-click bubbling in Firefox (#3861)
        if ( delegateCount && cur.nodeType && (!event.button || event.type !== "click") ) {

            /* jshint eqeqeq: false */
            for ( ; cur != this; cur = cur.parentNode || this ) {
                /* jshint eqeqeq: true */

                // Don't check non-elements (#13208)
                // Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
                if ( cur.nodeType === 1 && (cur.disabled !== true || event.type !== "click") ) {
                    matches = [];
                    for ( i = 0; i < delegateCount; i++ ) {
                        handleObj = handlers[ i ];

                        // Don't conflict with Object.prototype properties (#13203)
                        sel = handleObj.selector + " ";

                        if ( matches[ sel ] === undefined ) {
                            matches[ sel ] = handleObj.needsContext ?
                                jQuery( sel, this ).index( cur ) >= 0 :
                                jQuery.find( sel, this, null, [ cur ] ).length;
                        }
                        if ( matches[ sel ] ) {
                            matches.push( handleObj );
                        }
                    }
                    if ( matches.length ) {
                        handlerQueue.push({ elem: cur, handlers: matches });
                    }
                }
            }
        }

        // Add the remaining (directly-bound) handlers
        if ( delegateCount < handlers.length ) {
            handlerQueue.push({ elem: this, handlers: handlers.slice( delegateCount ) });
        }

        return handlerQueue;
    },

    fix: function( event ) {
        if ( event[ jQuery.expando ] ) {
            return event;
        }

        // Create a writable copy of the event object and normalize some properties
        var i, prop, copy,
            type = event.type,
            originalEvent = event,
            fixHook = this.fixHooks[ type ];

        if ( !fixHook ) {
            this.fixHooks[ type ] = fixHook =
                rmouseEvent.test( type ) ? this.mouseHooks :
                rkeyEvent.test( type ) ? this.keyHooks :
                {};
        }
        copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

        event = new jQuery.Event( originalEvent );

        i = copy.length;
        while ( i-- ) {
            prop = copy[ i ];
            event[ prop ] = originalEvent[ prop ];
        }

        // Support: IE<9
        // Fix target property (#1925)
        if ( !event.target ) {
            event.target = originalEvent.srcElement || document;
        }

        // Support: Chrome 23+, Safari?
        // Target should not be a text node (#504, #13143)
        if ( event.target.nodeType === 3 ) {
            event.target = event.target.parentNode;
        }

        // Support: IE<9
        // For mouse/key events, metaKey==false if it's undefined (#3368, #11328)
        event.metaKey = !!event.metaKey;

        return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;
    },

    // Includes some event props shared by KeyEvent and MouseEvent
    props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),

    fixHooks: {},

    keyHooks: {
        props: "char charCode key keyCode".split(" "),
        filter: function( event, original ) {

            // Add which for key events
            if ( event.which == null ) {
                event.which = original.charCode != null ? original.charCode : original.keyCode;
            }

            return event;
        }
    },

    mouseHooks: {
        props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
        filter: function( event, original ) {
            var body, eventDoc, doc,
                button = original.button,
                fromElement = original.fromElement;

            // Calculate pageX/Y if missing and clientX/Y available
            if ( event.pageX == null && original.clientX != null ) {
                eventDoc = event.target.ownerDocument || document;
                doc = eventDoc.documentElement;
                body = eventDoc.body;

                event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );
                event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );
            }

            // Add relatedTarget, if necessary
            if ( !event.relatedTarget && fromElement ) {
                event.relatedTarget = fromElement === event.target ? original.toElement : fromElement;
            }

            // Add which for click: 1 === left; 2 === middle; 3 === right
            // Note: button is not normalized, so don't use it
            if ( !event.which && button !== undefined ) {
                event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
            }

            return event;
        }
    },

    special: {
        load: {
            // Prevent triggered image.load events from bubbling to window.load
            noBubble: true
        },
        focus: {
            // Fire native event if possible so blur/focus sequence is correct
            trigger: function() {
                if ( this !== safeActiveElement() && this.focus ) {
                    try {
                        this.focus();
                        return false;
                    } catch ( e ) {
                        // Support: IE<9
                        // If we error on focus to hidden element (#1486, #12518),
                        // let .trigger() run the handlers
                    }
                }
            },
            delegateType: "focusin"
        },
        blur: {
            trigger: function() {
                if ( this === safeActiveElement() && this.blur ) {
                    this.blur();
                    return false;
                }
            },
            delegateType: "focusout"
        },
        click: {
            // For checkbox, fire native event so checked state will be right
            trigger: function() {
                if ( jQuery.nodeName( this, "input" ) && this.type === "checkbox" && this.click ) {
                    this.click();
                    return false;
                }
            },

            // For cross-browser consistency, don't fire native .click() on links
            _default: function( event ) {
                return jQuery.nodeName( event.target, "a" );
            }
        },

        beforeunload: {
            postDispatch: function( event ) {

                // Support: Firefox 20+
                // Firefox doesn't alert if the returnValue field is not set.
                if ( event.result !== undefined && event.originalEvent ) {
                    event.originalEvent.returnValue = event.result;
                }
            }
        }
    },

    simulate: function( type, elem, event, bubble ) {
        // Piggyback on a donor event to simulate a different one.
        // Fake originalEvent to avoid donor's stopPropagation, but if the
        // simulated event prevents default then we do the same on the donor.
        var e = jQuery.extend(
            new jQuery.Event(),
            event,
            {
                type: type,
                isSimulated: true,
                originalEvent: {}
            }
        );
        if ( bubble ) {
            jQuery.event.trigger( e, null, elem );
        } else {
            jQuery.event.dispatch.call( elem, e );
        }
        if ( e.isDefaultPrevented() ) {
            event.preventDefault();
        }
    }
};

jQuery.removeEvent = document.removeEventListener ?
    function( elem, type, handle ) {
        if ( elem.removeEventListener ) {
            elem.removeEventListener( type, handle, false );
        }
    } :
    function( elem, type, handle ) {
        var name = "on" + type;

        if ( elem.detachEvent ) {

            // #8545, #7054, preventing memory leaks for custom events in IE6-8
            // detachEvent needed property on element, by name of that event, to properly expose it to GC
            if ( typeof elem[ name ] === strundefined ) {
                elem[ name ] = null;
            }

            elem.detachEvent( name, handle );
        }
    };

jQuery.Event = function( src, props ) {
    // Allow instantiation without the 'new' keyword
    if ( !(this instanceof jQuery.Event) ) {
        return new jQuery.Event( src, props );
    }

    // Event object
    if ( src && src.type ) {
        this.originalEvent = src;
        this.type = src.type;

        // Events bubbling up the document may have been marked as prevented
        // by a handler lower down the tree; reflect the correct value.
        this.isDefaultPrevented = src.defaultPrevented ||
                src.defaultPrevented === undefined &&
                // Support: IE < 9, Android < 4.0
                src.returnValue === false ?
            returnTrue :
            returnFalse;

    // Event type
    } else {
        this.type = src;
    }

    // Put explicitly provided properties onto the event object
    if ( props ) {
        jQuery.extend( this, props );
    }

    // Create a timestamp if incoming event doesn't have one
    this.timeStamp = src && src.timeStamp || jQuery.now();

    // Mark it as fixed
    this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
    isDefaultPrevented: returnFalse,
    isPropagationStopped: returnFalse,
    isImmediatePropagationStopped: returnFalse,

    preventDefault: function() {
        var e = this.originalEvent;

        this.isDefaultPrevented = returnTrue;
        if ( !e ) {
            return;
        }

        // If preventDefault exists, run it on the original event
        if ( e.preventDefault ) {
            e.preventDefault();

        // Support: IE
        // Otherwise set the returnValue property of the original event to false
        } else {
            e.returnValue = false;
        }
    },
    stopPropagation: function() {
        var e = this.originalEvent;

        this.isPropagationStopped = returnTrue;
        if ( !e ) {
            return;
        }
        // If stopPropagation exists, run it on the original event
        if ( e.stopPropagation ) {
            e.stopPropagation();
        }

        // Support: IE
        // Set the cancelBubble property of the original event to true
        e.cancelBubble = true;
    },
    stopImmediatePropagation: function() {
        var e = this.originalEvent;

        this.isImmediatePropagationStopped = returnTrue;

        if ( e && e.stopImmediatePropagation ) {
            e.stopImmediatePropagation();
        }

        this.stopPropagation();
    }
};

// Create mouseenter/leave events using mouseover/out and event-time checks
jQuery.each({
    mouseenter: "mouseover",
    mouseleave: "mouseout",
    pointerenter: "pointerover",
    pointerleave: "pointerout"
}, function( orig, fix ) {
    jQuery.event.special[ orig ] = {
        delegateType: fix,
        bindType: fix,

        handle: function( event ) {
            var ret,
                target = this,
                related = event.relatedTarget,
                handleObj = event.handleObj;

            // For mousenter/leave call the handler if related is outside the target.
            // NB: No relatedTarget if the mouse left/entered the browser window
            if ( !related || (related !== target && !jQuery.contains( target, related )) ) {
                event.type = handleObj.origType;
                ret = handleObj.handler.apply( this, arguments );
                event.type = fix;
            }
            return ret;
        }
    };
});

// IE submit delegation
if ( !support.submitBubbles ) {

    jQuery.event.special.submit = {
        setup: function() {
            // Only need this for delegated form submit events
            if ( jQuery.nodeName( this, "form" ) ) {
                return false;
            }

            // Lazy-add a submit handler when a descendant form may potentially be submitted
            jQuery.event.add( this, "click._submit keypress._submit", function( e ) {
                // Node name check avoids a VML-related crash in IE (#9807)
                var elem = e.target,
                    form = jQuery.nodeName( elem, "input" ) || jQuery.nodeName( elem, "button" ) ? elem.form : undefined;
                if ( form && !jQuery._data( form, "submitBubbles" ) ) {
                    jQuery.event.add( form, "submit._submit", function( event ) {
                        event._submit_bubble = true;
                    });
                    jQuery._data( form, "submitBubbles", true );
                }
            });
            // return undefined since we don't need an event listener
        },

        postDispatch: function( event ) {
            // If form was submitted by the user, bubble the event up the tree
            if ( event._submit_bubble ) {
                delete event._submit_bubble;
                if ( this.parentNode && !event.isTrigger ) {
                    jQuery.event.simulate( "submit", this.parentNode, event, true );
                }
            }
        },

        teardown: function() {
            // Only need this for delegated form submit events
            if ( jQuery.nodeName( this, "form" ) ) {
                return false;
            }

            // Remove delegated handlers; cleanData eventually reaps submit handlers attached above
            jQuery.event.remove( this, "._submit" );
        }
    };
}

// IE change delegation and checkbox/radio fix
if ( !support.changeBubbles ) {

    jQuery.event.special.change = {

        setup: function() {

            if ( rformElems.test( this.nodeName ) ) {
                // IE doesn't fire change on a check/radio until blur; trigger it on click
                // after a propertychange. Eat the blur-change in special.change.handle.
                // This still fires onchange a second time for check/radio after blur.
                if ( this.type === "checkbox" || this.type === "radio" ) {
                    jQuery.event.add( this, "propertychange._change", function( event ) {
                        if ( event.originalEvent.propertyName === "checked" ) {
                            this._just_changed = true;
                        }
                    });
                    jQuery.event.add( this, "click._change", function( event ) {
                        if ( this._just_changed && !event.isTrigger ) {
                            this._just_changed = false;
                        }
                        // Allow triggered, simulated change events (#11500)
                        jQuery.event.simulate( "change", this, event, true );
                    });
                }
                return false;
            }
            // Delegated event; lazy-add a change handler on descendant inputs
            jQuery.event.add( this, "beforeactivate._change", function( e ) {
                var elem = e.target;

                if ( rformElems.test( elem.nodeName ) && !jQuery._data( elem, "changeBubbles" ) ) {
                    jQuery.event.add( elem, "change._change", function( event ) {
                        if ( this.parentNode && !event.isSimulated && !event.isTrigger ) {
                            jQuery.event.simulate( "change", this.parentNode, event, true );
                        }
                    });
                    jQuery._data( elem, "changeBubbles", true );
                }
            });
        },

        handle: function( event ) {
            var elem = event.target;

            // Swallow native change events from checkbox/radio, we already triggered them above
            if ( this !== elem || event.isSimulated || event.isTrigger || (elem.type !== "radio" && elem.type !== "checkbox") ) {
                return event.handleObj.handler.apply( this, arguments );
            }
        },

        teardown: function() {
            jQuery.event.remove( this, "._change" );

            return !rformElems.test( this.nodeName );
        }
    };
}

// Create "bubbling" focus and blur events
if ( !support.focusinBubbles ) {
    jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {

        // Attach a single capturing handler on the document while someone wants focusin/focusout
        var handler = function( event ) {
                jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
            };

        jQuery.event.special[ fix ] = {
            setup: function() {
                var doc = this.ownerDocument || this,
                    attaches = jQuery._data( doc, fix );

                if ( !attaches ) {
                    doc.addEventListener( orig, handler, true );
                }
                jQuery._data( doc, fix, ( attaches || 0 ) + 1 );
            },
            teardown: function() {
                var doc = this.ownerDocument || this,
                    attaches = jQuery._data( doc, fix ) - 1;

                if ( !attaches ) {
                    doc.removeEventListener( orig, handler, true );
                    jQuery._removeData( doc, fix );
                } else {
                    jQuery._data( doc, fix, attaches );
                }
            }
        };
    });
}

jQuery.fn.extend({

    on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
        var type, origFn;

        // Types can be a map of types/handlers
        if ( typeof types === "object" ) {
            // ( types-Object, selector, data )
            if ( typeof selector !== "string" ) {
                // ( types-Object, data )
                data = data || selector;
                selector = undefined;
            }
            for ( type in types ) {
                this.on( type, selector, data, types[ type ], one );
            }
            return this;
        }

        if ( data == null && fn == null ) {
            // ( types, fn )
            fn = selector;
            data = selector = undefined;
        } else if ( fn == null ) {
            if ( typeof selector === "string" ) {
                // ( types, selector, fn )
                fn = data;
                data = undefined;
            } else {
                // ( types, data, fn )
                fn = data;
                data = selector;
                selector = undefined;
            }
        }
        if ( fn === false ) {
            fn = returnFalse;
        } else if ( !fn ) {
            return this;
        }

        if ( one === 1 ) {
            origFn = fn;
            fn = function( event ) {
                // Can use an empty set, since event contains the info
                jQuery().off( event );
                return origFn.apply( this, arguments );
            };
            // Use same guid so caller can remove using origFn
            fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
        }
        return this.each( function() {
            jQuery.event.add( this, types, fn, data, selector );
        });
    },
    one: function( types, selector, data, fn ) {
        return this.on( types, selector, data, fn, 1 );
    },
    off: function( types, selector, fn ) {
        var handleObj, type;
        if ( types && types.preventDefault && types.handleObj ) {
            // ( event )  dispatched jQuery.Event
            handleObj = types.handleObj;
            jQuery( types.delegateTarget ).off(
                handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
                handleObj.selector,
                handleObj.handler
            );
            return this;
        }
        if ( typeof types === "object" ) {
            // ( types-object [, selector] )
            for ( type in types ) {
                this.off( type, selector, types[ type ] );
            }
            return this;
        }
        if ( selector === false || typeof selector === "function" ) {
            // ( types [, fn] )
            fn = selector;
            selector = undefined;
        }
        if ( fn === false ) {
            fn = returnFalse;
        }
        return this.each(function() {
            jQuery.event.remove( this, types, fn, selector );
        });
    },

    trigger: function( type, data ) {
        return this.each(function() {
            jQuery.event.trigger( type, data, this );
        });
    },
    triggerHandler: function( type, data ) {
        var elem = this[0];
        if ( elem ) {
            return jQuery.event.trigger( type, data, elem, true );
        }
    }
});


function createSafeFragment( document ) {
    var list = nodeNames.split( "|" ),
        safeFrag = document.createDocumentFragment();

    if ( safeFrag.createElement ) {
        while ( list.length ) {
            safeFrag.createElement(
                list.pop()
            );
        }
    }
    return safeFrag;
}

var nodeNames = "abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|" +
        "header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",
    rinlinejQuery = / jQuery\d+="(?:null|\d+)"/g,
    rnoshimcache = new RegExp("<(?:" + nodeNames + ")[\\s/>]", "i"),
    rleadingWhitespace = /^\s+/,
    rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
    rtagName = /<([\w:]+)/,
    rtbody = /<tbody/i,
    rhtml = /<|&#?\w+;/,
    rnoInnerhtml = /<(?:script|style|link)/i,
    // checked="checked" or checked
    rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
    rscriptType = /^$|\/(?:java|ecma)script/i,
    rscriptTypeMasked = /^true\/(.*)/,
    rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,

    // We have to close these tags to support XHTML (#13200)
    wrapMap = {
        option: [ 1, "<select multiple='multiple'>", "</select>" ],
        legend: [ 1, "<fieldset>", "</fieldset>" ],
        area: [ 1, "<map>", "</map>" ],
        param: [ 1, "<object>", "</object>" ],
        thead: [ 1, "<table>", "</table>" ],
        tr: [ 2, "<table><tbody>", "</tbody></table>" ],
        col: [ 2, "<table><tbody></tbody><colgroup>", "</colgroup></table>" ],
        td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

        // IE6-8 can't serialize link, script, style, or any html5 (NoScope) tags,
        // unless wrapped in a div with non-breaking characters in front of it.
        _default: support.htmlSerialize ? [ 0, "", "" ] : [ 1, "X<div>", "</div>"  ]
    },
    safeFragment = createSafeFragment( document ),
    fragmentDiv = safeFragment.appendChild( document.createElement("div") );

wrapMap.optgroup = wrapMap.option;
wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

function getAll( context, tag ) {
    var elems, elem,
        i = 0,
        found = typeof context.getElementsByTagName !== strundefined ? context.getElementsByTagName( tag || "*" ) :
            typeof context.querySelectorAll !== strundefined ? context.querySelectorAll( tag || "*" ) :
            undefined;

    if ( !found ) {
        for ( found = [], elems = context.childNodes || context; (elem = elems[i]) != null; i++ ) {
            if ( !tag || jQuery.nodeName( elem, tag ) ) {
                found.push( elem );
            } else {
                jQuery.merge( found, getAll( elem, tag ) );
            }
        }
    }

    return tag === undefined || tag && jQuery.nodeName( context, tag ) ?
        jQuery.merge( [ context ], found ) :
        found;
}

// Used in buildFragment, fixes the defaultChecked property
function fixDefaultChecked( elem ) {
    if ( rcheckableType.test( elem.type ) ) {
        elem.defaultChecked = elem.checked;
    }
}

// Support: IE<8
// Manipulating tables requires a tbody
function manipulationTarget( elem, content ) {
    return jQuery.nodeName( elem, "table" ) &&
        jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ?

        elem.getElementsByTagName("tbody")[0] ||
            elem.appendChild( elem.ownerDocument.createElement("tbody") ) :
        elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
    elem.type = (jQuery.find.attr( elem, "type" ) !== null) + "/" + elem.type;
    return elem;
}
function restoreScript( elem ) {
    var match = rscriptTypeMasked.exec( elem.type );
    if ( match ) {
        elem.type = match[1];
    } else {
        elem.removeAttribute("type");
    }
    return elem;
}

// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
    var elem,
        i = 0;
    for ( ; (elem = elems[i]) != null; i++ ) {
        jQuery._data( elem, "globalEval", !refElements || jQuery._data( refElements[i], "globalEval" ) );
    }
}

function cloneCopyEvent( src, dest ) {

    if ( dest.nodeType !== 1 || !jQuery.hasData( src ) ) {
        return;
    }

    var type, i, l,
        oldData = jQuery._data( src ),
        curData = jQuery._data( dest, oldData ),
        events = oldData.events;

    if ( events ) {
        delete curData.handle;
        curData.events = {};

        for ( type in events ) {
            for ( i = 0, l = events[ type ].length; i < l; i++ ) {
                jQuery.event.add( dest, type, events[ type ][ i ] );
            }
        }
    }

    // make the cloned public data object a copy from the original
    if ( curData.data ) {
        curData.data = jQuery.extend( {}, curData.data );
    }
}

function fixCloneNodeIssues( src, dest ) {
    var nodeName, e, data;

    // We do not need to do anything for non-Elements
    if ( dest.nodeType !== 1 ) {
        return;
    }

    nodeName = dest.nodeName.toLowerCase();

    // IE6-8 copies events bound via attachEvent when using cloneNode.
    if ( !support.noCloneEvent && dest[ jQuery.expando ] ) {
        data = jQuery._data( dest );

        for ( e in data.events ) {
            jQuery.removeEvent( dest, e, data.handle );
        }

        // Event data gets referenced instead of copied if the expando gets copied too
        dest.removeAttribute( jQuery.expando );
    }

    // IE blanks contents when cloning scripts, and tries to evaluate newly-set text
    if ( nodeName === "script" && dest.text !== src.text ) {
        disableScript( dest ).text = src.text;
        restoreScript( dest );

    // IE6-10 improperly clones children of object elements using classid.
    // IE10 throws NoModificationAllowedError if parent is null, #12132.
    } else if ( nodeName === "object" ) {
        if ( dest.parentNode ) {
            dest.outerHTML = src.outerHTML;
        }

        // This path appears unavoidable for IE9. When cloning an object
        // element in IE9, the outerHTML strategy above is not sufficient.
        // If the src has innerHTML and the destination does not,
        // copy the src.innerHTML into the dest.innerHTML. #10324
        if ( support.html5Clone && ( src.innerHTML && !jQuery.trim(dest.innerHTML) ) ) {
            dest.innerHTML = src.innerHTML;
        }

    } else if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
        // IE6-8 fails to persist the checked state of a cloned checkbox
        // or radio button. Worse, IE6-7 fail to give the cloned element
        // a checked appearance if the defaultChecked value isn't also set

        dest.defaultChecked = dest.checked = src.checked;

        // IE6-7 get confused and end up setting the value of a cloned
        // checkbox/radio button to an empty string instead of "on"
        if ( dest.value !== src.value ) {
            dest.value = src.value;
        }

    // IE6-8 fails to return the selected option to the default selected
    // state when cloning options
    } else if ( nodeName === "option" ) {
        dest.defaultSelected = dest.selected = src.defaultSelected;

    // IE6-8 fails to set the defaultValue to the correct value when
    // cloning other types of input fields
    } else if ( nodeName === "input" || nodeName === "textarea" ) {
        dest.defaultValue = src.defaultValue;
    }
}

jQuery.extend({
    clone: function( elem, dataAndEvents, deepDataAndEvents ) {
        var destElements, node, clone, i, srcElements,
            inPage = jQuery.contains( elem.ownerDocument, elem );

        if ( support.html5Clone || jQuery.isXMLDoc(elem) || !rnoshimcache.test( "<" + elem.nodeName + ">" ) ) {
            clone = elem.cloneNode( true );

        // IE<=8 does not properly clone detached, unknown element nodes
        } else {
            fragmentDiv.innerHTML = elem.outerHTML;
            fragmentDiv.removeChild( clone = fragmentDiv.firstChild );
        }

        if ( (!support.noCloneEvent || !support.noCloneChecked) &&
                (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem) ) {

            // We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
            destElements = getAll( clone );
            srcElements = getAll( elem );

            // Fix all IE cloning issues
            for ( i = 0; (node = srcElements[i]) != null; ++i ) {
                // Ensure that the destination node is not null; Fixes #9587
                if ( destElements[i] ) {
                    fixCloneNodeIssues( node, destElements[i] );
                }
            }
        }

        // Copy the events from the original to the clone
        if ( dataAndEvents ) {
            if ( deepDataAndEvents ) {
                srcElements = srcElements || getAll( elem );
                destElements = destElements || getAll( clone );

                for ( i = 0; (node = srcElements[i]) != null; i++ ) {
                    cloneCopyEvent( node, destElements[i] );
                }
            } else {
                cloneCopyEvent( elem, clone );
            }
        }

        // Preserve script evaluation history
        destElements = getAll( clone, "script" );
        if ( destElements.length > 0 ) {
            setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
        }

        destElements = srcElements = node = null;

        // Return the cloned set
        return clone;
    },

    buildFragment: function( elems, context, scripts, selection ) {
        var j, elem, contains,
            tmp, tag, tbody, wrap,
            l = elems.length,

            // Ensure a safe fragment
            safe = createSafeFragment( context ),

            nodes = [],
            i = 0;

        for ( ; i < l; i++ ) {
            elem = elems[ i ];

            if ( elem || elem === 0 ) {

                // Add nodes directly
                if ( jQuery.type( elem ) === "object" ) {
                    jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

                // Convert non-html into a text node
                } else if ( !rhtml.test( elem ) ) {
                    nodes.push( context.createTextNode( elem ) );

                // Convert html into DOM nodes
                } else {
                    tmp = tmp || safe.appendChild( context.createElement("div") );

                    // Deserialize a standard representation
                    tag = (rtagName.exec( elem ) || [ "", "" ])[ 1 ].toLowerCase();
                    wrap = wrapMap[ tag ] || wrapMap._default;

                    tmp.innerHTML = wrap[1] + elem.replace( rxhtmlTag, "<$1></$2>" ) + wrap[2];

                    // Descend through wrappers to the right content
                    j = wrap[0];
                    while ( j-- ) {
                        tmp = tmp.lastChild;
                    }

                    // Manually add leading whitespace removed by IE
                    if ( !support.leadingWhitespace && rleadingWhitespace.test( elem ) ) {
                        nodes.push( context.createTextNode( rleadingWhitespace.exec( elem )[0] ) );
                    }

                    // Remove IE's autoinserted <tbody> from table fragments
                    if ( !support.tbody ) {

                        // String was a <table>, *may* have spurious <tbody>
                        elem = tag === "table" && !rtbody.test( elem ) ?
                            tmp.firstChild :

                            // String was a bare <thead> or <tfoot>
                            wrap[1] === "<table>" && !rtbody.test( elem ) ?
                                tmp :
                                0;

                        j = elem && elem.childNodes.length;
                        while ( j-- ) {
                            if ( jQuery.nodeName( (tbody = elem.childNodes[j]), "tbody" ) && !tbody.childNodes.length ) {
                                elem.removeChild( tbody );
                            }
                        }
                    }

                    jQuery.merge( nodes, tmp.childNodes );

                    // Fix #12392 for WebKit and IE > 9
                    tmp.textContent = "";

                    // Fix #12392 for oldIE
                    while ( tmp.firstChild ) {
                        tmp.removeChild( tmp.firstChild );
                    }

                    // Remember the top-level container for proper cleanup
                    tmp = safe.lastChild;
                }
            }
        }

        // Fix #11356: Clear elements from fragment
        if ( tmp ) {
            safe.removeChild( tmp );
        }

        // Reset defaultChecked for any radios and checkboxes
        // about to be appended to the DOM in IE 6/7 (#8060)
        if ( !support.appendChecked ) {
            jQuery.grep( getAll( nodes, "input" ), fixDefaultChecked );
        }

        i = 0;
        while ( (elem = nodes[ i++ ]) ) {

            // #4087 - If origin and destination elements are the same, and this is
            // that element, do not do anything
            if ( selection && jQuery.inArray( elem, selection ) !== -1 ) {
                continue;
            }

            contains = jQuery.contains( elem.ownerDocument, elem );

            // Append to fragment
            tmp = getAll( safe.appendChild( elem ), "script" );

            // Preserve script evaluation history
            if ( contains ) {
                setGlobalEval( tmp );
            }

            // Capture executables
            if ( scripts ) {
                j = 0;
                while ( (elem = tmp[ j++ ]) ) {
                    if ( rscriptType.test( elem.type || "" ) ) {
                        scripts.push( elem );
                    }
                }
            }
        }

        tmp = null;

        return safe;
    },

    cleanData: function( elems, /* internal */ acceptData ) {
        var elem, type, id, data,
            i = 0,
            internalKey = jQuery.expando,
            cache = jQuery.cache,
            deleteExpando = support.deleteExpando,
            special = jQuery.event.special;

        for ( ; (elem = elems[i]) != null; i++ ) {
            if ( acceptData || jQuery.acceptData( elem ) ) {

                id = elem[ internalKey ];
                data = id && cache[ id ];

                if ( data ) {
                    if ( data.events ) {
                        for ( type in data.events ) {
                            if ( special[ type ] ) {
                                jQuery.event.remove( elem, type );

                            // This is a shortcut to avoid jQuery.event.remove's overhead
                            } else {
                                jQuery.removeEvent( elem, type, data.handle );
                            }
                        }
                    }

                    // Remove cache only if it was not already removed by jQuery.event.remove
                    if ( cache[ id ] ) {

                        delete cache[ id ];

                        // IE does not allow us to delete expando properties from nodes,
                        // nor does it have a removeAttribute function on Document nodes;
                        // we must handle all of these cases
                        if ( deleteExpando ) {
                            delete elem[ internalKey ];

                        } else if ( typeof elem.removeAttribute !== strundefined ) {
                            elem.removeAttribute( internalKey );

                        } else {
                            elem[ internalKey ] = null;
                        }

                        deletedIds.push( id );
                    }
                }
            }
        }
    }
});

jQuery.fn.extend({
    text: function( value ) {
        return access( this, function( value ) {
            return value === undefined ?
                jQuery.text( this ) :
                this.empty().append( ( this[0] && this[0].ownerDocument || document ).createTextNode( value ) );
        }, null, value, arguments.length );
    },

    append: function() {
        return this.domManip( arguments, function( elem ) {
            if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
                var target = manipulationTarget( this, elem );
                target.appendChild( elem );
            }
        });
    },

    prepend: function() {
        return this.domManip( arguments, function( elem ) {
            if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
                var target = manipulationTarget( this, elem );
                target.insertBefore( elem, target.firstChild );
            }
        });
    },

    before: function() {
        return this.domManip( arguments, function( elem ) {
            if ( this.parentNode ) {
                this.parentNode.insertBefore( elem, this );
            }
        });
    },

    after: function() {
        return this.domManip( arguments, function( elem ) {
            if ( this.parentNode ) {
                this.parentNode.insertBefore( elem, this.nextSibling );
            }
        });
    },

    remove: function( selector, keepData /* Internal Use Only */ ) {
        var elem,
            elems = selector ? jQuery.filter( selector, this ) : this,
            i = 0;

        for ( ; (elem = elems[i]) != null; i++ ) {

            if ( !keepData && elem.nodeType === 1 ) {
                jQuery.cleanData( getAll( elem ) );
            }

            if ( elem.parentNode ) {
                if ( keepData && jQuery.contains( elem.ownerDocument, elem ) ) {
                    setGlobalEval( getAll( elem, "script" ) );
                }
                elem.parentNode.removeChild( elem );
            }
        }

        return this;
    },

    empty: function() {
        var elem,
            i = 0;

        for ( ; (elem = this[i]) != null; i++ ) {
            // Remove element nodes and prevent memory leaks
            if ( elem.nodeType === 1 ) {
                jQuery.cleanData( getAll( elem, false ) );
            }

            // Remove any remaining nodes
            while ( elem.firstChild ) {
                elem.removeChild( elem.firstChild );
            }

            // If this is a select, ensure that it displays empty (#12336)
            // Support: IE<9
            if ( elem.options && jQuery.nodeName( elem, "select" ) ) {
                elem.options.length = 0;
            }
        }

        return this;
    },

    clone: function( dataAndEvents, deepDataAndEvents ) {
        dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
        deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

        return this.map(function() {
            return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
        });
    },

    html: function( value ) {
        return access( this, function( value ) {
            var elem = this[ 0 ] || {},
                i = 0,
                l = this.length;

            if ( value === undefined ) {
                return elem.nodeType === 1 ?
                    elem.innerHTML.replace( rinlinejQuery, "" ) :
                    undefined;
            }

            // See if we can take a shortcut and just use innerHTML
            if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
                ( support.htmlSerialize || !rnoshimcache.test( value )  ) &&
                ( support.leadingWhitespace || !rleadingWhitespace.test( value ) ) &&
                !wrapMap[ (rtagName.exec( value ) || [ "", "" ])[ 1 ].toLowerCase() ] ) {

                value = value.replace( rxhtmlTag, "<$1></$2>" );

                try {
                    for (; i < l; i++ ) {
                        // Remove element nodes and prevent memory leaks
                        elem = this[i] || {};
                        if ( elem.nodeType === 1 ) {
                            jQuery.cleanData( getAll( elem, false ) );
                            elem.innerHTML = value;
                        }
                    }

                    elem = 0;

                // If using innerHTML throws an exception, use the fallback method
                } catch(e) {}
            }

            if ( elem ) {
                this.empty().append( value );
            }
        }, null, value, arguments.length );
    },

    replaceWith: function() {
        var arg = arguments[ 0 ];

        // Make the changes, replacing each context element with the new content
        this.domManip( arguments, function( elem ) {
            arg = this.parentNode;

            jQuery.cleanData( getAll( this ) );

            if ( arg ) {
                arg.replaceChild( elem, this );
            }
        });

        // Force removal if there was no new content (e.g., from empty arguments)
        return arg && (arg.length || arg.nodeType) ? this : this.remove();
    },

    detach: function( selector ) {
        return this.remove( selector, true );
    },

    domManip: function( args, callback ) {

        // Flatten any nested arrays
        args = concat.apply( [], args );

        var first, node, hasScripts,
            scripts, doc, fragment,
            i = 0,
            l = this.length,
            set = this,
            iNoClone = l - 1,
            value = args[0],
            isFunction = jQuery.isFunction( value );

        // We can't cloneNode fragments that contain checked, in WebKit
        if ( isFunction ||
                ( l > 1 && typeof value === "string" &&
                    !support.checkClone && rchecked.test( value ) ) ) {
            return this.each(function( index ) {
                var self = set.eq( index );
                if ( isFunction ) {
                    args[0] = value.call( this, index, self.html() );
                }
                self.domManip( args, callback );
            });
        }

        if ( l ) {
            fragment = jQuery.buildFragment( args, this[ 0 ].ownerDocument, false, this );
            first = fragment.firstChild;

            if ( fragment.childNodes.length === 1 ) {
                fragment = first;
            }

            if ( first ) {
                scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
                hasScripts = scripts.length;

                // Use the original fragment for the last item instead of the first because it can end up
                // being emptied incorrectly in certain situations (#8070).
                for ( ; i < l; i++ ) {
                    node = fragment;

                    if ( i !== iNoClone ) {
                        node = jQuery.clone( node, true, true );

                        // Keep references to cloned scripts for later restoration
                        if ( hasScripts ) {
                            jQuery.merge( scripts, getAll( node, "script" ) );
                        }
                    }

                    callback.call( this[i], node, i );
                }

                if ( hasScripts ) {
                    doc = scripts[ scripts.length - 1 ].ownerDocument;

                    // Reenable scripts
                    jQuery.map( scripts, restoreScript );

                    // Evaluate executable scripts on first document insertion
                    for ( i = 0; i < hasScripts; i++ ) {
                        node = scripts[ i ];
                        if ( rscriptType.test( node.type || "" ) &&
                            !jQuery._data( node, "globalEval" ) && jQuery.contains( doc, node ) ) {

                            if ( node.src ) {
                                // Optional AJAX dependency, but won't run scripts if not present
                                if ( jQuery._evalUrl ) {
                                    jQuery._evalUrl( node.src );
                                }
                            } else {
                                jQuery.globalEval( ( node.text || node.textContent || node.innerHTML || "" ).replace( rcleanScript, "" ) );
                            }
                        }
                    }
                }

                // Fix #11809: Avoid leaking memory
                fragment = first = null;
            }
        }

        return this;
    }
});

jQuery.each({
    appendTo: "append",
    prependTo: "prepend",
    insertBefore: "before",
    insertAfter: "after",
    replaceAll: "replaceWith"
}, function( name, original ) {
    jQuery.fn[ name ] = function( selector ) {
        var elems,
            i = 0,
            ret = [],
            insert = jQuery( selector ),
            last = insert.length - 1;

        for ( ; i <= last; i++ ) {
            elems = i === last ? this : this.clone(true);
            jQuery( insert[i] )[ original ]( elems );

            // Modern browsers can apply jQuery collections as arrays, but oldIE needs a .get()
            push.apply( ret, elems.get() );
        }

        return this.pushStack( ret );
    };
});


var iframe,
    elemdisplay = {};

/**
 * Retrieve the actual display of a element
 * @param {String} name nodeName of the element
 * @param {Object} doc Document object
 */
// Called only from within defaultDisplay
function actualDisplay( name, doc ) {
    var style,
        elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),

        // getDefaultComputedStyle might be reliably used only on attached element
        display = window.getDefaultComputedStyle && ( style = window.getDefaultComputedStyle( elem[ 0 ] ) ) ?

            // Use of this method is a temporary fix (more like optmization) until something better comes along,
            // since it was removed from specification and supported only in FF
            style.display : jQuery.css( elem[ 0 ], "display" );

    // We don't have any data stored on the element,
    // so use "detach" method as fast way to get rid of the element
    elem.detach();

    return display;
}

/**
 * Try to determine the default display value of an element
 * @param {String} nodeName
 */
function defaultDisplay( nodeName ) {
    var doc = document,
        display = elemdisplay[ nodeName ];

    if ( !display ) {
        display = actualDisplay( nodeName, doc );

        // If the simple way fails, read from inside an iframe
        if ( display === "none" || !display ) {

            // Use the already-created iframe if possible
            iframe = (iframe || jQuery( "<iframe frameborder='0' width='0' height='0'/>" )).appendTo( doc.documentElement );

            // Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
            doc = ( iframe[ 0 ].contentWindow || iframe[ 0 ].contentDocument ).document;

            // Support: IE
            doc.write();
            doc.close();

            display = actualDisplay( nodeName, doc );
            iframe.detach();
        }

        // Store the correct default display
        elemdisplay[ nodeName ] = display;
    }

    return display;
}


(function() {
    var shrinkWrapBlocksVal;

    support.shrinkWrapBlocks = function() {
        if ( shrinkWrapBlocksVal != null ) {
            return shrinkWrapBlocksVal;
        }

        // Will be changed later if needed.
        shrinkWrapBlocksVal = false;

        // Minified: var b,c,d
        var div, body, container;

        body = document.getElementsByTagName( "body" )[ 0 ];
        if ( !body || !body.style ) {
            // Test fired too early or in an unsupported environment, exit.
            return;
        }

        // Setup
        div = document.createElement( "div" );
        container = document.createElement( "div" );
        container.style.cssText = "position:absolute;border:0;width:0;height:0;top:0;left:-9999px";
        body.appendChild( container ).appendChild( div );

        // Support: IE6
        // Check if elements with layout shrink-wrap their children
        if ( typeof div.style.zoom !== strundefined ) {
            // Reset CSS: box-sizing; display; margin; border
            div.style.cssText =
                // Support: Firefox<29, Android 2.3
                // Vendor-prefix box-sizing
                "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;" +
                "box-sizing:content-box;display:block;margin:0;border:0;" +
                "padding:1px;width:1px;zoom:1";
            div.appendChild( document.createElement( "div" ) ).style.width = "5px";
            shrinkWrapBlocksVal = div.offsetWidth !== 3;
        }

        body.removeChild( container );

        return shrinkWrapBlocksVal;
    };

})();
var rmargin = (/^margin/);

var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );



var getStyles, curCSS,
    rposition = /^(top|right|bottom|left)$/;

if ( window.getComputedStyle ) {
    getStyles = function( elem ) {
        return elem.ownerDocument.defaultView.getComputedStyle( elem, null );
    };

    curCSS = function( elem, name, computed ) {
        var width, minWidth, maxWidth, ret,
            style = elem.style;

        computed = computed || getStyles( elem );

        // getPropertyValue is only needed for .css('filter') in IE9, see #12537
        ret = computed ? computed.getPropertyValue( name ) || computed[ name ] : undefined;

        if ( computed ) {

            if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
                ret = jQuery.style( elem, name );
            }

            // A tribute to the "awesome hack by Dean Edwards"
            // Chrome < 17 and Safari 5.0 uses "computed value" instead of "used value" for margin-right
            // Safari 5.1.7 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels
            // this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
            if ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {

                // Remember the original values
                width = style.width;
                minWidth = style.minWidth;
                maxWidth = style.maxWidth;

                // Put in the new values to get a computed value out
                style.minWidth = style.maxWidth = style.width = ret;
                ret = computed.width;

                // Revert the changed values
                style.width = width;
                style.minWidth = minWidth;
                style.maxWidth = maxWidth;
            }
        }

        // Support: IE
        // IE returns zIndex value as an integer.
        return ret === undefined ?
            ret :
            ret + "";
    };
} else if ( document.documentElement.currentStyle ) {
    getStyles = function( elem ) {
        return elem.currentStyle;
    };

    curCSS = function( elem, name, computed ) {
        var left, rs, rsLeft, ret,
            style = elem.style;

        computed = computed || getStyles( elem );
        ret = computed ? computed[ name ] : undefined;

        // Avoid setting ret to empty string here
        // so we don't default to auto
        if ( ret == null && style && style[ name ] ) {
            ret = style[ name ];
        }

        // From the awesome hack by Dean Edwards
        // http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291

        // If we're not dealing with a regular pixel number
        // but a number that has a weird ending, we need to convert it to pixels
        // but not position css attributes, as those are proportional to the parent element instead
        // and we can't measure the parent instead because it might trigger a "stacking dolls" problem
        if ( rnumnonpx.test( ret ) && !rposition.test( name ) ) {

            // Remember the original values
            left = style.left;
            rs = elem.runtimeStyle;
            rsLeft = rs && rs.left;

            // Put in the new values to get a computed value out
            if ( rsLeft ) {
                rs.left = elem.currentStyle.left;
            }
            style.left = name === "fontSize" ? "1em" : ret;
            ret = style.pixelLeft + "px";

            // Revert the changed values
            style.left = left;
            if ( rsLeft ) {
                rs.left = rsLeft;
            }
        }

        // Support: IE
        // IE returns zIndex value as an integer.
        return ret === undefined ?
            ret :
            ret + "" || "auto";
    };
}




function addGetHookIf( conditionFn, hookFn ) {
    // Define the hook, we'll check on the first run if it's really needed.
    return {
        get: function() {
            var condition = conditionFn();

            if ( condition == null ) {
                // The test was not ready at this point; screw the hook this time
                // but check again when needed next time.
                return;
            }

            if ( condition ) {
                // Hook not needed (or it's not possible to use it due to missing dependency),
                // remove it.
                // Since there are no other hooks for marginRight, remove the whole object.
                delete this.get;
                return;
            }

            // Hook needed; redefine it so that the support test is not executed again.

            return (this.get = hookFn).apply( this, arguments );
        }
    };
}


(function() {
    // Minified: var b,c,d,e,f,g, h,i
    var div, style, a, pixelPositionVal, boxSizingReliableVal,
        reliableHiddenOffsetsVal, reliableMarginRightVal;

    // Setup
    div = document.createElement( "div" );
    div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";
    a = div.getElementsByTagName( "a" )[ 0 ];
    style = a && a.style;

    // Finish early in limited (non-browser) environments
    if ( !style ) {
        return;
    }

    style.cssText = "float:left;opacity:.5";

    // Support: IE<9
    // Make sure that element opacity exists (as opposed to filter)
    support.opacity = style.opacity === "0.5";

    // Verify style float existence
    // (IE uses styleFloat instead of cssFloat)
    support.cssFloat = !!style.cssFloat;

    div.style.backgroundClip = "content-box";
    div.cloneNode( true ).style.backgroundClip = "";
    support.clearCloneStyle = div.style.backgroundClip === "content-box";

    // Support: Firefox<29, Android 2.3
    // Vendor-prefix box-sizing
    support.boxSizing = style.boxSizing === "" || style.MozBoxSizing === "" ||
        style.WebkitBoxSizing === "";

    jQuery.extend(support, {
        reliableHiddenOffsets: function() {
            if ( reliableHiddenOffsetsVal == null ) {
                computeStyleTests();
            }
            return reliableHiddenOffsetsVal;
        },

        boxSizingReliable: function() {
            if ( boxSizingReliableVal == null ) {
                computeStyleTests();
            }
            return boxSizingReliableVal;
        },

        pixelPosition: function() {
            if ( pixelPositionVal == null ) {
                computeStyleTests();
            }
            return pixelPositionVal;
        },

        // Support: Android 2.3
        reliableMarginRight: function() {
            if ( reliableMarginRightVal == null ) {
                computeStyleTests();
            }
            return reliableMarginRightVal;
        }
    });

    function computeStyleTests() {
        // Minified: var b,c,d,j
        var div, body, container, contents;

        body = document.getElementsByTagName( "body" )[ 0 ];
        if ( !body || !body.style ) {
            // Test fired too early or in an unsupported environment, exit.
            return;
        }

        // Setup
        div = document.createElement( "div" );
        container = document.createElement( "div" );
        container.style.cssText = "position:absolute;border:0;width:0;height:0;top:0;left:-9999px";
        body.appendChild( container ).appendChild( div );

        div.style.cssText =
            // Support: Firefox<29, Android 2.3
            // Vendor-prefix box-sizing
            "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;" +
            "box-sizing:border-box;display:block;margin-top:1%;top:1%;" +
            "border:1px;padding:1px;width:4px;position:absolute";

        // Support: IE<9
        // Assume reasonable values in the absence of getComputedStyle
        pixelPositionVal = boxSizingReliableVal = false;
        reliableMarginRightVal = true;

        // Check for getComputedStyle so that this code is not run in IE<9.
        if ( window.getComputedStyle ) {
            pixelPositionVal = ( window.getComputedStyle( div, null ) || {} ).top !== "1%";
            boxSizingReliableVal =
                ( window.getComputedStyle( div, null ) || { width: "4px" } ).width === "4px";

            // Support: Android 2.3
            // Div with explicit width and no margin-right incorrectly
            // gets computed margin-right based on width of container (#3333)
            // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
            contents = div.appendChild( document.createElement( "div" ) );

            // Reset CSS: box-sizing; display; margin; border; padding
            contents.style.cssText = div.style.cssText =
                // Support: Firefox<29, Android 2.3
                // Vendor-prefix box-sizing
                "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;" +
                "box-sizing:content-box;display:block;margin:0;border:0;padding:0";
            contents.style.marginRight = contents.style.width = "0";
            div.style.width = "1px";

            reliableMarginRightVal =
                !parseFloat( ( window.getComputedStyle( contents, null ) || {} ).marginRight );
        }

        // Support: IE8
        // Check if table cells still have offsetWidth/Height when they are set
        // to display:none and there are still other visible table cells in a
        // table row; if so, offsetWidth/Height are not reliable for use when
        // determining if an element has been hidden directly using
        // display:none (it is still safe to use offsets if a parent element is
        // hidden; don safety goggles and see bug #4512 for more information).
        div.innerHTML = "<table><tr><td></td><td>t</td></tr></table>";
        contents = div.getElementsByTagName( "td" );
        contents[ 0 ].style.cssText = "margin:0;border:0;padding:0;display:none";
        reliableHiddenOffsetsVal = contents[ 0 ].offsetHeight === 0;
        if ( reliableHiddenOffsetsVal ) {
            contents[ 0 ].style.display = "";
            contents[ 1 ].style.display = "none";
            reliableHiddenOffsetsVal = contents[ 0 ].offsetHeight === 0;
        }

        body.removeChild( container );
    }

})();


// A method for quickly swapping in/out CSS properties to get correct calculations.
jQuery.swap = function( elem, options, callback, args ) {
    var ret, name,
        old = {};

    // Remember the old values, and insert the new ones
    for ( name in options ) {
        old[ name ] = elem.style[ name ];
        elem.style[ name ] = options[ name ];
    }

    ret = callback.apply( elem, args || [] );

    // Revert the old values
    for ( name in options ) {
        elem.style[ name ] = old[ name ];
    }

    return ret;
};


var
        ralpha = /alpha\([^)]*\)/i,
    ropacity = /opacity\s*=\s*([^)]*)/,

    // swappable if display is none or starts with table except "table", "table-cell", or "table-caption"
    // see here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
    rdisplayswap = /^(none|table(?!-c[ea]).+)/,
    rnumsplit = new RegExp( "^(" + pnum + ")(.*)$", "i" ),
    rrelNum = new RegExp( "^([+-])=(" + pnum + ")", "i" ),

    cssShow = { position: "absolute", visibility: "hidden", display: "block" },
    cssNormalTransform = {
        letterSpacing: "0",
        fontWeight: "400"
    },

    cssPrefixes = [ "Webkit", "O", "Moz", "ms" ];


// return a css property mapped to a potentially vendor prefixed property
function vendorPropName( style, name ) {

    // shortcut for names that are not vendor prefixed
    if ( name in style ) {
        return name;
    }

    // check for vendor prefixed names
    var capName = name.charAt(0).toUpperCase() + name.slice(1),
        origName = name,
        i = cssPrefixes.length;

    while ( i-- ) {
        name = cssPrefixes[ i ] + capName;
        if ( name in style ) {
            return name;
        }
    }

    return origName;
}

function showHide( elements, show ) {
    var display, elem, hidden,
        values = [],
        index = 0,
        length = elements.length;

    for ( ; index < length; index++ ) {
        elem = elements[ index ];
        if ( !elem.style ) {
            continue;
        }

        values[ index ] = jQuery._data( elem, "olddisplay" );
        display = elem.style.display;
        if ( show ) {
            // Reset the inline display of this element to learn if it is
            // being hidden by cascaded rules or not
            if ( !values[ index ] && display === "none" ) {
                elem.style.display = "";
            }

            // Set elements which have been overridden with display: none
            // in a stylesheet to whatever the default browser style is
            // for such an element
            if ( elem.style.display === "" && isHidden( elem ) ) {
                values[ index ] = jQuery._data( elem, "olddisplay", defaultDisplay(elem.nodeName) );
            }
        } else {
            hidden = isHidden( elem );

            if ( display && display !== "none" || !hidden ) {
                jQuery._data( elem, "olddisplay", hidden ? display : jQuery.css( elem, "display" ) );
            }
        }
    }

    // Set the display of most of the elements in a second loop
    // to avoid the constant reflow
    for ( index = 0; index < length; index++ ) {
        elem = elements[ index ];
        if ( !elem.style ) {
            continue;
        }
        if ( !show || elem.style.display === "none" || elem.style.display === "" ) {
            elem.style.display = show ? values[ index ] || "" : "none";
        }
    }

    return elements;
}

function setPositiveNumber( elem, value, subtract ) {
    var matches = rnumsplit.exec( value );
    return matches ?
        // Guard against undefined "subtract", e.g., when used as in cssHooks
        Math.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || "px" ) :
        value;
}

function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
    var i = extra === ( isBorderBox ? "border" : "content" ) ?
        // If we already have the right measurement, avoid augmentation
        4 :
        // Otherwise initialize for horizontal or vertical properties
        name === "width" ? 1 : 0,

        val = 0;

    for ( ; i < 4; i += 2 ) {
        // both box models exclude margin, so add it if we want it
        if ( extra === "margin" ) {
            val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
        }

        if ( isBorderBox ) {
            // border-box includes padding, so remove it if we want content
            if ( extra === "content" ) {
                val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
            }

            // at this point, extra isn't border nor margin, so remove border
            if ( extra !== "margin" ) {
                val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
            }
        } else {
            // at this point, extra isn't content, so add padding
            val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

            // at this point, extra isn't content nor padding, so add border
            if ( extra !== "padding" ) {
                val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
            }
        }
    }

    return val;
}

function getWidthOrHeight( elem, name, extra ) {

    // Start with offset property, which is equivalent to the border-box value
    var valueIsBorderBox = true,
        val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
        styles = getStyles( elem ),
        isBorderBox = support.boxSizing && jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

    // some non-html elements return undefined for offsetWidth, so check for null/undefined
    // svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
    // MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
    if ( val <= 0 || val == null ) {
        // Fall back to computed then uncomputed css if necessary
        val = curCSS( elem, name, styles );
        if ( val < 0 || val == null ) {
            val = elem.style[ name ];
        }

        // Computed unit is not pixels. Stop here and return.
        if ( rnumnonpx.test(val) ) {
            return val;
        }

        // we need the check for style in case a browser which returns unreliable values
        // for getComputedStyle silently falls back to the reliable elem.style
        valueIsBorderBox = isBorderBox && ( support.boxSizingReliable() || val === elem.style[ name ] );

        // Normalize "", auto, and prepare for extra
        val = parseFloat( val ) || 0;
    }

    // use the active box-sizing model to add/subtract irrelevant styles
    return ( val +
        augmentWidthOrHeight(
            elem,
            name,
            extra || ( isBorderBox ? "border" : "content" ),
            valueIsBorderBox,
            styles
        )
    ) + "px";
}

jQuery.extend({
    // Add in style property hooks for overriding the default
    // behavior of getting and setting a style property
    cssHooks: {
        opacity: {
            get: function( elem, computed ) {
                if ( computed ) {
                    // We should always get a number back from opacity
                    var ret = curCSS( elem, "opacity" );
                    return ret === "" ? "1" : ret;
                }
            }
        }
    },

    // Don't automatically add "px" to these possibly-unitless properties
    cssNumber: {
        "columnCount": true,
        "fillOpacity": true,
        "flexGrow": true,
        "flexShrink": true,
        "fontWeight": true,
        "lineHeight": true,
        "opacity": true,
        "order": true,
        "orphans": true,
        "widows": true,
        "zIndex": true,
        "zoom": true
    },

    // Add in properties whose names you wish to fix before
    // setting or getting the value
    cssProps: {
        // normalize float css property
        "float": support.cssFloat ? "cssFloat" : "styleFloat"
    },

    // Get and set the style property on a DOM Node
    style: function( elem, name, value, extra ) {
        // Don't set styles on text and comment nodes
        if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
            return;
        }

        // Make sure that we're working with the right name
        var ret, type, hooks,
            origName = jQuery.camelCase( name ),
            style = elem.style;

        name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );

        // gets hook for the prefixed version
        // followed by the unprefixed version
        hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

        // Check if we're setting a value
        if ( value !== undefined ) {
            type = typeof value;

            // convert relative number strings (+= or -=) to relative numbers. #7345
            if ( type === "string" && (ret = rrelNum.exec( value )) ) {
                value = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );
                // Fixes bug #9237
                type = "number";
            }

            // Make sure that null and NaN values aren't set. See: #7116
            if ( value == null || value !== value ) {
                return;
            }

            // If a number was passed in, add 'px' to the (except for certain CSS properties)
            if ( type === "number" && !jQuery.cssNumber[ origName ] ) {
                value += "px";
            }

            // Fixes #8908, it can be done more correctly by specifing setters in cssHooks,
            // but it would mean to define eight (for every problematic property) identical functions
            if ( !support.clearCloneStyle && value === "" && name.indexOf("background") === 0 ) {
                style[ name ] = "inherit";
            }

            // If a hook was provided, use that value, otherwise just set the specified value
            if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {

                // Support: IE
                // Swallow errors from 'invalid' CSS values (#5509)
                try {
                    style[ name ] = value;
                } catch(e) {}
            }

        } else {
            // If a hook was provided get the non-computed value from there
            if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {
                return ret;
            }

            // Otherwise just get the value from the style object
            return style[ name ];
        }
    },

    css: function( elem, name, extra, styles ) {
        var num, val, hooks,
            origName = jQuery.camelCase( name );

        // Make sure that we're working with the right name
        name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );

        // gets hook for the prefixed version
        // followed by the unprefixed version
        hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

        // If a hook was provided get the computed value from there
        if ( hooks && "get" in hooks ) {
            val = hooks.get( elem, true, extra );
        }

        // Otherwise, if a way to get the computed value exists, use that
        if ( val === undefined ) {
            val = curCSS( elem, name, styles );
        }

        //convert "normal" to computed value
        if ( val === "normal" && name in cssNormalTransform ) {
            val = cssNormalTransform[ name ];
        }

        // Return, converting to number if forced or a qualifier was provided and val looks numeric
        if ( extra === "" || extra ) {
            num = parseFloat( val );
            return extra === true || jQuery.isNumeric( num ) ? num || 0 : val;
        }
        return val;
    }
});

jQuery.each([ "height", "width" ], function( i, name ) {
    jQuery.cssHooks[ name ] = {
        get: function( elem, computed, extra ) {
            if ( computed ) {
                // certain elements can have dimension info if we invisibly show them
                // however, it must have a current display style that would benefit from this
                return rdisplayswap.test( jQuery.css( elem, "display" ) ) && elem.offsetWidth === 0 ?
                    jQuery.swap( elem, cssShow, function() {
                        return getWidthOrHeight( elem, name, extra );
                    }) :
                    getWidthOrHeight( elem, name, extra );
            }
        },

        set: function( elem, value, extra ) {
            var styles = extra && getStyles( elem );
            return setPositiveNumber( elem, value, extra ?
                augmentWidthOrHeight(
                    elem,
                    name,
                    extra,
                    support.boxSizing && jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
                    styles
                ) : 0
            );
        }
    };
});

if ( !support.opacity ) {
    jQuery.cssHooks.opacity = {
        get: function( elem, computed ) {
            // IE uses filters for opacity
            return ropacity.test( (computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || "" ) ?
                ( 0.01 * parseFloat( RegExp.$1 ) ) + "" :
                computed ? "1" : "";
        },

        set: function( elem, value ) {
            var style = elem.style,
                currentStyle = elem.currentStyle,
                opacity = jQuery.isNumeric( value ) ? "alpha(opacity=" + value * 100 + ")" : "",
                filter = currentStyle && currentStyle.filter || style.filter || "";

            // IE has trouble with opacity if it does not have layout
            // Force it by setting the zoom level
            style.zoom = 1;

            // if setting opacity to 1, and no other filters exist - attempt to remove filter attribute #6652
            // if value === "", then remove inline opacity #12685
            if ( ( value >= 1 || value === "" ) &&
                    jQuery.trim( filter.replace( ralpha, "" ) ) === "" &&
                    style.removeAttribute ) {

                // Setting style.filter to null, "" & " " still leave "filter:" in the cssText
                // if "filter:" is present at all, clearType is disabled, we want to avoid this
                // style.removeAttribute is IE Only, but so apparently is this code path...
                style.removeAttribute( "filter" );

                // if there is no filter style applied in a css rule or unset inline opacity, we are done
                if ( value === "" || currentStyle && !currentStyle.filter ) {
                    return;
                }
            }

            // otherwise, set new filter values
            style.filter = ralpha.test( filter ) ?
                filter.replace( ralpha, opacity ) :
                filter + " " + opacity;
        }
    };
}

jQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,
    function( elem, computed ) {
        if ( computed ) {
            // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
            // Work around by temporarily setting element display to inline-block
            return jQuery.swap( elem, { "display": "inline-block" },
                curCSS, [ elem, "marginRight" ] );
        }
    }
);

// These hooks are used by animate to expand properties
jQuery.each({
    margin: "",
    padding: "",
    border: "Width"
}, function( prefix, suffix ) {
    jQuery.cssHooks[ prefix + suffix ] = {
        expand: function( value ) {
            var i = 0,
                expanded = {},

                // assumes a single number if not a string
                parts = typeof value === "string" ? value.split(" ") : [ value ];

            for ( ; i < 4; i++ ) {
                expanded[ prefix + cssExpand[ i ] + suffix ] =
                    parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
            }

            return expanded;
        }
    };

    if ( !rmargin.test( prefix ) ) {
        jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
    }
});

jQuery.fn.extend({
    css: function( name, value ) {
        return access( this, function( elem, name, value ) {
            var styles, len,
                map = {},
                i = 0;

            if ( jQuery.isArray( name ) ) {
                styles = getStyles( elem );
                len = name.length;

                for ( ; i < len; i++ ) {
                    map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
                }

                return map;
            }

            return value !== undefined ?
                jQuery.style( elem, name, value ) :
                jQuery.css( elem, name );
        }, name, value, arguments.length > 1 );
    },
    show: function() {
        return showHide( this, true );
    },
    hide: function() {
        return showHide( this );
    },
    toggle: function( state ) {
        if ( typeof state === "boolean" ) {
            return state ? this.show() : this.hide();
        }

        return this.each(function() {
            if ( isHidden( this ) ) {
                jQuery( this ).show();
            } else {
                jQuery( this ).hide();
            }
        });
    }
});


function Tween( elem, options, prop, end, easing ) {
    return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
    constructor: Tween,
    init: function( elem, options, prop, end, easing, unit ) {
        this.elem = elem;
        this.prop = prop;
        this.easing = easing || "swing";
        this.options = options;
        this.start = this.now = this.cur();
        this.end = end;
        this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
    },
    cur: function() {
        var hooks = Tween.propHooks[ this.prop ];

        return hooks && hooks.get ?
            hooks.get( this ) :
            Tween.propHooks._default.get( this );
    },
    run: function( percent ) {
        var eased,
            hooks = Tween.propHooks[ this.prop ];

        if ( this.options.duration ) {
            this.pos = eased = jQuery.easing[ this.easing ](
                percent, this.options.duration * percent, 0, 1, this.options.duration
            );
        } else {
            this.pos = eased = percent;
        }
        this.now = ( this.end - this.start ) * eased + this.start;

        if ( this.options.step ) {
            this.options.step.call( this.elem, this.now, this );
        }

        if ( hooks && hooks.set ) {
            hooks.set( this );
        } else {
            Tween.propHooks._default.set( this );
        }
        return this;
    }
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
    _default: {
        get: function( tween ) {
            var result;

            if ( tween.elem[ tween.prop ] != null &&
                (!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {
                return tween.elem[ tween.prop ];
            }

            // passing an empty string as a 3rd parameter to .css will automatically
            // attempt a parseFloat and fallback to a string if the parse fails
            // so, simple values such as "10px" are parsed to Float.
            // complex values such as "rotate(1rad)" are returned as is.
            result = jQuery.css( tween.elem, tween.prop, "" );
            // Empty strings, null, undefined and "auto" are converted to 0.
            return !result || result === "auto" ? 0 : result;
        },
        set: function( tween ) {
            // use step hook for back compat - use cssHook if its there - use .style if its
            // available and use plain properties where available
            if ( jQuery.fx.step[ tween.prop ] ) {
                jQuery.fx.step[ tween.prop ]( tween );
            } else if ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {
                jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
            } else {
                tween.elem[ tween.prop ] = tween.now;
            }
        }
    }
};

// Support: IE <=9
// Panic based approach to setting things on disconnected nodes

Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
    set: function( tween ) {
        if ( tween.elem.nodeType && tween.elem.parentNode ) {
            tween.elem[ tween.prop ] = tween.now;
        }
    }
};

jQuery.easing = {
    linear: function( p ) {
        return p;
    },
    swing: function( p ) {
        return 0.5 - Math.cos( p * Math.PI ) / 2;
    }
};

jQuery.fx = Tween.prototype.init;

// Back Compat <1.8 extension point
jQuery.fx.step = {};




var
    fxNow, timerId,
    rfxtypes = /^(?:toggle|show|hide)$/,
    rfxnum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" ),
    rrun = /queueHooks$/,
    animationPrefilters = [ defaultPrefilter ],
    tweeners = {
        "*": [ function( prop, value ) {
            var tween = this.createTween( prop, value ),
                target = tween.cur(),
                parts = rfxnum.exec( value ),
                unit = parts && parts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

                // Starting value computation is required for potential unit mismatches
                start = ( jQuery.cssNumber[ prop ] || unit !== "px" && +target ) &&
                    rfxnum.exec( jQuery.css( tween.elem, prop ) ),
                scale = 1,
                maxIterations = 20;

            if ( start && start[ 3 ] !== unit ) {
                // Trust units reported by jQuery.css
                unit = unit || start[ 3 ];

                // Make sure we update the tween properties later on
                parts = parts || [];

                // Iteratively approximate from a nonzero starting point
                start = +target || 1;

                do {
                    // If previous iteration zeroed out, double until we get *something*
                    // Use a string for doubling factor so we don't accidentally see scale as unchanged below
                    scale = scale || ".5";

                    // Adjust and apply
                    start = start / scale;
                    jQuery.style( tween.elem, prop, start + unit );

                // Update scale, tolerating zero or NaN from tween.cur()
                // And breaking the loop if scale is unchanged or perfect, or if we've just had enough
                } while ( scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations );
            }

            // Update tween properties
            if ( parts ) {
                start = tween.start = +start || +target || 0;
                tween.unit = unit;
                // If a +=/-= token was provided, we're doing a relative animation
                tween.end = parts[ 1 ] ?
                    start + ( parts[ 1 ] + 1 ) * parts[ 2 ] :
                    +parts[ 2 ];
            }

            return tween;
        } ]
    };

// Animations created synchronously will run synchronously
function createFxNow() {
    setTimeout(function() {
        fxNow = undefined;
    });
    return ( fxNow = jQuery.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
    var which,
        attrs = { height: type },
        i = 0;

    // if we include width, step value is 1 to do all cssExpand values,
    // if we don't include width, step value is 2 to skip over Left and Right
    includeWidth = includeWidth ? 1 : 0;
    for ( ; i < 4 ; i += 2 - includeWidth ) {
        which = cssExpand[ i ];
        attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
    }

    if ( includeWidth ) {
        attrs.opacity = attrs.width = type;
    }

    return attrs;
}

function createTween( value, prop, animation ) {
    var tween,
        collection = ( tweeners[ prop ] || [] ).concat( tweeners[ "*" ] ),
        index = 0,
        length = collection.length;
    for ( ; index < length; index++ ) {
        if ( (tween = collection[ index ].call( animation, prop, value )) ) {

            // we're done with this property
            return tween;
        }
    }
}

function defaultPrefilter( elem, props, opts ) {
    /* jshint validthis: true */
    var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,
        anim = this,
        orig = {},
        style = elem.style,
        hidden = elem.nodeType && isHidden( elem ),
        dataShow = jQuery._data( elem, "fxshow" );

    // handle queue: false promises
    if ( !opts.queue ) {
        hooks = jQuery._queueHooks( elem, "fx" );
        if ( hooks.unqueued == null ) {
            hooks.unqueued = 0;
            oldfire = hooks.empty.fire;
            hooks.empty.fire = function() {
                if ( !hooks.unqueued ) {
                    oldfire();
                }
            };
        }
        hooks.unqueued++;

        anim.always(function() {
            // doing this makes sure that the complete handler will be called
            // before this completes
            anim.always(function() {
                hooks.unqueued--;
                if ( !jQuery.queue( elem, "fx" ).length ) {
                    hooks.empty.fire();
                }
            });
        });
    }

    // height/width overflow pass
    if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {
        // Make sure that nothing sneaks out
        // Record all 3 overflow attributes because IE does not
        // change the overflow attribute when overflowX and
        // overflowY are set to the same value
        opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

        // Set display property to inline-block for height/width
        // animations on inline elements that are having width/height animated
        display = jQuery.css( elem, "display" );

        // Test default display if display is currently "none"
        checkDisplay = display === "none" ?
            jQuery._data( elem, "olddisplay" ) || defaultDisplay( elem.nodeName ) : display;

        if ( checkDisplay === "inline" && jQuery.css( elem, "float" ) === "none" ) {

            // inline-level elements accept inline-block;
            // block-level elements need to be inline with layout
            if ( !support.inlineBlockNeedsLayout || defaultDisplay( elem.nodeName ) === "inline" ) {
                style.display = "inline-block";
            } else {
                style.zoom = 1;
            }
        }
    }

    if ( opts.overflow ) {
        style.overflow = "hidden";
        if ( !support.shrinkWrapBlocks() ) {
            anim.always(function() {
                style.overflow = opts.overflow[ 0 ];
                style.overflowX = opts.overflow[ 1 ];
                style.overflowY = opts.overflow[ 2 ];
            });
        }
    }

    // show/hide pass
    for ( prop in props ) {
        value = props[ prop ];
        if ( rfxtypes.exec( value ) ) {
            delete props[ prop ];
            toggle = toggle || value === "toggle";
            if ( value === ( hidden ? "hide" : "show" ) ) {

                // If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden
                if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
                    hidden = true;
                } else {
                    continue;
                }
            }
            orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );

        // Any non-fx value stops us from restoring the original display value
        } else {
            display = undefined;
        }
    }

    if ( !jQuery.isEmptyObject( orig ) ) {
        if ( dataShow ) {
            if ( "hidden" in dataShow ) {
                hidden = dataShow.hidden;
            }
        } else {
            dataShow = jQuery._data( elem, "fxshow", {} );
        }

        // store state if its toggle - enables .stop().toggle() to "reverse"
        if ( toggle ) {
            dataShow.hidden = !hidden;
        }
        if ( hidden ) {
            jQuery( elem ).show();
        } else {
            anim.done(function() {
                jQuery( elem ).hide();
            });
        }
        anim.done(function() {
            var prop;
            jQuery._removeData( elem, "fxshow" );
            for ( prop in orig ) {
                jQuery.style( elem, prop, orig[ prop ] );
            }
        });
        for ( prop in orig ) {
            tween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );

            if ( !( prop in dataShow ) ) {
                dataShow[ prop ] = tween.start;
                if ( hidden ) {
                    tween.end = tween.start;
                    tween.start = prop === "width" || prop === "height" ? 1 : 0;
                }
            }
        }

    // If this is a noop like .hide().hide(), restore an overwritten display value
    } else if ( (display === "none" ? defaultDisplay( elem.nodeName ) : display) === "inline" ) {
        style.display = display;
    }
}

function propFilter( props, specialEasing ) {
    var index, name, easing, value, hooks;

    // camelCase, specialEasing and expand cssHook pass
    for ( index in props ) {
        name = jQuery.camelCase( index );
        easing = specialEasing[ name ];
        value = props[ index ];
        if ( jQuery.isArray( value ) ) {
            easing = value[ 1 ];
            value = props[ index ] = value[ 0 ];
        }

        if ( index !== name ) {
            props[ name ] = value;
            delete props[ index ];
        }

        hooks = jQuery.cssHooks[ name ];
        if ( hooks && "expand" in hooks ) {
            value = hooks.expand( value );
            delete props[ name ];

            // not quite $.extend, this wont overwrite keys already present.
            // also - reusing 'index' from above because we have the correct "name"
            for ( index in value ) {
                if ( !( index in props ) ) {
                    props[ index ] = value[ index ];
                    specialEasing[ index ] = easing;
                }
            }
        } else {
            specialEasing[ name ] = easing;
        }
    }
}

function Animation( elem, properties, options ) {
    var result,
        stopped,
        index = 0,
        length = animationPrefilters.length,
        deferred = jQuery.Deferred().always( function() {
            // don't match elem in the :animated selector
            delete tick.elem;
        }),
        tick = function() {
            if ( stopped ) {
                return false;
            }
            var currentTime = fxNow || createFxNow(),
                remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),
                // archaic crash bug won't allow us to use 1 - ( 0.5 || 0 ) (#12497)
                temp = remaining / animation.duration || 0,
                percent = 1 - temp,
                index = 0,
                length = animation.tweens.length;

            for ( ; index < length ; index++ ) {
                animation.tweens[ index ].run( percent );
            }

            deferred.notifyWith( elem, [ animation, percent, remaining ]);

            if ( percent < 1 && length ) {
                return remaining;
            } else {
                deferred.resolveWith( elem, [ animation ] );
                return false;
            }
        },
        animation = deferred.promise({
            elem: elem,
            props: jQuery.extend( {}, properties ),
            opts: jQuery.extend( true, { specialEasing: {} }, options ),
            originalProperties: properties,
            originalOptions: options,
            startTime: fxNow || createFxNow(),
            duration: options.duration,
            tweens: [],
            createTween: function( prop, end ) {
                var tween = jQuery.Tween( elem, animation.opts, prop, end,
                        animation.opts.specialEasing[ prop ] || animation.opts.easing );
                animation.tweens.push( tween );
                return tween;
            },
            stop: function( gotoEnd ) {
                var index = 0,
                    // if we are going to the end, we want to run all the tweens
                    // otherwise we skip this part
                    length = gotoEnd ? animation.tweens.length : 0;
                if ( stopped ) {
                    return this;
                }
                stopped = true;
                for ( ; index < length ; index++ ) {
                    animation.tweens[ index ].run( 1 );
                }

                // resolve when we played the last frame
                // otherwise, reject
                if ( gotoEnd ) {
                    deferred.resolveWith( elem, [ animation, gotoEnd ] );
                } else {
                    deferred.rejectWith( elem, [ animation, gotoEnd ] );
                }
                return this;
            }
        }),
        props = animation.props;

    propFilter( props, animation.opts.specialEasing );

    for ( ; index < length ; index++ ) {
        result = animationPrefilters[ index ].call( animation, elem, props, animation.opts );
        if ( result ) {
            return result;
        }
    }

    jQuery.map( props, createTween, animation );

    if ( jQuery.isFunction( animation.opts.start ) ) {
        animation.opts.start.call( elem, animation );
    }

    jQuery.fx.timer(
        jQuery.extend( tick, {
            elem: elem,
            anim: animation,
            queue: animation.opts.queue
        })
    );

    // attach callbacks from options
    return animation.progress( animation.opts.progress )
        .done( animation.opts.done, animation.opts.complete )
        .fail( animation.opts.fail )
        .always( animation.opts.always );
}

jQuery.Animation = jQuery.extend( Animation, {
    tweener: function( props, callback ) {
        if ( jQuery.isFunction( props ) ) {
            callback = props;
            props = [ "*" ];
        } else {
            props = props.split(" ");
        }

        var prop,
            index = 0,
            length = props.length;

        for ( ; index < length ; index++ ) {
            prop = props[ index ];
            tweeners[ prop ] = tweeners[ prop ] || [];
            tweeners[ prop ].unshift( callback );
        }
    },

    prefilter: function( callback, prepend ) {
        if ( prepend ) {
            animationPrefilters.unshift( callback );
        } else {
            animationPrefilters.push( callback );
        }
    }
});

jQuery.speed = function( speed, easing, fn ) {
    var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
        complete: fn || !fn && easing ||
            jQuery.isFunction( speed ) && speed,
        duration: speed,
        easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
    };

    opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
        opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

    // normalize opt.queue - true/undefined/null -> "fx"
    if ( opt.queue == null || opt.queue === true ) {
        opt.queue = "fx";
    }

    // Queueing
    opt.old = opt.complete;

    opt.complete = function() {
        if ( jQuery.isFunction( opt.old ) ) {
            opt.old.call( this );
        }

        if ( opt.queue ) {
            jQuery.dequeue( this, opt.queue );
        }
    };

    return opt;
};

jQuery.fn.extend({
    fadeTo: function( speed, to, easing, callback ) {

        // show any hidden elements after setting opacity to 0
        return this.filter( isHidden ).css( "opacity", 0 ).show()

            // animate to the value specified
            .end().animate({ opacity: to }, speed, easing, callback );
    },
    animate: function( prop, speed, easing, callback ) {
        var empty = jQuery.isEmptyObject( prop ),
            optall = jQuery.speed( speed, easing, callback ),
            doAnimation = function() {
                // Operate on a copy of prop so per-property easing won't be lost
                var anim = Animation( this, jQuery.extend( {}, prop ), optall );

                // Empty animations, or finishing resolves immediately
                if ( empty || jQuery._data( this, "finish" ) ) {
                    anim.stop( true );
                }
            };
            doAnimation.finish = doAnimation;

        return empty || optall.queue === false ?
            this.each( doAnimation ) :
            this.queue( optall.queue, doAnimation );
    },
    stop: function( type, clearQueue, gotoEnd ) {
        var stopQueue = function( hooks ) {
            var stop = hooks.stop;
            delete hooks.stop;
            stop( gotoEnd );
        };

        if ( typeof type !== "string" ) {
            gotoEnd = clearQueue;
            clearQueue = type;
            type = undefined;
        }
        if ( clearQueue && type !== false ) {
            this.queue( type || "fx", [] );
        }

        return this.each(function() {
            var dequeue = true,
                index = type != null && type + "queueHooks",
                timers = jQuery.timers,
                data = jQuery._data( this );

            if ( index ) {
                if ( data[ index ] && data[ index ].stop ) {
                    stopQueue( data[ index ] );
                }
            } else {
                for ( index in data ) {
                    if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
                        stopQueue( data[ index ] );
                    }
                }
            }

            for ( index = timers.length; index--; ) {
                if ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {
                    timers[ index ].anim.stop( gotoEnd );
                    dequeue = false;
                    timers.splice( index, 1 );
                }
            }

            // start the next in the queue if the last step wasn't forced
            // timers currently will call their complete callbacks, which will dequeue
            // but only if they were gotoEnd
            if ( dequeue || !gotoEnd ) {
                jQuery.dequeue( this, type );
            }
        });
    },
    finish: function( type ) {
        if ( type !== false ) {
            type = type || "fx";
        }
        return this.each(function() {
            var index,
                data = jQuery._data( this ),
                queue = data[ type + "queue" ],
                hooks = data[ type + "queueHooks" ],
                timers = jQuery.timers,
                length = queue ? queue.length : 0;

            // enable finishing flag on private data
            data.finish = true;

            // empty the queue first
            jQuery.queue( this, type, [] );

            if ( hooks && hooks.stop ) {
                hooks.stop.call( this, true );
            }

            // look for any active animations, and finish them
            for ( index = timers.length; index--; ) {
                if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
                    timers[ index ].anim.stop( true );
                    timers.splice( index, 1 );
                }
            }

            // look for any animations in the old queue and finish them
            for ( index = 0; index < length; index++ ) {
                if ( queue[ index ] && queue[ index ].finish ) {
                    queue[ index ].finish.call( this );
                }
            }

            // turn off finishing flag
            delete data.finish;
        });
    }
});

jQuery.each([ "toggle", "show", "hide" ], function( i, name ) {
    var cssFn = jQuery.fn[ name ];
    jQuery.fn[ name ] = function( speed, easing, callback ) {
        return speed == null || typeof speed === "boolean" ?
            cssFn.apply( this, arguments ) :
            this.animate( genFx( name, true ), speed, easing, callback );
    };
});

// Generate shortcuts for custom animations
jQuery.each({
    slideDown: genFx("show"),
    slideUp: genFx("hide"),
    slideToggle: genFx("toggle"),
    fadeIn: { opacity: "show" },
    fadeOut: { opacity: "hide" },
    fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
    jQuery.fn[ name ] = function( speed, easing, callback ) {
        return this.animate( props, speed, easing, callback );
    };
});

jQuery.timers = [];
jQuery.fx.tick = function() {
    var timer,
        timers = jQuery.timers,
        i = 0;

    fxNow = jQuery.now();

    for ( ; i < timers.length; i++ ) {
        timer = timers[ i ];
        // Checks the timer has not already been removed
        if ( !timer() && timers[ i ] === timer ) {
            timers.splice( i--, 1 );
        }
    }

    if ( !timers.length ) {
        jQuery.fx.stop();
    }
    fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
    jQuery.timers.push( timer );
    if ( timer() ) {
        jQuery.fx.start();
    } else {
        jQuery.timers.pop();
    }
};

jQuery.fx.interval = 13;

jQuery.fx.start = function() {
    if ( !timerId ) {
        timerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );
    }
};

jQuery.fx.stop = function() {
    clearInterval( timerId );
    timerId = null;
};

jQuery.fx.speeds = {
    slow: 600,
    fast: 200,
    // Default speed
    _default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
    time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
    type = type || "fx";

    return this.queue( type, function( next, hooks ) {
        var timeout = setTimeout( next, time );
        hooks.stop = function() {
            clearTimeout( timeout );
        };
    });
};


(function() {
    // Minified: var a,b,c,d,e
    var input, div, select, a, opt;

    // Setup
    div = document.createElement( "div" );
    div.setAttribute( "className", "t" );
    div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";
    a = div.getElementsByTagName("a")[ 0 ];

    // First batch of tests.
    select = document.createElement("select");
    opt = select.appendChild( document.createElement("option") );
    input = div.getElementsByTagName("input")[ 0 ];

    a.style.cssText = "top:1px";

    // Test setAttribute on camelCase class. If it works, we need attrFixes when doing get/setAttribute (ie6/7)
    support.getSetAttribute = div.className !== "t";

    // Get the style information from getAttribute
    // (IE uses .cssText instead)
    support.style = /top/.test( a.getAttribute("style") );

    // Make sure that URLs aren't manipulated
    // (IE normalizes it by default)
    support.hrefNormalized = a.getAttribute("href") === "/a";

    // Check the default checkbox/radio value ("" on WebKit; "on" elsewhere)
    support.checkOn = !!input.value;

    // Make sure that a selected-by-default option has a working selected property.
    // (WebKit defaults to false instead of true, IE too, if it's in an optgroup)
    support.optSelected = opt.selected;

    // Tests for enctype support on a form (#6743)
    support.enctype = !!document.createElement("form").enctype;

    // Make sure that the options inside disabled selects aren't marked as disabled
    // (WebKit marks them as disabled)
    select.disabled = true;
    support.optDisabled = !opt.disabled;

    // Support: IE8 only
    // Check if we can trust getAttribute("value")
    input = document.createElement( "input" );
    input.setAttribute( "value", "" );
    support.input = input.getAttribute( "value" ) === "";

    // Check if an input maintains its value after becoming a radio
    input.value = "t";
    input.setAttribute( "type", "radio" );
    support.radioValue = input.value === "t";
})();


var rreturn = /\r/g;

jQuery.fn.extend({
    val: function( value ) {
        var hooks, ret, isFunction,
            elem = this[0];

        if ( !arguments.length ) {
            if ( elem ) {
                hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];

                if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {
                    return ret;
                }

                ret = elem.value;

                return typeof ret === "string" ?
                    // handle most common string cases
                    ret.replace(rreturn, "") :
                    // handle cases where value is null/undef or number
                    ret == null ? "" : ret;
            }

            return;
        }

        isFunction = jQuery.isFunction( value );

        return this.each(function( i ) {
            var val;

            if ( this.nodeType !== 1 ) {
                return;
            }

            if ( isFunction ) {
                val = value.call( this, i, jQuery( this ).val() );
            } else {
                val = value;
            }

            // Treat null/undefined as ""; convert numbers to string
            if ( val == null ) {
                val = "";
            } else if ( typeof val === "number" ) {
                val += "";
            } else if ( jQuery.isArray( val ) ) {
                val = jQuery.map( val, function( value ) {
                    return value == null ? "" : value + "";
                });
            }

            hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

            // If set returns undefined, fall back to normal setting
            if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {
                this.value = val;
            }
        });
    }
});

jQuery.extend({
    valHooks: {
        option: {
            get: function( elem ) {
                var val = jQuery.find.attr( elem, "value" );
                return val != null ?
                    val :
                    // Support: IE10-11+
                    // option.text throws exceptions (#14686, #14858)
                    jQuery.trim( jQuery.text( elem ) );
            }
        },
        select: {
            get: function( elem ) {
                var value, option,
                    options = elem.options,
                    index = elem.selectedIndex,
                    one = elem.type === "select-one" || index < 0,
                    values = one ? null : [],
                    max = one ? index + 1 : options.length,
                    i = index < 0 ?
                        max :
                        one ? index : 0;

                // Loop through all the selected options
                for ( ; i < max; i++ ) {
                    option = options[ i ];

                    // oldIE doesn't update selected after form reset (#2551)
                    if ( ( option.selected || i === index ) &&
                            // Don't return options that are disabled or in a disabled optgroup
                            ( support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null ) &&
                            ( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {

                        // Get the specific value for the option
                        value = jQuery( option ).val();

                        // We don't need an array for one selects
                        if ( one ) {
                            return value;
                        }

                        // Multi-Selects return an array
                        values.push( value );
                    }
                }

                return values;
            },

            set: function( elem, value ) {
                var optionSet, option,
                    options = elem.options,
                    values = jQuery.makeArray( value ),
                    i = options.length;

                while ( i-- ) {
                    option = options[ i ];

                    if ( jQuery.inArray( jQuery.valHooks.option.get( option ), values ) >= 0 ) {

                        // Support: IE6
                        // When new option element is added to select box we need to
                        // force reflow of newly added node in order to workaround delay
                        // of initialization properties
                        try {
                            option.selected = optionSet = true;

                        } catch ( _ ) {

                            // Will be executed only in IE6
                            option.scrollHeight;
                        }

                    } else {
                        option.selected = false;
                    }
                }

                // Force browsers to behave consistently when non-matching value is set
                if ( !optionSet ) {
                    elem.selectedIndex = -1;
                }

                return options;
            }
        }
    }
});

// Radios and checkboxes getter/setter
jQuery.each([ "radio", "checkbox" ], function() {
    jQuery.valHooks[ this ] = {
        set: function( elem, value ) {
            if ( jQuery.isArray( value ) ) {
                return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );
            }
        }
    };
    if ( !support.checkOn ) {
        jQuery.valHooks[ this ].get = function( elem ) {
            // Support: Webkit
            // "" is returned instead of "on" if a value isn't specified
            return elem.getAttribute("value") === null ? "on" : elem.value;
        };
    }
});




var nodeHook, boolHook,
    attrHandle = jQuery.expr.attrHandle,
    ruseDefault = /^(?:checked|selected)$/i,
    getSetAttribute = support.getSetAttribute,
    getSetInput = support.input;

jQuery.fn.extend({
    attr: function( name, value ) {
        return access( this, jQuery.attr, name, value, arguments.length > 1 );
    },

    removeAttr: function( name ) {
        return this.each(function() {
            jQuery.removeAttr( this, name );
        });
    }
});

jQuery.extend({
    attr: function( elem, name, value ) {
        var hooks, ret,
            nType = elem.nodeType;

        // don't get/set attributes on text, comment and attribute nodes
        if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
            return;
        }

        // Fallback to prop when attributes are not supported
        if ( typeof elem.getAttribute === strundefined ) {
            return jQuery.prop( elem, name, value );
        }

        // All attributes are lowercase
        // Grab necessary hook if one is defined
        if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
            name = name.toLowerCase();
            hooks = jQuery.attrHooks[ name ] ||
                ( jQuery.expr.match.bool.test( name ) ? boolHook : nodeHook );
        }

        if ( value !== undefined ) {

            if ( value === null ) {
                jQuery.removeAttr( elem, name );

            } else if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
                return ret;

            } else {
                elem.setAttribute( name, value + "" );
                return value;
            }

        } else if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {
            return ret;

        } else {
            ret = jQuery.find.attr( elem, name );

            // Non-existent attributes return null, we normalize to undefined
            return ret == null ?
                undefined :
                ret;
        }
    },

    removeAttr: function( elem, value ) {
        var name, propName,
            i = 0,
            attrNames = value && value.match( rnotwhite );

        if ( attrNames && elem.nodeType === 1 ) {
            while ( (name = attrNames[i++]) ) {
                propName = jQuery.propFix[ name ] || name;

                // Boolean attributes get special treatment (#10870)
                if ( jQuery.expr.match.bool.test( name ) ) {
                    // Set corresponding property to false
                    if ( getSetInput && getSetAttribute || !ruseDefault.test( name ) ) {
                        elem[ propName ] = false;
                    // Support: IE<9
                    // Also clear defaultChecked/defaultSelected (if appropriate)
                    } else {
                        elem[ jQuery.camelCase( "default-" + name ) ] =
                            elem[ propName ] = false;
                    }

                // See #9699 for explanation of this approach (setting first, then removal)
                } else {
                    jQuery.attr( elem, name, "" );
                }

                elem.removeAttribute( getSetAttribute ? name : propName );
            }
        }
    },

    attrHooks: {
        type: {
            set: function( elem, value ) {
                if ( !support.radioValue && value === "radio" && jQuery.nodeName(elem, "input") ) {
                    // Setting the type on a radio button after the value resets the value in IE6-9
                    // Reset value to default in case type is set after value during creation
                    var val = elem.value;
                    elem.setAttribute( "type", value );
                    if ( val ) {
                        elem.value = val;
                    }
                    return value;
                }
            }
        }
    }
});

// Hook for boolean attributes
boolHook = {
    set: function( elem, value, name ) {
        if ( value === false ) {
            // Remove boolean attributes when set to false
            jQuery.removeAttr( elem, name );
        } else if ( getSetInput && getSetAttribute || !ruseDefault.test( name ) ) {
            // IE<8 needs the *property* name
            elem.setAttribute( !getSetAttribute && jQuery.propFix[ name ] || name, name );

        // Use defaultChecked and defaultSelected for oldIE
        } else {
            elem[ jQuery.camelCase( "default-" + name ) ] = elem[ name ] = true;
        }

        return name;
    }
};

// Retrieve booleans specially
jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {

    var getter = attrHandle[ name ] || jQuery.find.attr;

    attrHandle[ name ] = getSetInput && getSetAttribute || !ruseDefault.test( name ) ?
        function( elem, name, isXML ) {
            var ret, handle;
            if ( !isXML ) {
                // Avoid an infinite loop by temporarily removing this function from the getter
                handle = attrHandle[ name ];
                attrHandle[ name ] = ret;
                ret = getter( elem, name, isXML ) != null ?
                    name.toLowerCase() :
                    null;
                attrHandle[ name ] = handle;
            }
            return ret;
        } :
        function( elem, name, isXML ) {
            if ( !isXML ) {
                return elem[ jQuery.camelCase( "default-" + name ) ] ?
                    name.toLowerCase() :
                    null;
            }
        };
});

// fix oldIE attroperties
if ( !getSetInput || !getSetAttribute ) {
    jQuery.attrHooks.value = {
        set: function( elem, value, name ) {
            if ( jQuery.nodeName( elem, "input" ) ) {
                // Does not return so that setAttribute is also used
                elem.defaultValue = value;
            } else {
                // Use nodeHook if defined (#1954); otherwise setAttribute is fine
                return nodeHook && nodeHook.set( elem, value, name );
            }
        }
    };
}

// IE6/7 do not support getting/setting some attributes with get/setAttribute
if ( !getSetAttribute ) {

    // Use this for any attribute in IE6/7
    // This fixes almost every IE6/7 issue
    nodeHook = {
        set: function( elem, value, name ) {
            // Set the existing or create a new attribute node
            var ret = elem.getAttributeNode( name );
            if ( !ret ) {
                elem.setAttributeNode(
                    (ret = elem.ownerDocument.createAttribute( name ))
                );
            }

            try {
                ret.value = value += "";
            } 
			catch( e ) {}

            // Break association with cloned elements by also using setAttribute (#9646)
            if ( name === "value" || value === elem.getAttribute( name ) ) {
                return value;
            }
        }
    };

    // Some attributes are constructed with empty-string values when not defined
    attrHandle.id = attrHandle.name = attrHandle.coords =
        function( elem, name, isXML ) {
            var ret;
            if ( !isXML ) {
                return (ret = elem.getAttributeNode( name )) && ret.value !== "" ?
                    ret.value :
                    null;
            }
        };

    // Fixing value retrieval on a button requires this module
    jQuery.valHooks.button = {
        get: function( elem, name ) {
            var ret = elem.getAttributeNode( name );
            if ( ret && ret.specified ) {
                return ret.value;
            }
        },
        set: nodeHook.set
    };

    // Set contenteditable to false on removals(#10429)
    // Setting to empty string throws an error as an invalid value
    jQuery.attrHooks.contenteditable = {
        set: function( elem, value, name ) {
            nodeHook.set( elem, value === "" ? false : value, name );
        }
    };

    // Set width and height to auto instead of 0 on empty string( Bug #8150 )
    // This is for removals
    jQuery.each([ "width", "height" ], function( i, name ) {
        jQuery.attrHooks[ name ] = {
            set: function( elem, value ) {
                if ( value === "" ) {
                    elem.setAttribute( name, "auto" );
                    return value;
                }
            }
        };
    });
}

if ( !support.style ) {
    jQuery.attrHooks.style = {
        get: function( elem ) {
            // Return undefined in the case of empty string
            // Note: IE uppercases css property names, but if we were to .toLowerCase()
            // .cssText, that would destroy case senstitivity in URL's, like in "background"
            return elem.style.cssText || undefined;
        },
        set: function( elem, value ) {
            return ( elem.style.cssText = value + "" );
        }
    };
}




var rfocusable = /^(?:input|select|textarea|button|object)$/i,
    rclickable = /^(?:a|area)$/i;

jQuery.fn.extend({
    prop: function( name, value ) {
        return access( this, jQuery.prop, name, value, arguments.length > 1 );
    },

    removeProp: function( name ) {
        name = jQuery.propFix[ name ] || name;
        return this.each(function() {
            // try/catch handles cases where IE balks (such as removing a property on window)
            try {
                this[ name ] = undefined;
                delete this[ name ];
            } catch( e ) {}
        });
    }
});

jQuery.extend({
    propFix: {
        "for": "htmlFor",
        "class": "className"
    },

    prop: function( elem, name, value ) {
        var ret, hooks, notxml,
            nType = elem.nodeType;

        // don't get/set properties on text, comment and attribute nodes
        if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
            return;
        }

        notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

        if ( notxml ) {
            // Fix name and attach hooks
            name = jQuery.propFix[ name ] || name;
            hooks = jQuery.propHooks[ name ];
        }

        if ( value !== undefined ) {
            return hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ?
                ret :
                ( elem[ name ] = value );

        } else {
            return hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ?
                ret :
                elem[ name ];
        }
    },

    propHooks: {
        tabIndex: {
            get: function( elem ) {
                // elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set
                // http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
                // Use proper attribute retrieval(#12072)
                var tabindex = jQuery.find.attr( elem, "tabindex" );

                return tabindex ?
                    parseInt( tabindex, 10 ) :
                    rfocusable.test( elem.nodeName ) || rclickable.test( elem.nodeName ) && elem.href ?
                        0 :
                        -1;
            }
        }
    }
});

// Some attributes require a special call on IE
// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !support.hrefNormalized ) {
    // href/src property should get the full normalized URL (#10299/#12915)
    jQuery.each([ "href", "src" ], function( i, name ) {
        jQuery.propHooks[ name ] = {
            get: function( elem ) {
                return elem.getAttribute( name, 4 );
            }
        };
    });
}

// Support: Safari, IE9+
// mis-reports the default selected property of an option
// Accessing the parent's selectedIndex property fixes it
if ( !support.optSelected ) {
    jQuery.propHooks.selected = {
        get: function( elem ) {
            var parent = elem.parentNode;

            if ( parent ) {
                parent.selectedIndex;

                // Make sure that it also works with optgroups, see #5701
                if ( parent.parentNode ) {
                    parent.parentNode.selectedIndex;
                }
            }
            return null;
        }
    };
}

jQuery.each([
    "tabIndex",
    "readOnly",
    "maxLength",
    "cellSpacing",
    "cellPadding",
    "rowSpan",
    "colSpan",
    "useMap",
    "frameBorder",
    "contentEditable"
], function() {
    jQuery.propFix[ this.toLowerCase() ] = this;
});

// IE6/7 call enctype encoding
if ( !support.enctype ) {
    jQuery.propFix.enctype = "encoding";
}




var rclass = /[\t\r\n\f]/g;

jQuery.fn.extend({
    addClass: function( value ) {
        var classes, elem, cur, clazz, j, finalValue,
            i = 0,
            len = this.length,
            proceed = typeof value === "string" && value;

        if ( jQuery.isFunction( value ) ) {
            return this.each(function( j ) {
                jQuery( this ).addClass( value.call( this, j, this.className ) );
            });
        }

        if ( proceed ) {
            // The disjunction here is for better compressibility (see removeClass)
            classes = ( value || "" ).match( rnotwhite ) || [];

            for ( ; i < len; i++ ) {
                elem = this[ i ];
                cur = elem.nodeType === 1 && ( elem.className ?
                    ( " " + elem.className + " " ).replace( rclass, " " ) :
                    " "
                );

                if ( cur ) {
                    j = 0;
                    while ( (clazz = classes[j++]) ) {
                        if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
                            cur += clazz + " ";
                        }
                    }

                    // only assign if different to avoid unneeded rendering.
                    finalValue = jQuery.trim( cur );
                    if ( elem.className !== finalValue ) {
                        elem.className = finalValue;
                    }
                }
            }
        }

        return this;
    },

    removeClass: function( value ) {
        var classes, elem, cur, clazz, j, finalValue,
            i = 0,
            len = this.length,
            proceed = arguments.length === 0 || typeof value === "string" && value;

        if ( jQuery.isFunction( value ) ) {
            return this.each(function( j ) {
                jQuery( this ).removeClass( value.call( this, j, this.className ) );
            });
        }
        if ( proceed ) {
            classes = ( value || "" ).match( rnotwhite ) || [];

            for ( ; i < len; i++ ) {
                elem = this[ i ];
                // This expression is here for better compressibility (see addClass)
                cur = elem.nodeType === 1 && ( elem.className ?
                    ( " " + elem.className + " " ).replace( rclass, " " ) :
                    ""
                );

                if ( cur ) {
                    j = 0;
                    while ( (clazz = classes[j++]) ) {
                        // Remove *all* instances
                        while ( cur.indexOf( " " + clazz + " " ) >= 0 ) {
                            cur = cur.replace( " " + clazz + " ", " " );
                        }
                    }

                    // only assign if different to avoid unneeded rendering.
                    finalValue = value ? jQuery.trim( cur ) : "";
                    if ( elem.className !== finalValue ) {
                        elem.className = finalValue;
                    }
                }
            }
        }

        return this;
    },

    toggleClass: function( value, stateVal ) {
        var type = typeof value;

        if ( typeof stateVal === "boolean" && type === "string" ) {
            return stateVal ? this.addClass( value ) : this.removeClass( value );
        }

        if ( jQuery.isFunction( value ) ) {
            return this.each(function( i ) {
                jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
            });
        }

        return this.each(function() {
            if ( type === "string" ) {
                // toggle individual class names
                var className,
                    i = 0,
                    self = jQuery( this ),
                    classNames = value.match( rnotwhite ) || [];

                while ( (className = classNames[ i++ ]) ) {
                    // check each className given, space separated list
                    if ( self.hasClass( className ) ) {
                        self.removeClass( className );
                    } else {
                        self.addClass( className );
                    }
                }

            // Toggle whole class name
            } else if ( type === strundefined || type === "boolean" ) {
                if ( this.className ) {
                    // store className if set
                    jQuery._data( this, "__className__", this.className );
                }

                // If the element has a class name or if we're passed "false",
                // then remove the whole classname (if there was one, the above saved it).
                // Otherwise bring back whatever was previously saved (if anything),
                // falling back to the empty string if nothing was stored.
                this.className = this.className || value === false ? "" : jQuery._data( this, "__className__" ) || "";
            }
        });
    },

    hasClass: function( selector ) {
        var className = " " + selector + " ",
            i = 0,
            l = this.length;
        for ( ; i < l; i++ ) {
            if ( this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) >= 0 ) {
                return true;
            }
        }

        return false;
    }
});




// Return jQuery for attributes-only inclusion


jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
    "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
    "change select submit keydown keypress keyup error contextmenu").split(" "), function( i, name ) {

    // Handle event binding
    jQuery.fn[ name ] = function( data, fn ) {
        return arguments.length > 0 ?
            this.on( name, null, data, fn ) :
            this.trigger( name );
    };
});

jQuery.fn.extend({
    hover: function( fnOver, fnOut ) {
        return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
    },

    bind: function( types, data, fn ) {
        return this.on( types, null, data, fn );
    },
    unbind: function( types, fn ) {
        return this.off( types, null, fn );
    },

    delegate: function( selector, types, data, fn ) {
        return this.on( types, selector, data, fn );
    },
    undelegate: function( selector, types, fn ) {
        // ( namespace ) or ( selector, types [, fn] )
        return arguments.length === 1 ? this.off( selector, "**" ) : this.off( types, selector || "**", fn );
    }
});


var nonce = jQuery.now();

var rquery = (/\?/);



var rvalidtokens = /(,)|(\[|{)|(}|])|"(?:[^"\\\r\n]|\\["\\\/bfnrt]|\\u[\da-fA-F]{4})*"\s*:?|true|false|null|-?(?!0\d)\d+(?:\.\d+|)(?:[eE][+-]?\d+|)/g;

jQuery.parseJSON = function( data ) {
    // Attempt to parse using the native JSON parser first
    if ( window.JSON && window.JSON.parse ) {
        // Support: Android 2.3
        // Workaround failure to string-cast null input
        return window.JSON.parse( data + "" );
    }

    var requireNonComma,
        depth = null,
        str = jQuery.trim( data + "" );

    // Guard against invalid (and possibly dangerous) input by ensuring that nothing remains
    // after removing valid tokens
    return str && !jQuery.trim( str.replace( rvalidtokens, function( token, comma, open, close ) {

        // Force termination if we see a misplaced comma
        if ( requireNonComma && comma ) {
            depth = 0;
        }

        // Perform no more replacements after returning to outermost depth
        if ( depth === 0 ) {
            return token;
        }

        // Commas must not follow "[", "{", or ","
        requireNonComma = open || comma;

        // Determine new depth
        // array/object open ("[" or "{"): depth += true - false (increment)
        // array/object close ("]" or "}"): depth += false - true (decrement)
        // other cases ("," or primitive): depth += true - true (numeric cast)
        depth += !close - !open;

        // Remove this token
        return "";
    }) ) ?
        ( Function( "return " + str ) )() :
        jQuery.error( "Invalid JSON: " + data );
};


// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
    var xml, tmp;
    if ( !data || typeof data !== "string" ) {
        return null;
    }
    try {
        if ( window.DOMParser ) { // Standard
            tmp = new DOMParser();
            xml = tmp.parseFromString( data, "text/xml" );
        } else { // IE
            xml = new ActiveXObject( "Microsoft.XMLDOM" );
            xml.async = "false";
            xml.loadXML( data );
        }
    } catch( e ) {
        xml = undefined;
    }
    if ( !xml || !xml.documentElement || xml.getElementsByTagName( "parsererror" ).length ) {
        jQuery.error( "Invalid XML: " + data );
    }
    return xml;
};


var
    // Document location
    ajaxLocParts,
    ajaxLocation,

    rhash = /#.*$/,
    rts = /([?&])_=[^&]*/,
    rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg, // IE leaves an \r character at EOL
    // #7653, #8125, #8152: local protocol detection
    rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
    rnoContent = /^(?:GET|HEAD)$/,
    rprotocol = /^\/\//,
    rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,

    /* Prefilters
     * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
     * 2) These are called:
     *    - BEFORE asking for a transport
     *    - AFTER param serialization (s.data is a string if s.processData is true)
     * 3) key is the dataType
     * 4) the catchall symbol "*" can be used
     * 5) execution will start with transport dataType and THEN continue down to "*" if needed
     */
    prefilters = {},

    /* Transports bindings
     * 1) key is the dataType
     * 2) the catchall symbol "*" can be used
     * 3) selection will start with transport dataType and THEN go to "*" if needed
     */
    transports = {},

    // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
    allTypes = "*/".concat("*");

// #8138, IE may throw an exception when accessing
// a field from window.location if document.domain has been set
try {
    ajaxLocation = location.href;
} catch( e ) {
    // Use the href attribute of an A element
    // since IE will modify it given document.location
    ajaxLocation = document.createElement( "a" );
    ajaxLocation.href = "";
    ajaxLocation = ajaxLocation.href;
}

// Segment location into parts
ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

    // dataTypeExpression is optional and defaults to "*"
    return function( dataTypeExpression, func ) {

        if ( typeof dataTypeExpression !== "string" ) {
            func = dataTypeExpression;
            dataTypeExpression = "*";
        }

        var dataType,
            i = 0,
            dataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];

        if ( jQuery.isFunction( func ) ) {
            // For each dataType in the dataTypeExpression
            while ( (dataType = dataTypes[i++]) ) {
                // Prepend if requested
                if ( dataType.charAt( 0 ) === "+" ) {
                    dataType = dataType.slice( 1 ) || "*";
                    (structure[ dataType ] = structure[ dataType ] || []).unshift( func );

                // Otherwise append
                } else {
                    (structure[ dataType ] = structure[ dataType ] || []).push( func );
                }
            }
        }
    };
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

    var inspected = {},
        seekingTransport = ( structure === transports );

    function inspect( dataType ) {
        var selected;
        inspected[ dataType ] = true;
        jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
            var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
            if ( typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[ dataTypeOrTransport ] ) {
                options.dataTypes.unshift( dataTypeOrTransport );
                inspect( dataTypeOrTransport );
                return false;
            } else if ( seekingTransport ) {
                return !( selected = dataTypeOrTransport );
            }
        });
        return selected;
    }

    return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
    var deep, key,
        flatOptions = jQuery.ajaxSettings.flatOptions || {};

    for ( key in src ) {
        if ( src[ key ] !== undefined ) {
            ( flatOptions[ key ] ? target : ( deep || (deep = {}) ) )[ key ] = src[ key ];
        }
    }
    if ( deep ) {
        jQuery.extend( true, target, deep );
    }

    return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {
    var firstDataType, ct, finalDataType, type,
        contents = s.contents,
        dataTypes = s.dataTypes;

    // Remove auto dataType and get content-type in the process
    while ( dataTypes[ 0 ] === "*" ) {
        dataTypes.shift();
        if ( ct === undefined ) {
            ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
        }
    }

    // Check if we're dealing with a known content-type
    if ( ct ) {
        for ( type in contents ) {
            if ( contents[ type ] && contents[ type ].test( ct ) ) {
                dataTypes.unshift( type );
                break;
            }
        }
    }

    // Check to see if we have a response for the expected dataType
    if ( dataTypes[ 0 ] in responses ) {
        finalDataType = dataTypes[ 0 ];
    } else {
        // Try convertible dataTypes
        for ( type in responses ) {
            if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {
                finalDataType = type;
                break;
            }
            if ( !firstDataType ) {
                firstDataType = type;
            }
        }
        // Or just use first one
        finalDataType = finalDataType || firstDataType;
    }

    // If we found a dataType
    // We add the dataType to the list if needed
    // and return the corresponding response
    if ( finalDataType ) {
        if ( finalDataType !== dataTypes[ 0 ] ) {
            dataTypes.unshift( finalDataType );
        }
        return responses[ finalDataType ];
    }
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
    var conv2, current, conv, tmp, prev,
        converters = {},
        // Work with a copy of dataTypes in case we need to modify it for conversion
        dataTypes = s.dataTypes.slice();

    // Create converters map with lowercased keys
    if ( dataTypes[ 1 ] ) {
        for ( conv in s.converters ) {
            converters[ conv.toLowerCase() ] = s.converters[ conv ];
        }
    }

    current = dataTypes.shift();

    // Convert to each sequential dataType
    while ( current ) {

        if ( s.responseFields[ current ] ) {
            jqXHR[ s.responseFields[ current ] ] = response;
        }

        // Apply the dataFilter if provided
        if ( !prev && isSuccess && s.dataFilter ) {
            response = s.dataFilter( response, s.dataType );
        }

        prev = current;
        current = dataTypes.shift();

        if ( current ) {

            // There's only work to do if current dataType is non-auto
            if ( current === "*" ) {

                current = prev;

            // Convert response if prev dataType is non-auto and differs from current
            } else if ( prev !== "*" && prev !== current ) {

                // Seek a direct converter
                conv = converters[ prev + " " + current ] || converters[ "* " + current ];

                // If none found, seek a pair
                if ( !conv ) {
                    for ( conv2 in converters ) {

                        // If conv2 outputs current
                        tmp = conv2.split( " " );
                        if ( tmp[ 1 ] === current ) {

                            // If prev can be converted to accepted input
                            conv = converters[ prev + " " + tmp[ 0 ] ] ||
                                converters[ "* " + tmp[ 0 ] ];
                            if ( conv ) {
                                // Condense equivalence converters
                                if ( conv === true ) {
                                    conv = converters[ conv2 ];

                                // Otherwise, insert the intermediate dataType
                                } else if ( converters[ conv2 ] !== true ) {
                                    current = tmp[ 0 ];
                                    dataTypes.unshift( tmp[ 1 ] );
                                }
                                break;
                            }
                        }
                    }
                }

                // Apply converter (if not an equivalence)
                if ( conv !== true ) {

                    // Unless errors are allowed to bubble, catch and return them
                    if ( conv && s[ "throws" ] ) {
                        response = conv( response );
                    } else {
                        try {
                            response = conv( response );
                        } catch ( e ) {
                            return { state: "parsererror", error: conv ? e : "No conversion from " + prev + " to " + current };
                        }
                    }
                }
            }
        }
    }

    return { state: "success", data: response };
}

jQuery.extend({

    // Counter for holding the number of active queries
    active: 0,

    // Last-Modified header cache for next request
    lastModified: {},
    etag: {},

    ajaxSettings: {
        url: ajaxLocation,
        type: "GET",
        isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
        global: true,
        processData: true,
        async: true,
        contentType: "application/x-www-form-urlencoded; charset=UTF-8",
        /*
        timeout: 0,
        data: null,
        dataType: null,
        username: null,
        password: null,
        cache: null,
        throws: false,
        traditional: false,
        headers: {},
        */

        accepts: {
            "*": allTypes,
            text: "text/plain",
            html: "text/html",
            xml: "application/xml, text/xml",
            json: "application/json, text/javascript"
        },

        contents: {
            xml: /xml/,
            html: /html/,
            json: /json/
        },

        responseFields: {
            xml: "responseXML",
            text: "responseText",
            json: "responseJSON"
        },

        // Data converters
        // Keys separate source (or catchall "*") and destination types with a single space
        converters: {

            // Convert anything to text
            "* text": String,

            // Text to html (true = no transformation)
            "text html": true,

            // Evaluate text as a json expression
            "text json": jQuery.parseJSON,

            // Parse text as xml
            "text xml": jQuery.parseXML
        },

        // For options that shouldn't be deep extended:
        // you can add your own custom options here if
        // and when you create one that shouldn't be
        // deep extended (see ajaxExtend)
        flatOptions: {
            url: true,
            context: true
        }
    },

    // Creates a full fledged settings object into target
    // with both ajaxSettings and settings fields.
    // If target is omitted, writes into ajaxSettings.
    ajaxSetup: function( target, settings ) {
        return settings ?

            // Building a settings object
            ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

            // Extending ajaxSettings
            ajaxExtend( jQuery.ajaxSettings, target );
    },

    ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
    ajaxTransport: addToPrefiltersOrTransports( transports ),

    // Main method
    ajax: function( url, options ) {

        // If url is an object, simulate pre-1.5 signature
        if ( typeof url === "object" ) {
            options = url;
            url = undefined;
        }

        // Force options to be an object
        options = options || {};

        var // Cross-domain detection vars
            parts,
            // Loop variable
            i,
            // URL without anti-cache param
            cacheURL,
            // Response headers as string
            responseHeadersString,
            // timeout handle
            timeoutTimer,

            // To know if global events are to be dispatched
            fireGlobals,

            transport,
            // Response headers
            responseHeaders,
            // Create the final options object
            s = jQuery.ajaxSetup( {}, options ),
            // Callbacks context
            callbackContext = s.context || s,
            // Context for global events is callbackContext if it is a DOM node or jQuery collection
            globalEventContext = s.context && ( callbackContext.nodeType || callbackContext.jquery ) ?
                jQuery( callbackContext ) :
                jQuery.event,
            // Deferreds
            deferred = jQuery.Deferred(),
            completeDeferred = jQuery.Callbacks("once memory"),
            // Status-dependent callbacks
            statusCode = s.statusCode || {},
            // Headers (they are sent all at once)
            requestHeaders = {},
            requestHeadersNames = {},
            // The jqXHR state
            state = 0,
            // Default abort message
            strAbort = "canceled",
            // Fake xhr
            jqXHR = {
                readyState: 0,

                // Builds headers hashtable if needed
                getResponseHeader: function( key ) {
                    var match;
                    if ( state === 2 ) {
                        if ( !responseHeaders ) {
                            responseHeaders = {};
                            while ( (match = rheaders.exec( responseHeadersString )) ) {
                                responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
                            }
                        }
                        match = responseHeaders[ key.toLowerCase() ];
                    }
                    return match == null ? null : match;
                },

                // Raw string
                getAllResponseHeaders: function() {
                    return state === 2 ? responseHeadersString : null;
                },

                // Caches the header
                setRequestHeader: function( name, value ) {
                    var lname = name.toLowerCase();
                    if ( !state ) {
                        name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
                        requestHeaders[ name ] = value;
                    }
                    return this;
                },

                // Overrides response content-type header
                overrideMimeType: function( type ) {
                    if ( !state ) {
                        s.mimeType = type;
                    }
                    return this;
                },

                // Status-dependent callbacks
                statusCode: function( map ) {
                    var code;
                    if ( map ) {
                        if ( state < 2 ) {
                            for ( code in map ) {
                                // Lazy-add the new callback in a way that preserves old ones
                                statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
                            }
                        } else {
                            // Execute the appropriate callbacks
                            jqXHR.always( map[ jqXHR.status ] );
                        }
                    }
                    return this;
                },

                // Cancel the request
                abort: function( statusText ) {
                    var finalText = statusText || strAbort;
                    if ( transport ) {
                        transport.abort( finalText );
                    }
                    done( 0, finalText );
                    return this;
                }
            };

        // Attach deferreds
        deferred.promise( jqXHR ).complete = completeDeferred.add;
        jqXHR.success = jqXHR.done;
        jqXHR.error = jqXHR.fail;

        // Remove hash character (#7531: and string promotion)
        // Add protocol if not provided (#5866: IE7 issue with protocol-less urls)
        // Handle falsy url in the settings object (#10093: consistency with old signature)
        // We also use the url parameter if available
        s.url = ( ( url || s.url || ajaxLocation ) + "" ).replace( rhash, "" ).replace( rprotocol, ajaxLocParts[ 1 ] + "//" );

        // Alias method option to type as per ticket #12004
        s.type = options.method || options.type || s.method || s.type;

        // Extract dataTypes list
        s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().match( rnotwhite ) || [ "" ];

        // A cross-domain request is in order when we have a protocol:host:port mismatch
        if ( s.crossDomain == null ) {
            parts = rurl.exec( s.url.toLowerCase() );
            s.crossDomain = !!( parts &&
                ( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||
                    ( parts[ 3 ] || ( parts[ 1 ] === "http:" ? "80" : "443" ) ) !==
                        ( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? "80" : "443" ) ) )
            );
        }

        // Convert data if not already a string
        if ( s.data && s.processData && typeof s.data !== "string" ) {
            s.data = jQuery.param( s.data, s.traditional );
        }

        // Apply prefilters
        inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

        // If request was aborted inside a prefilter, stop there
        if ( state === 2 ) {
            return jqXHR;
        }

        // We can fire global events as of now if asked to
        fireGlobals = s.global;

        // Watch for a new set of requests
        if ( fireGlobals && jQuery.active++ === 0 ) {
            jQuery.event.trigger("ajaxStart");
        }

        // Uppercase the type
        s.type = s.type.toUpperCase();

        // Determine if request has content
        s.hasContent = !rnoContent.test( s.type );

        // Save the URL in case we're toying with the If-Modified-Since
        // and/or If-None-Match header later on
        cacheURL = s.url;

        // More options handling for requests with no content
        if ( !s.hasContent ) {

            // If data is available, append data to url
            if ( s.data ) {
                cacheURL = ( s.url += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data );
                // #9682: remove data so that it's not used in an eventual retry
                delete s.data;
            }

            // Add anti-cache in url if needed
            if ( s.cache === false ) {
                s.url = rts.test( cacheURL ) ?

                    // If there is already a '_' parameter, set its value
                    cacheURL.replace( rts, "$1_=" + nonce++ ) :

                    // Otherwise add one to the end
                    cacheURL + ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + nonce++;
            }
        }

        // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
        if ( s.ifModified ) {
            if ( jQuery.lastModified[ cacheURL ] ) {
                jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
            }
            if ( jQuery.etag[ cacheURL ] ) {
                jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
            }
        }

        // Set the correct header, if data is being sent
        if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
            jqXHR.setRequestHeader( "Content-Type", s.contentType );
        }

        // Set the Accepts header for the server, depending on the dataType
        jqXHR.setRequestHeader(
            "Accept",
            s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?
                s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
                s.accepts[ "*" ]
        );

        // Check for headers option
        for ( i in s.headers ) {
            jqXHR.setRequestHeader( i, s.headers[ i ] );
        }

        // Allow custom headers/mimetypes and early abort
        if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
            // Abort if not done already and return
            return jqXHR.abort();
        }

        // aborting is no longer a cancellation
        strAbort = "abort";

        // Install callbacks on deferreds
        for ( i in { success: 1, error: 1, complete: 1 } ) {
            jqXHR[ i ]( s[ i ] );
        }

        // Get transport
        transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

        // If no transport, we auto-abort
        if ( !transport ) {
            done( -1, "No Transport" );
        } else {
            jqXHR.readyState = 1;

            // Send global event
            if ( fireGlobals ) {
                globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
            }
            // Timeout
            if ( s.async && s.timeout > 0 ) {
                timeoutTimer = setTimeout(function() {
                    jqXHR.abort("timeout");
                }, s.timeout );
            }

            try {
                state = 1;
                transport.send( requestHeaders, done );
            } catch ( e ) {
                // Propagate exception as error if not done
                if ( state < 2 ) {
                    done( -1, e );
                // Simply rethrow otherwise
                } else {
                    throw e;
                }
            }
        }

        // Callback for when everything is done
        function done( status, nativeStatusText, responses, headers ) {
            var isSuccess, success, error, response, modified,
                statusText = nativeStatusText;

            // Called once
            if ( state === 2 ) {
                return;
            }

            // State is "done" now
            state = 2;

            // Clear timeout if it exists
            if ( timeoutTimer ) {
                clearTimeout( timeoutTimer );
            }

            // Dereference transport for early garbage collection
            // (no matter how long the jqXHR object will be used)
            transport = undefined;

            // Cache response headers
            responseHeadersString = headers || "";

            // Set readyState
            jqXHR.readyState = status > 0 ? 4 : 0;

            // Determine if successful
            isSuccess = status >= 200 && status < 300 || status === 304;

            // Get response data
            if ( responses ) {
                response = ajaxHandleResponses( s, jqXHR, responses );
            }

            // Convert no matter what (that way responseXXX fields are always set)
            response = ajaxConvert( s, response, jqXHR, isSuccess );

            // If successful, handle type chaining
            if ( isSuccess ) {

                // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
                if ( s.ifModified ) {
                    modified = jqXHR.getResponseHeader("Last-Modified");
                    if ( modified ) {
                        jQuery.lastModified[ cacheURL ] = modified;
                    }
                    modified = jqXHR.getResponseHeader("etag");
                    if ( modified ) {
                        jQuery.etag[ cacheURL ] = modified;
                    }
                }

                // if no content
                if ( status === 204 || s.type === "HEAD" ) {
                    statusText = "nocontent";

                // if not modified
                } else if ( status === 304 ) {
                    statusText = "notmodified";

                // If we have data, let's convert it
                } else {
                    statusText = response.state;
                    success = response.data;
                    error = response.error;
                    isSuccess = !error;
                }
            } else {
                // We extract error from statusText
                // then normalize statusText and status for non-aborts
                error = statusText;
                if ( status || !statusText ) {
                    statusText = "error";
                    if ( status < 0 ) {
                        status = 0;
                    }
                }
            }

            // Set data for the fake xhr object
            jqXHR.status = status;
            jqXHR.statusText = ( nativeStatusText || statusText ) + "";

            // Success/Error
            if ( isSuccess ) {
                deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
            } else {
                deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
            }

            // Status-dependent callbacks
            jqXHR.statusCode( statusCode );
            statusCode = undefined;

            if ( fireGlobals ) {
                globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
                    [ jqXHR, s, isSuccess ? success : error ] );
            }

            // Complete
            completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

            if ( fireGlobals ) {
                globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
                // Handle the global AJAX counter
                if ( !( --jQuery.active ) ) {
                    jQuery.event.trigger("ajaxStop");
                }
            }
        }

        return jqXHR;
    },

    getJSON: function( url, data, callback ) {
        return jQuery.get( url, data, callback, "json" );
    },

    getScript: function( url, callback ) {
        return jQuery.get( url, undefined, callback, "script" );
    }
});

jQuery.each( [ "get", "post" ], function( i, method ) {
    jQuery[ method ] = function( url, data, callback, type ) {
        // shift arguments if data argument was omitted
        if ( jQuery.isFunction( data ) ) {
            type = type || callback;
            callback = data;
            data = undefined;
        }

        return jQuery.ajax({
            url: url,
            type: method,
            dataType: type,
            data: data,
            success: callback
        });
    };
});

// Attach a bunch of functions for handling common AJAX events
jQuery.each( [ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend" ], function( i, type ) {
    jQuery.fn[ type ] = function( fn ) {
        return this.on( type, fn );
    };
});


jQuery._evalUrl = function( url ) {
    return jQuery.ajax({
        url: url,
        type: "GET",
        dataType: "script",
        async: false,
        global: false,
        "throws": true
    });
};


jQuery.fn.extend({
    wrapAll: function( html ) {
        if ( jQuery.isFunction( html ) ) {
            return this.each(function(i) {
                jQuery(this).wrapAll( html.call(this, i) );
            });
        }

        if ( this[0] ) {
            // The elements to wrap the target around
            var wrap = jQuery( html, this[0].ownerDocument ).eq(0).clone(true);

            if ( this[0].parentNode ) {
                wrap.insertBefore( this[0] );
            }

            wrap.map(function() {
                var elem = this;

                while ( elem.firstChild && elem.firstChild.nodeType === 1 ) {
                    elem = elem.firstChild;
                }

                return elem;
            }).append( this );
        }

        return this;
    },

    wrapInner: function( html ) {
        if ( jQuery.isFunction( html ) ) {
            return this.each(function(i) {
                jQuery(this).wrapInner( html.call(this, i) );
            });
        }

        return this.each(function() {
            var self = jQuery( this ),
                contents = self.contents();

            if ( contents.length ) {
                contents.wrapAll( html );

            } else {
                self.append( html );
            }
        });
    },

    wrap: function( html ) {
        var isFunction = jQuery.isFunction( html );

        return this.each(function(i) {
            jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );
        });
    },

    unwrap: function() {
        return this.parent().each(function() {
            if ( !jQuery.nodeName( this, "body" ) ) {
                jQuery( this ).replaceWith( this.childNodes );
            }
        }).end();
    }
});


jQuery.expr.filters.hidden = function( elem ) {
    // Support: Opera <= 12.12
    // Opera reports offsetWidths and offsetHeights less than zero on some elements
    return elem.offsetWidth <= 0 && elem.offsetHeight <= 0 ||
        (!support.reliableHiddenOffsets() &&
            ((elem.style && elem.style.display) || jQuery.css( elem, "display" )) === "none");
};

jQuery.expr.filters.visible = function( elem ) {
    return !jQuery.expr.filters.hidden( elem );
};




var r20 = /%20/g,
    rbracket = /\[\]$/,
    rCRLF = /\r?\n/g,
    rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
    rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
    var name;

    if ( jQuery.isArray( obj ) ) {
        // Serialize array item.
        jQuery.each( obj, function( i, v ) {
            if ( traditional || rbracket.test( prefix ) ) {
                // Treat each array item as a scalar.
                add( prefix, v );

            } else {
                // Item is non-scalar (array or object), encode its numeric index.
                buildParams( prefix + "[" + ( typeof v === "object" ? i : "" ) + "]", v, traditional, add );
            }
        });

    } else if ( !traditional && jQuery.type( obj ) === "object" ) {
        // Serialize object item.
        for ( name in obj ) {
            buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
        }

    } else {
        // Serialize scalar item.
        add( prefix, obj );
    }
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
    var prefix,
        s = [],
        add = function( key, value ) {
            // If value is a function, invoke it and return its value
            value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );
            s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
        };

    // Set traditional to true for jQuery <= 1.3.2 behavior.
    if ( traditional === undefined ) {
        traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
    }

    // If an array was passed in, assume that it is an array of form elements.
    if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
        // Serialize the form elements
        jQuery.each( a, function() {
            add( this.name, this.value );
        });

    } else {
        // If traditional, encode the "old" way (the way 1.3.2 or older
        // did it), otherwise encode params recursively.
        for ( prefix in a ) {
            buildParams( prefix, a[ prefix ], traditional, add );
        }
    }

    // Return the resulting serialization
    return s.join( "&" ).replace( r20, "+" );
};

jQuery.fn.extend({
    serialize: function() {
        return jQuery.param( this.serializeArray() );
    },
    serializeArray: function() {
        return this.map(function() {
            // Can add propHook for "elements" to filter or add form elements
            var elements = jQuery.prop( this, "elements" );
            return elements ? jQuery.makeArray( elements ) : this;
        })
        .filter(function() {
            var type = this.type;
            // Use .is(":disabled") so that fieldset[disabled] works
            return this.name && !jQuery( this ).is( ":disabled" ) &&
                rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
                ( this.checked || !rcheckableType.test( type ) );
        })
        .map(function( i, elem ) {
            var val = jQuery( this ).val();

            return val == null ?
                null :
                jQuery.isArray( val ) ?
                    jQuery.map( val, function( val ) {
                        return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
                    }) :
                    { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
        }).get();
    }
});


// Create the request object
// (This is still attached to ajaxSettings for backward compatibility)
jQuery.ajaxSettings.xhr = window.ActiveXObject !== undefined ?
    // Support: IE6+
    function() {

        // XHR cannot access local files, always use ActiveX for that case
        return !this.isLocal &&

            // Support: IE7-8
            // oldIE XHR does not support non-RFC2616 methods (#13240)
            // See http://msdn.microsoft.com/en-us/library/ie/ms536648(v=vs.85).aspx
            // and http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9
            // Although this check for six methods instead of eight
            // since IE also does not support "trace" and "connect"
            /^(get|post|head|put|delete|options)$/i.test( this.type ) &&

            createStandardXHR() || createActiveXHR();
    } :
    // For all other browsers, use the standard XMLHttpRequest object
    createStandardXHR;

var xhrId = 0,
    xhrCallbacks = {},
    xhrSupported = jQuery.ajaxSettings.xhr();

// Support: IE<10
// Open requests must be manually aborted on unload (#5280)
if ( window.ActiveXObject ) {
    jQuery( window ).on( "unload", function() {
        for ( var key in xhrCallbacks ) {
            xhrCallbacks[ key ]( undefined, true );
        }
    });
}

// Determine support properties
support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
xhrSupported = support.ajax = !!xhrSupported;

// Create transport if the browser can provide an xhr
if ( xhrSupported ) {

    jQuery.ajaxTransport(function( options ) {
        // Cross domain only allowed if supported through XMLHttpRequest
        if ( !options.crossDomain || support.cors ) {

            var callback;

            return {
                send: function( headers, complete ) {
                    var i,
                        xhr = options.xhr(),
                        id = ++xhrId;

                    // Open the socket
                    xhr.open( options.type, options.url, options.async, options.username, options.password );

                    // Apply custom fields if provided
                    if ( options.xhrFields ) {
                        for ( i in options.xhrFields ) {
                            xhr[ i ] = options.xhrFields[ i ];
                        }
                    }

                    // Override mime type if needed
                    if ( options.mimeType && xhr.overrideMimeType ) {
                        xhr.overrideMimeType( options.mimeType );
                    }

                    // X-Requested-With header
                    // For cross-domain requests, seeing as conditions for a preflight are
                    // akin to a jigsaw puzzle, we simply never set it to be sure.
                    // (it can always be set on a per-request basis or even using ajaxSetup)
                    // For same-domain requests, won't change header if already provided.
                    if ( !options.crossDomain && !headers["X-Requested-With"] ) {
                        headers["X-Requested-With"] = "XMLHttpRequest";
                    }

                    // Set headers
                    for ( i in headers ) {
                        // Support: IE<9
                        // IE's ActiveXObject throws a 'Type Mismatch' exception when setting
                        // request header to a null-value.
                        //
                        // To keep consistent with other XHR implementations, cast the value
                        // to string and ignore `undefined`.
                        if ( headers[ i ] !== undefined ) {
                            xhr.setRequestHeader( i, headers[ i ] + "" );
                        }
                    }

                    // Do send the request
                    // This may raise an exception which is actually
                    // handled in jQuery.ajax (so no try/catch here)
                    xhr.send( ( options.hasContent && options.data ) || null );

                    // Listener
                    callback = function( _, isAbort ) {
                        var status, statusText, responses;

                        // Was never called and is aborted or complete
                        if ( callback && ( isAbort || xhr.readyState === 4 ) ) {
                            // Clean up
                            delete xhrCallbacks[ id ];
                            callback = undefined;
                            xhr.onreadystatechange = jQuery.noop;

                            // Abort manually if needed
                            if ( isAbort ) {
                                if ( xhr.readyState !== 4 ) {
                                    xhr.abort();
                                }
                            } else {
                                responses = {};
                                status = xhr.status;

                                // Support: IE<10
                                // Accessing binary-data responseText throws an exception
                                // (#11426)
                                if ( typeof xhr.responseText === "string" ) {
                                    responses.text = xhr.responseText;
                                }

                                // Firefox throws an exception when accessing
                                // statusText for faulty cross-domain requests
                                try {
                                    statusText = xhr.statusText;
                                } catch( e ) {
                                    // We normalize with Webkit giving an empty statusText
                                    statusText = "";
                                }

                                // Filter status for non standard behaviors

                                // If the request is local and we have data: assume a success
                                // (success with no data won't get notified, that's the best we
                                // can do given current implementations)
                                if ( !status && options.isLocal && !options.crossDomain ) {
                                    status = responses.text ? 200 : 404;
                                // IE - #1450: sometimes returns 1223 when it should be 204
                                } else if ( status === 1223 ) {
                                    status = 204;
                                }
                            }
                        }

                        // Call complete if needed
                        if ( responses ) {
                            complete( status, statusText, responses, xhr.getAllResponseHeaders() );
                        }
                    };

                    if ( !options.async ) {
                        // if we're in sync mode we fire the callback
                        callback();
                    } else if ( xhr.readyState === 4 ) {
                        // (IE6 & IE7) if it's in cache and has been
                        // retrieved directly we need to fire the callback
                        setTimeout( callback );
                    } else {
                        // Add to the list of active xhr callbacks
                        xhr.onreadystatechange = xhrCallbacks[ id ] = callback;
                    }
                },

                abort: function() {
                    if ( callback ) {
                        callback( undefined, true );
                    }
                }
            };
        }
    });
}

// Functions to create xhrs
function createStandardXHR() {
    try {
        return new window.XMLHttpRequest();
    } catch( e ) {}
}

function createActiveXHR() {
    try {
        return new window.ActiveXObject( "Microsoft.XMLHTTP" );
    } catch( e ) {}
}




// Install script dataType
jQuery.ajaxSetup({
    accepts: {
        script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
    },
    contents: {
        script: /(?:java|ecma)script/
    },
    converters: {
        "text script": function( text ) {
            jQuery.globalEval( text );
            return text;
        }
    }
});

// Handle cache's special case and global
jQuery.ajaxPrefilter( "script", function( s ) {
    if ( s.cache === undefined ) {
        s.cache = false;
    }
    if ( s.crossDomain ) {
        s.type = "GET";
        s.global = false;
    }
});

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function(s) {

    // This transport only deals with cross domain requests
    if ( s.crossDomain ) {

        var script,
            head = document.head || jQuery("head")[0] || document.documentElement;

        return {

            send: function( _, callback ) {

                script = document.createElement("script");

                script.async = true;

                if ( s.scriptCharset ) {
                    script.charset = s.scriptCharset;
                }

                script.src = s.url;

                // Attach handlers for all browsers
                script.onload = script.onreadystatechange = function( _, isAbort ) {

                    if ( isAbort || !script.readyState || /loaded|complete/.test( script.readyState ) ) {

                        // Handle memory leak in IE
                        script.onload = script.onreadystatechange = null;

                        // Remove the script
                        if ( script.parentNode ) {
                            script.parentNode.removeChild( script );
                        }

                        // Dereference the script
                        script = null;

                        // Callback if not abort
                        if ( !isAbort ) {
                            callback( 200, "success" );
                        }
                    }
                };

                // Circumvent IE6 bugs with base elements (#2709 and #4378) by prepending
                // Use native DOM manipulation to avoid our domManip AJAX trickery
                head.insertBefore( script, head.firstChild );
            },

            abort: function() {
                if ( script ) {
                    script.onload( undefined, true );
                }
            }
        };
    }
});




var oldCallbacks = [],
    rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup({
    jsonp: "callback",
    jsonpCallback: function() {
        var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
        this[ callback ] = true;
        return callback;
    }
});

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

    var callbackName, overwritten, responseContainer,
        jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
            "url" :
            typeof s.data === "string" && !( s.contentType || "" ).indexOf("application/x-www-form-urlencoded") && rjsonp.test( s.data ) && "data"
        );

    // Handle iff the expected data type is "jsonp" or we have a parameter to set
    if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

        // Get callback name, remembering preexisting value associated with it
        callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
            s.jsonpCallback() :
            s.jsonpCallback;

        // Insert callback into url or form data
        if ( jsonProp ) {
            s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
        } else if ( s.jsonp !== false ) {
            s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
        }

        // Use data converter to retrieve json after script execution
        s.converters["script json"] = function() {
            if ( !responseContainer ) {
                jQuery.error( callbackName + " was not called" );
            }
            return responseContainer[ 0 ];
        };

        // force json dataType
        s.dataTypes[ 0 ] = "json";

        // Install callback
        overwritten = window[ callbackName ];
        window[ callbackName ] = function() {
            responseContainer = arguments;
        };

        // Clean-up function (fires after converters)
        jqXHR.always(function() {
            // Restore preexisting value
            window[ callbackName ] = overwritten;

            // Save back as free
            if ( s[ callbackName ] ) {
                // make sure that re-using the options doesn't screw things around
                s.jsonpCallback = originalSettings.jsonpCallback;

                // save the callback name for future use
                oldCallbacks.push( callbackName );
            }

            // Call if it was a function and we have a response
            if ( responseContainer && jQuery.isFunction( overwritten ) ) {
                overwritten( responseContainer[ 0 ] );
            }

            responseContainer = overwritten = undefined;
        });

        // Delegate to script
        return "script";
    }
});




// data: string of html
// context (optional): If specified, the fragment will be created in this context, defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
    if ( !data || typeof data !== "string" ) {
        return null;
    }
    if ( typeof context === "boolean" ) {
        keepScripts = context;
        context = false;
    }
    context = context || document;

    var parsed = rsingleTag.exec( data ),
        scripts = !keepScripts && [];

    // Single tag
    if ( parsed ) {
        return [ context.createElement( parsed[1] ) ];
    }

    parsed = jQuery.buildFragment( [ data ], context, scripts );

    if ( scripts && scripts.length ) {
        jQuery( scripts ).remove();
    }

    return jQuery.merge( [], parsed.childNodes );
};


// Keep a copy of the old load method
var _load = jQuery.fn.load;

/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
    if ( typeof url !== "string" && _load ) {
        return _load.apply( this, arguments );
    }

    var selector, response, type,
        self = this,
        off = url.indexOf(" ");

    if ( off >= 0 ) {
        selector = jQuery.trim( url.slice( off, url.length ) );
        url = url.slice( 0, off );
    }

    // If it's a function
    if ( jQuery.isFunction( params ) ) {

        // We assume that it's the callback
        callback = params;
        params = undefined;

    // Otherwise, build a param string
    } else if ( params && typeof params === "object" ) {
        type = "POST";
    }

    // If we have elements to modify, make the request
    if ( self.length > 0 ) {
        jQuery.ajax({
            url: url,

            // if "type" variable is undefined, then "GET" method will be used
            type: type,
            dataType: "html",
            data: params
        }).done(function( responseText ) {

            // Save response for use in complete callback
            response = arguments;

            self.html( selector ?

                // If a selector was specified, locate the right elements in a dummy div
                // Exclude scripts to avoid IE 'Permission Denied' errors
                jQuery("<div>").append( jQuery.parseHTML( responseText ) ).find( selector ) :

                // Otherwise use the full result
                responseText );

        }).complete( callback && function( jqXHR, status ) {
            self.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );
        });
    }

    return this;
};




jQuery.expr.filters.animated = function( elem ) {
    return jQuery.grep(jQuery.timers, function( fn ) {
        return elem === fn.elem;
    }).length;
};





var docElem = window.document.documentElement;

/**
 * Gets a window from an element
 */
function getWindow( elem ) {
    return jQuery.isWindow( elem ) ?
        elem :
        elem.nodeType === 9 ?
            elem.defaultView || elem.parentWindow :
            false;
}

jQuery.offset = {
    setOffset: function( elem, options, i ) {
        var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
            position = jQuery.css( elem, "position" ),
            curElem = jQuery( elem ),
            props = {};

        // set position first, in-case top/left are set even on static elem
        if ( position === "static" ) {
            elem.style.position = "relative";
        }

        curOffset = curElem.offset();
        curCSSTop = jQuery.css( elem, "top" );
        curCSSLeft = jQuery.css( elem, "left" );
        calculatePosition = ( position === "absolute" || position === "fixed" ) &&
            jQuery.inArray("auto", [ curCSSTop, curCSSLeft ] ) > -1;

        // need to be able to calculate position if either top or left is auto and position is either absolute or fixed
        if ( calculatePosition ) {
            curPosition = curElem.position();
            curTop = curPosition.top;
            curLeft = curPosition.left;
        } else {
            curTop = parseFloat( curCSSTop ) || 0;
            curLeft = parseFloat( curCSSLeft ) || 0;
        }

        if ( jQuery.isFunction( options ) ) {
            options = options.call( elem, i, curOffset );
        }

        if ( options.top != null ) {
            props.top = ( options.top - curOffset.top ) + curTop;
        }
        if ( options.left != null ) {
            props.left = ( options.left - curOffset.left ) + curLeft;
        }

        if ( "using" in options ) {
            options.using.call( elem, props );
        } else {
            curElem.css( props );
        }
    }
};

jQuery.fn.extend({
    offset: function( options ) {
        if ( arguments.length ) {
            return options === undefined ?
                this :
                this.each(function( i ) {
                    jQuery.offset.setOffset( this, options, i );
                });
        }

        var docElem, win,
            box = { top: 0, left: 0 },
            elem = this[ 0 ],
            doc = elem && elem.ownerDocument;

        if ( !doc ) {
            return;
        }

        docElem = doc.documentElement;

        // Make sure it's not a disconnected DOM node
        if ( !jQuery.contains( docElem, elem ) ) {
            return box;
        }

        // If we don't have gBCR, just use 0,0 rather than error
        // BlackBerry 5, iOS 3 (original iPhone)
        if ( typeof elem.getBoundingClientRect !== strundefined ) {
            box = elem.getBoundingClientRect();
        }
        win = getWindow( doc );
        return {
            top: box.top  + ( win.pageYOffset || docElem.scrollTop )  - ( docElem.clientTop  || 0 ),
            left: box.left + ( win.pageXOffset || docElem.scrollLeft ) - ( docElem.clientLeft || 0 )
        };
    },

    position: function() {
        if ( !this[ 0 ] ) {
            return;
        }

        var offsetParent, offset,
            parentOffset = { top: 0, left: 0 },
            elem = this[ 0 ];

        // fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is its only offset parent
        if ( jQuery.css( elem, "position" ) === "fixed" ) {
            // we assume that getBoundingClientRect is available when computed position is fixed
            offset = elem.getBoundingClientRect();
        } else {
            // Get *real* offsetParent
            offsetParent = this.offsetParent();

            // Get correct offsets
            offset = this.offset();
            if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
                parentOffset = offsetParent.offset();
            }

            // Add offsetParent borders
            parentOffset.top  += jQuery.css( offsetParent[ 0 ], "borderTopWidth", true );
            parentOffset.left += jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true );
        }

        // Subtract parent offsets and element margins
        // note: when an element has margin: auto the offsetLeft and marginLeft
        // are the same in Safari causing offset.left to incorrectly be 0
        return {
            top:  offset.top  - parentOffset.top - jQuery.css( elem, "marginTop", true ),
            left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true)
        };
    },

    offsetParent: function() {
        return this.map(function() {
            var offsetParent = this.offsetParent || docElem;

            while ( offsetParent && ( !jQuery.nodeName( offsetParent, "html" ) && jQuery.css( offsetParent, "position" ) === "static" ) ) {
                offsetParent = offsetParent.offsetParent;
            }
            return offsetParent || docElem;
        });
    }
});

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
    var top = /Y/.test( prop );

    jQuery.fn[ method ] = function( val ) {
        return access( this, function( elem, method, val ) {
            var win = getWindow( elem );

            if ( val === undefined ) {
                return win ? (prop in win) ? win[ prop ] :
                    win.document.documentElement[ method ] :
                    elem[ method ];
            }

            if ( win ) {
                win.scrollTo(
                    !top ? val : jQuery( win ).scrollLeft(),
                    top ? val : jQuery( win ).scrollTop()
                );

            } else {
                elem[ method ] = val;
            }
        }, method, val, arguments.length, null );
    };
});

// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// getComputedStyle returns percent when specified for top/left/bottom/right
// rather than make the css module depend on the offset module, we just check for it here
jQuery.each( [ "top", "left" ], function( i, prop ) {
    jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
        function( elem, computed ) {
            if ( computed ) {
                computed = curCSS( elem, prop );
                // if curCSS returns percentage, fallback to offset
                return rnumnonpx.test( computed ) ?
                    jQuery( elem ).position()[ prop ] + "px" :
                    computed;
            }
        }
    );
});


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
    jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name }, function( defaultExtra, funcName ) {
        // margin is only for outerHeight, outerWidth
        jQuery.fn[ funcName ] = function( margin, value ) {
            var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
                extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

            return access( this, function( elem, type, value ) {
                var doc;

                if ( jQuery.isWindow( elem ) ) {
                    // As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
                    // isn't a whole lot we can do. See pull request at this URL for discussion:
                    // https://github.com/jquery/jquery/pull/764
                    return elem.document.documentElement[ "client" + name ];
                }

                // Get document width or height
                if ( elem.nodeType === 9 ) {
                    doc = elem.documentElement;

                    // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height], whichever is greatest
                    // unfortunately, this causes bug #3838 in IE6/8 only, but there is currently no good, small way to fix it.
                    return Math.max(
                        elem.body[ "scroll" + name ], doc[ "scroll" + name ],
                        elem.body[ "offset" + name ], doc[ "offset" + name ],
                        doc[ "client" + name ]
                    );
                }

                return value === undefined ?
                    // Get width or height on the element, requesting but not forcing parseFloat
                    jQuery.css( elem, type, extra ) :

                    // Set width or height on the element
                    jQuery.style( elem, type, value, extra );
            }, type, chainable ? margin : undefined, chainable, null );
        };
    });
});


// The number of elements contained in the matched element set
jQuery.fn.size = function() {
    return this.length;
};

jQuery.fn.andSelf = jQuery.fn.addBack;




// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( typeof define === "function" && define.amd ) {
    define( "jquery", [], function() {
        return jQuery;
    });
}




var
    // Map over jQuery in case of overwrite
    _jQuery = window.jQuery,

    // Map over the $ in case of overwrite
    _$ = window.$;

jQuery.noConflict = function( deep ) {
    if ( window.$ === jQuery ) {
        window.$ = _$;
    }

    if ( deep && window.jQuery === jQuery ) {
        window.jQuery = _jQuery;
    }

    return jQuery;
};

// Expose jQuery and $ identifiers, even in
// AMD (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( typeof noGlobal === strundefined ) {
    window.jQuery = window.$ = jQuery;
}




return jQuery;

}));


/* jshint ignore:end */;

/**

	jQuery extensions
	<br />Used for IBM core JS foundation. 
	<br />Extra custom jQuery extensions we've added onto jQuery.

	@class jQuery:focusable
**/
(function($) {
	/**
		This is not a method, but rather a " :focusable" selector extension to jQuery.
		<br />This allows you to find focusable elements for tabbing/accessibility.
		<br />Usage:  $("someContainer :focusable")  gives you a list of $elements that you can do .focus() on.

		@method focusable
	**/
	// Primarily used in overlay for tab rings since content is unknown. 
	function focusable(element, isTabIndexNotNaN) {
		var map, mapName, img,
			nodeName = element.nodeName.toLowerCase();
		if ("area" === nodeName) {
			map = element.parentNode;
			mapName = map.name;
			if (!element.href || !mapName || map.nodeName.toLowerCase() !== "map") {
				return false;
			}
			img = $("img[usemap=#" + mapName + "]")[0];
			return !!img && visible(img);
		}
		return (/input|select|textarea|button|object/.test(nodeName) ?
				!element.disabled :
				"a" === nodeName ?
				element.href || isTabIndexNotNaN :
				isTabIndexNotNaN) &&
			// the element and all of its ancestors must be visible
			visible(element);
	}

	function visible(element) {
		return $.expr.filters.visible(element) &&
			!$(element).parents().addBack().filter(function() {
				return $.css(this, "visibility") === "hidden";
			}).length;
	}

	// This is the actual :focusable extension.
	$.extend($.expr[":"], {
		focusable: function(element) {
			return focusable(element, !isNaN($.attr(element, "tabindex")));
		}
	});
	////
	//  END :focusable selector extension.
	////

})(jQuery);
;

/**

	Browser plug-in script for jQuery. 
	<br />Used for browser detection.
	<br />Official documentation at <a href="http://jquery.thewikies.com/browser" target="_blank">http://jquery.thewikies.com/browser</a>.
	
	@module jQuery.browser
	@main jQuery.browser
	@class jQuery.browser
	@class jQuery.layout
	@class jQuery.os

**/
/*

jQuery Browser Plugin
	* Version 2.3
	* 2008-09-17 19:27:05
	* URL: http://jquery.thewikies.com/browser
	* Description: jQuery Browser Plugin extends browser detection capabilities and can assign browser selectors to CSS classes.
	* Author: Nate Cavanaugh, Minhchau Dang, & Jonathan Neal
	* Copyright: Copyright (c) 2008 Jonathan Neal under dual MIT/GPL license.
	* JSLint: This javascript file passes JSLint verification.
*//*jslint
		bitwise: true,
		browser: true,
		eqeqeq: true,
		forin: true,
		nomen: true,
		plusplus: true,
		undef: true,
		white: true
*//*global
		jQuery
*/

(function ($) {
	$.browserTest = function (a, z) {
		var u = 'unknown', x = 'X', m = function (r, h) {
			for (var i = 0; i < h.length; i = i + 1) {
				r = r.replace(h[i][0], h[i][1]);
			}

			return r;
		}, c = function (i, a, b, c) {
			var r = {
				name: m((a.exec(i) || [u, u])[1], b)
			};

			r[r.name] = true;

			r.version = (c.exec(i) || [x, x, x, x])[3];

			if (r.name.match(/safari/) && r.version > 400) {
				r.version = '2.0';
			}

			if (r.name === 'presto') {
				r.version = ($.browser.version > 9.27) ? 'futhark' : 'linear_b';
			}
			r.versionNumber = parseFloat(r.version, 10) || 0;
			r.versionX = (r.version !== x) ? (r.version + '').substr(0, 1) : x;
			r.className = r.name + r.versionX;

			return r;
		};

		a = (a.match(/Opera|Navigator|Minefield|KHTML|Chrome/) ? m(a, [
			[/(Firefox|MSIE|KHTML,\slike\sGecko|Konqueror)/, ''],
			['Chrome Safari', 'Chrome'],
			['KHTML', 'Konqueror'],
			['Minefield', 'Firefox'],
			['Navigator', 'Netscape']
		]) : a).toLowerCase();

		$.browser = $.extend((!z) ? $.browser : {}, c(a, /(camino|chrome|firefox|netscape|konqueror|lynx|msie|opera|safari)/, [], /(camino|chrome|firefox|netscape|netscape6|opera|version|konqueror|lynx|msie|safari)(\/|\s)([a-z0-9\.\+]*?)(\;|dev|rel|\s|$)/));

		$.layout = c(a, /(gecko|konqueror|msie|opera|webkit)/, [
			['konqueror', 'khtml'],
			['msie', 'trident'],
			['opera', 'presto']
		], /(applewebkit|rv|konqueror|msie)(\:|\/|\s)([a-z0-9\.]*?)(\;|\)|\s)/);

		$.os = {
			name: (/(win|mac|linux|sunos|solaris|iphone)/.exec(navigator.platform.toLowerCase()) || [u])[0].replace('sunos', 'solaris')
		};

		if (!z) {
			$('html').addClass([$.os.name, $.browser.name, $.browser.className, $.layout.name, $.layout.className].join(' '));
		}
	};

	$.browserTest(navigator.userAgent);
})(jQuery);;

/**
	
	Slick carousel plug-in script for jQuery.
	<br />Used for IBM carousel widgets.
	<br />Official documentation at <a href="http://kenwheeler.github.io/slick" target="_blank">http://kenwheeler.github.io/slick</a>.

	@module jQuery.slick
	@main jQuery.slick
	@class jQuery.fn.slick

**/
/*
     _ _      _       _
 ___| (_) ___| | __  (_)___
/ __| | |/ __| |/ /  | / __|
\__ \ | | (__|   < _ | \__ \
|___/_|_|\___|_|\_(_)/ |___/
                   |__/

 Version: 1.5.0
  Author: Ken Wheeler
 Website: http://kenwheeler.github.io
    Docs: http://kenwheeler.github.io/slick
    Repo: http://github.com/kenwheeler/slick
  Issues: http://github.com/kenwheeler/slick/issues

 */
/* global window, document, define, jQuery, setInterval, clearInterval */
(function(factory) {
    'use strict';
    if (typeof define === 'function' && define.amd) {
        define(['jquery'], factory);
    } else if (typeof exports !== 'undefined') {
        module.exports = factory(require('jquery'));
    } else {
        factory(jQuery);
    }

}(function($) {
    'use strict';
    var Slick = window.Slick || {};

    Slick = (function() {

        var instanceUid = 0;

        function Slick(element, settings) {

            var _ = this,
                dataSettings, responsiveSettings, breakpoint;

            _.defaults = {
                accessibility: true,
                adaptiveHeight: false,
                appendArrows: $(element),
                appendDots: $(element),
                arrows: true,
                asNavFor: null,
                prevArrow: '<button type="button" data-role="none" class="slick-prev" aria-label="previous">Previous</button>',
                nextArrow: '<button type="button" data-role="none" class="slick-next" aria-label="next">Next</button>',
                autoplay: false,
                autoplaySpeed: 3000,
                centerMode: false,
                centerPadding: '50px',
                cssEase: 'ease',
                customPaging: function(slider, i) {
                    return '<button type="button" data-role="none">' + (i + 1) + '</button>';
                },
                dots: false,
                dotsClass: 'slick-dots',
                draggable: true,
                easing: 'linear',
                edgeFriction: 0.35,
                fade: false,
                focusOnSelect: false,
                infinite: true,
                initialSlide: 0,
                lazyLoad: 'ondemand',
                mobileFirst: false,
                pauseOnHover: true,
                pauseOnDotsHover: false,
                respondTo: 'window',
                responsive: null,
                rows: 1,
                rtl: false,
                slide: '',
                slidesPerRow: 1,
                slidesToShow: 1,
                slidesToScroll: 1,
                speed: 500,
                swipe: true,
                swipeToSlide: false,
                touchMove: true,
                touchThreshold: 5,
                useCSS: true,
                variableWidth: false,
                vertical: false,
                verticalSwiping: false,
                waitForAnimate: true
            };

            _.initials = {
                animating: false,
                dragging: false,
                autoPlayTimer: null,
                currentDirection: 0,
                currentLeft: null,
                currentSlide: 0,
                direction: 1,
                $dots: null,
                listWidth: null,
                listHeight: null,
                loadIndex: 0,
                $nextArrow: null,
                $prevArrow: null,
                slideCount: null,
                slideWidth: null,
                $slideTrack: null,
                $slides: null,
                sliding: false,
                slideOffset: 0,
                swipeLeft: null,
                $list: null,
                touchObject: {},
                transformsEnabled: false
            };

            $.extend(_, _.initials);

            _.activeBreakpoint = null;
            _.animType = null;
            _.animProp = null;
            _.breakpoints = [];
            _.breakpointSettings = [];
            _.cssTransitions = false;
            _.hidden = 'hidden';
            _.paused = false;
            _.positionProp = null;
            _.respondTo = null;
            _.rowCount = 1;
            _.shouldClick = true;
            _.$slider = $(element);
            _.$slidesCache = null;
            _.transformType = null;
            _.transitionType = null;
            _.visibilityChange = 'visibilitychange';
            _.windowWidth = 0;
            _.windowTimer = null;

            dataSettings = $(element).data('slick') || {};

            _.options = $.extend({}, _.defaults, dataSettings, settings);

            _.currentSlide = _.options.initialSlide;

            _.originalSettings = _.options;
            responsiveSettings = _.options.responsive || null;

            if (responsiveSettings && responsiveSettings.length > -1) {
                _.respondTo = _.options.respondTo || 'window';
                for (breakpoint in responsiveSettings) {
                    if (responsiveSettings.hasOwnProperty(breakpoint)) {
                        _.breakpoints.push(responsiveSettings[
                            breakpoint].breakpoint);
                        _.breakpointSettings[responsiveSettings[
                                breakpoint].breakpoint] =
                            responsiveSettings[breakpoint].settings;
                    }
                }
                _.breakpoints.sort(function(a, b) {
                    if (_.options.mobileFirst === true) {
                        return a - b;
                    } else {
                        return b - a;
                    }
                });
            }

            if (typeof document.mozHidden !== 'undefined') {
                _.hidden = 'mozHidden';
                _.visibilityChange = 'mozvisibilitychange';
            } else if (typeof document.msHidden !== 'undefined') {
                _.hidden = 'msHidden';
                _.visibilityChange = 'msvisibilitychange';
            } else if (typeof document.webkitHidden !== 'undefined') {
                _.hidden = 'webkitHidden';
                _.visibilityChange = 'webkitvisibilitychange';
            }

            _.autoPlay = $.proxy(_.autoPlay, _);
            _.autoPlayClear = $.proxy(_.autoPlayClear, _);
            _.changeSlide = $.proxy(_.changeSlide, _);
            _.clickHandler = $.proxy(_.clickHandler, _);
            _.selectHandler = $.proxy(_.selectHandler, _);
            _.setPosition = $.proxy(_.setPosition, _);
            _.swipeHandler = $.proxy(_.swipeHandler, _);
            _.dragHandler = $.proxy(_.dragHandler, _);
            _.keyHandler = $.proxy(_.keyHandler, _);
            _.autoPlayIterator = $.proxy(_.autoPlayIterator, _);

            _.instanceUid = instanceUid++;

            // A simple way to check for HTML strings
            // Strict HTML recognition (must start with <)
            // Extracted from jQuery v1.11 source
            _.htmlExpr = /^(?:\s*(<[\w\W]+>)[^>]*)$/;

            _.init();

            _.checkResponsive(true);

        }

        return Slick;

    }());

    Slick.prototype.addSlide = Slick.prototype.slickAdd = function(markup, index, addBefore) {

        var _ = this;

        if (typeof(index) === 'boolean') {
            addBefore = index;
            index = null;
        } else if (index < 0 || (index >= _.slideCount)) {
            return false;
        }

        _.unload();

        if (typeof(index) === 'number') {
            if (index === 0 && _.$slides.length === 0) {
                $(markup).appendTo(_.$slideTrack);
            } else if (addBefore) {
                $(markup).insertBefore(_.$slides.eq(index));
            } else {
                $(markup).insertAfter(_.$slides.eq(index));
            }
        } else {
            if (addBefore === true) {
                $(markup).prependTo(_.$slideTrack);
            } else {
                $(markup).appendTo(_.$slideTrack);
            }
        }

        _.$slides = _.$slideTrack.children(this.options.slide);

        _.$slideTrack.children(this.options.slide).detach();

        _.$slideTrack.append(_.$slides);

        _.$slides.each(function(index, element) {
            $(element).attr('data-slick-index', index);
        });

        _.$slidesCache = _.$slides;

        _.reinit();

    };

    Slick.prototype.animateHeight = function() {
        var _ = this;
        if (_.options.slidesToShow === 1 && _.options.adaptiveHeight === true && _.options.vertical === false) {
            var targetHeight = _.$slides.eq(_.currentSlide).outerHeight(true);
            _.$list.animate({
                height: targetHeight
            }, _.options.speed);
        }
    };

    Slick.prototype.animateSlide = function(targetLeft, callback) {

        var animProps = {},
            _ = this;

        _.animateHeight();

        if (_.options.rtl === true && _.options.vertical === false) {
            targetLeft = -targetLeft;
        }
        if (_.transformsEnabled === false) {
            if (_.options.vertical === false) {
                _.$slideTrack.animate({
                    left: targetLeft
                }, _.options.speed, _.options.easing, callback);
            } else {
                _.$slideTrack.animate({
                    top: targetLeft
                }, _.options.speed, _.options.easing, callback);
            }

        } else {

            if (_.cssTransitions === false) {
                if (_.options.rtl === true) {
                    _.currentLeft = -(_.currentLeft);
                }
                $({
                    animStart: _.currentLeft
                }).animate({
                    animStart: targetLeft
                }, {
                    duration: _.options.speed,
                    easing: _.options.easing,
                    step: function(now) {
                        now = Math.ceil(now);
                        if (_.options.vertical === false) {
                            animProps[_.animType] = 'translate(' +
                                now + 'px, 0px)';
                            _.$slideTrack.css(animProps);
                        } else {
                            animProps[_.animType] = 'translate(0px,' +
                                now + 'px)';
                            _.$slideTrack.css(animProps);
                        }
                    },
                    complete: function() {
                        if (callback) {
                            callback.call();
                        }
                    }
                });

            } else {

                _.applyTransition();
                targetLeft = Math.ceil(targetLeft);

                if (_.options.vertical === false) {
                    animProps[_.animType] = 'translate3d(' + targetLeft + 'px, 0px, 0px)';
                } else {
                    animProps[_.animType] = 'translate3d(0px,' + targetLeft + 'px, 0px)';
                }
                _.$slideTrack.css(animProps);

                if (callback) {
                    setTimeout(function() {

                        _.disableTransition();

                        callback.call();
                    }, _.options.speed);
                }

            }

        }

    };

    Slick.prototype.asNavFor = function(index) {
        var _ = this,
            asNavFor = _.options.asNavFor !== null ? $(_.options.asNavFor).slick('getSlick') : null;
        if (asNavFor !== null) asNavFor.slideHandler(index, true);
    };

    Slick.prototype.applyTransition = function(slide) {

        var _ = this,
            transition = {};

        if (_.options.fade === false) {
            transition[_.transitionType] = _.transformType + ' ' + _.options.speed + 'ms ' + _.options.cssEase;
        } else {
            transition[_.transitionType] = 'opacity ' + _.options.speed + 'ms ' + _.options.cssEase;
        }

        if (_.options.fade === false) {
            _.$slideTrack.css(transition);
        } else {
            _.$slides.eq(slide).css(transition);
        }

    };

    Slick.prototype.autoPlay = function() {

        var _ = this;

        if (_.autoPlayTimer) {
            clearInterval(_.autoPlayTimer);
        }

        if (_.slideCount > _.options.slidesToShow && _.paused !== true) {
            _.autoPlayTimer = setInterval(_.autoPlayIterator,
                _.options.autoplaySpeed);
        }

    };

    Slick.prototype.autoPlayClear = function() {

        var _ = this;
        if (_.autoPlayTimer) {
            clearInterval(_.autoPlayTimer);
        }

    };

    Slick.prototype.autoPlayIterator = function() {

        var _ = this;

        if (_.options.infinite === false) {

            if (_.direction === 1) {

                if ((_.currentSlide + 1) === _.slideCount -
                    1) {
                    _.direction = 0;
                }

                _.slideHandler(_.currentSlide + _.options.slidesToScroll);

            } else {

                if ((_.currentSlide - 1 === 0)) {

                    _.direction = 1;

                }

                _.slideHandler(_.currentSlide - _.options.slidesToScroll);

            }

        } else {

            _.slideHandler(_.currentSlide + _.options.slidesToScroll);

        }

    };

    Slick.prototype.buildArrows = function() {

        var _ = this;

        if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {

            _.$prevArrow = $(_.options.prevArrow);
            _.$nextArrow = $(_.options.nextArrow);

            if (_.htmlExpr.test(_.options.prevArrow)) {
                _.$prevArrow.appendTo(_.options.appendArrows);
            }

            if (_.htmlExpr.test(_.options.nextArrow)) {
                _.$nextArrow.appendTo(_.options.appendArrows);
            }

            if (_.options.infinite !== true) {
                _.$prevArrow.addClass('slick-disabled');
            }

        }

    };

    Slick.prototype.buildDots = function() {

        var _ = this,
            i, dotString;

        if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {

            dotString = '<ul class="' + _.options.dotsClass + '">';

            for (i = 0; i <= _.getDotCount(); i += 1) {
                dotString += '<li>' + _.options.customPaging.call(this, _, i) + '</li>';
            }

            dotString += '</ul>';

            _.$dots = $(dotString).appendTo(
                _.options.appendDots);

            _.$dots.find('li').first().addClass('slick-active').attr('aria-hidden', 'false');

        }

    };

    Slick.prototype.buildOut = function() {

        var _ = this;

        _.$slides = _.$slider.children(
            ':not(.slick-cloned)').addClass(
            'slick-slide');
        _.slideCount = _.$slides.length;

        _.$slides.each(function(index, element) {
            $(element).attr('data-slick-index', index);
        });

        _.$slidesCache = _.$slides;

        _.$slider.addClass('slick-slider');

        _.$slideTrack = (_.slideCount === 0) ?
            $('<div class="slick-track"/>').appendTo(_.$slider) :
            _.$slides.wrapAll('<div class="slick-track"/>').parent();

        _.$list = _.$slideTrack.wrap(
            '<div aria-live="polite" class="slick-list"/>').parent();
        _.$slideTrack.css('opacity', 0);

        if (_.options.centerMode === true || _.options.swipeToSlide === true) {
            _.options.slidesToScroll = 1;
        }

        $('img[data-lazy]', _.$slider).not('[src]').addClass('slick-loading');

        _.setupInfinite();

        _.buildArrows();

        _.buildDots();

        _.updateDots();

        if (_.options.accessibility === true) {
            _.$list.prop('tabIndex', 0);
        }

        _.setSlideClasses(typeof this.currentSlide === 'number' ? this.currentSlide : 0);

        if (_.options.draggable === true) {
            _.$list.addClass('draggable');
        }

    };

    Slick.prototype.buildRows = function() {

        var _ = this, a, b, c, newSlides, numOfSlides, originalSlides,slidesPerSection;

        newSlides = document.createDocumentFragment();
        originalSlides = _.$slider.children();

        if(_.options.rows > 1) {
            slidesPerSection = _.options.slidesPerRow * _.options.rows;
            numOfSlides = Math.ceil(
                originalSlides.length / slidesPerSection
            );

            for(a = 0; a < numOfSlides; a++){
                var slide = document.createElement('div');
                for(b = 0; b < _.options.rows; b++) {
                    var row = document.createElement('div');
                    for(c = 0; c < _.options.slidesPerRow; c++) {
                        var target = (a * slidesPerSection + ((b * _.options.slidesPerRow) + c));
                        if (originalSlides.get(target)) {
                            row.appendChild(originalSlides.get(target));
                        }
                    }
                    slide.appendChild(row);
                }
                newSlides.appendChild(slide);
            };
            _.$slider.html(newSlides);
            _.$slider.children().children().children()
                .width((100 / _.options.slidesPerRow) + "%")
                .css({'display': 'inline-block'});
        };

    };

    Slick.prototype.checkResponsive = function(initial) {

        var _ = this,
            breakpoint, targetBreakpoint, respondToWidth;
        var sliderWidth = _.$slider.width();
        var windowWidth = window.innerWidth || $(window).width();
        if (_.respondTo === 'window') {
            respondToWidth = windowWidth;
        } else if (_.respondTo === 'slider') {
            respondToWidth = sliderWidth;
        } else if (_.respondTo === 'min') {
            respondToWidth = Math.min(windowWidth, sliderWidth);
        }

        if (_.originalSettings.responsive && _.originalSettings
            .responsive.length > -1 && _.originalSettings.responsive !== null) {

            targetBreakpoint = null;

            for (breakpoint in _.breakpoints) {
                if (_.breakpoints.hasOwnProperty(breakpoint)) {
                    if (_.originalSettings.mobileFirst === false) {
                        if (respondToWidth < _.breakpoints[breakpoint]) {
                            targetBreakpoint = _.breakpoints[breakpoint];
                        }
                    } else {
                        if (respondToWidth > _.breakpoints[breakpoint]) {
                            targetBreakpoint = _.breakpoints[breakpoint];
                        }
                    }
                }
            }

            if (targetBreakpoint !== null) {
                if (_.activeBreakpoint !== null) {
                    if (targetBreakpoint !== _.activeBreakpoint) {
                        _.activeBreakpoint =
                            targetBreakpoint;
                        if (_.breakpointSettings[targetBreakpoint] === 'unslick') {
                            _.unslick();
                        } else {
                            _.options = $.extend({}, _.originalSettings,
                                _.breakpointSettings[
                                    targetBreakpoint]);
                            if (initial === true)
                                _.currentSlide = _.options.initialSlide;
                            _.refresh();
                        }
                    }
                } else {
                    _.activeBreakpoint = targetBreakpoint;
                    if (_.breakpointSettings[targetBreakpoint] === 'unslick') {
                        _.unslick();
                    } else {
                        _.options = $.extend({}, _.originalSettings,
                            _.breakpointSettings[
                                targetBreakpoint]);
                        if (initial === true)
                            _.currentSlide = _.options.initialSlide;
                        _.refresh();
                    }
                }
            } else {
                if (_.activeBreakpoint !== null) {
                    _.activeBreakpoint = null;
                    _.options = _.originalSettings;
                    if (initial === true)
                        _.currentSlide = _.options.initialSlide;
                    _.refresh();
                }
            }

        }

    };

    Slick.prototype.changeSlide = function(event, dontAnimate) {

        var _ = this,
            $target = $(event.target),
            indexOffset, slideOffset, unevenOffset;

        // If target is a link, prevent default action.
        $target.is('a') && event.preventDefault();

        unevenOffset = (_.slideCount % _.options.slidesToScroll !== 0);
        indexOffset = unevenOffset ? 0 : (_.slideCount - _.currentSlide) % _.options.slidesToScroll;

        switch (event.data.message) {

            case 'previous':
                slideOffset = indexOffset === 0 ? _.options.slidesToScroll : _.options.slidesToShow - indexOffset;
                if (_.slideCount > _.options.slidesToShow) {
                    _.slideHandler(_.currentSlide - slideOffset, false, dontAnimate);
                }
                break;

            case 'next':
                slideOffset = indexOffset === 0 ? _.options.slidesToScroll : indexOffset;
                if (_.slideCount > _.options.slidesToShow) {
                    _.slideHandler(_.currentSlide + slideOffset, false, dontAnimate);
                }
                break;

            case 'index':
                var index = event.data.index === 0 ? 0 :
                    event.data.index || $(event.target).parent().index() * _.options.slidesToScroll;

                _.slideHandler(_.checkNavigable(index), false, dontAnimate);
                break;

            default:
                return;
        }

    };

    Slick.prototype.checkNavigable = function(index) {

        var _ = this,
            navigables, prevNavigable;

        navigables = _.getNavigableIndexes();
        prevNavigable = 0;
        if (index > navigables[navigables.length - 1]) {
            index = navigables[navigables.length - 1];
        } else {
            for (var n in navigables) {
                if (index < navigables[n]) {
                    index = prevNavigable;
                    break;
                }
                prevNavigable = navigables[n];
            }
        }

        return index;
    };

    Slick.prototype.cleanUpEvents = function() {

        var _ = this;

        if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {
            $('li', _.$dots).off('click.slick', _.changeSlide);
        }

        if (_.options.dots === true && _.options.pauseOnDotsHover === true && _.options.autoplay === true) {
            $('li', _.$dots)
                .off('mouseenter.slick', _.setPaused.bind(_, true))
                .off('mouseleave.slick', _.setPaused.bind(_, false));
        }

        if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {
            _.$prevArrow && _.$prevArrow.off('click.slick', _.changeSlide);
            _.$nextArrow && _.$nextArrow.off('click.slick', _.changeSlide);
        }

        _.$list.off('touchstart.slick mousedown.slick', _.swipeHandler);
        _.$list.off('touchmove.slick mousemove.slick', _.swipeHandler);
        _.$list.off('touchend.slick mouseup.slick', _.swipeHandler);
        _.$list.off('touchcancel.slick mouseleave.slick', _.swipeHandler);

        _.$list.off('click.slick', _.clickHandler);

        if (_.options.autoplay === true) {
            $(document).off(_.visibilityChange, _.visibility);
        }

        _.$list.off('mouseenter.slick', _.setPaused.bind(_, true));
        _.$list.off('mouseleave.slick', _.setPaused.bind(_, false));

        if (_.options.accessibility === true) {
            _.$list.off('keydown.slick', _.keyHandler);
        }

        if (_.options.focusOnSelect === true) {
            $(_.$slideTrack).children().off('click.slick', _.selectHandler);
        }

        $(window).off('orientationchange.slick.slick-' + _.instanceUid, _.orientationChange);

        $(window).off('resize.slick.slick-' + _.instanceUid, _.resize);

        $('[draggable!=true]', _.$slideTrack).off('dragstart', _.preventDefault);

        $(window).off('load.slick.slick-' + _.instanceUid, _.setPosition);
        $(document).off('ready.slick.slick-' + _.instanceUid, _.setPosition);
    };

    Slick.prototype.cleanUpRows = function() {

        var _ = this, originalSlides;

        if(_.options.rows > 1) {
            originalSlides = _.$slides.children().children();
            originalSlides.removeAttr('style');
            _.$slider.html(originalSlides);
        }

    };

    Slick.prototype.clickHandler = function(event) {

        var _ = this;

        if (_.shouldClick === false) {
            event.stopImmediatePropagation();
            event.stopPropagation();
            event.preventDefault();
        }

    };

    Slick.prototype.destroy = function() {

        var _ = this;

        _.autoPlayClear();

        _.touchObject = {};

        _.cleanUpEvents();

        $('.slick-cloned', _.$slider).remove();

        if (_.$dots) {
            _.$dots.remove();
        }
        if (_.$prevArrow && (typeof _.options.prevArrow !== 'object')) {
            _.$prevArrow.remove();
        }
        if (_.$nextArrow && (typeof _.options.nextArrow !== 'object')) {
            _.$nextArrow.remove();
        }

        if (_.$slides) {
            _.$slides.removeClass('slick-slide slick-active slick-center slick-visible')
                .attr('aria-hidden', 'true')
                .removeAttr('data-slick-index')
                .css({
                    position: '',
                    left: '',
                    top: '',
                    zIndex: '',
                    opacity: '',
                    width: ''
                });

            _.$slider.html(_.$slides);
        }

        _.cleanUpRows();

        _.$slider.removeClass('slick-slider');
        _.$slider.removeClass('slick-initialized');

    };

    Slick.prototype.disableTransition = function(slide) {

        var _ = this,
            transition = {};

        transition[_.transitionType] = '';

        if (_.options.fade === false) {
            _.$slideTrack.css(transition);
        } else {
            _.$slides.eq(slide).css(transition);
        }

    };

    Slick.prototype.fadeSlide = function(slideIndex, callback) {

        var _ = this;

        if (_.cssTransitions === false) {

            _.$slides.eq(slideIndex).css({
                zIndex: 1000
            });

            _.$slides.eq(slideIndex).animate({
                opacity: 1
            }, _.options.speed, _.options.easing, callback);

        } else {

            _.applyTransition(slideIndex);

            _.$slides.eq(slideIndex).css({
                opacity: 1,
                zIndex: 1000
            });

            if (callback) {
                setTimeout(function() {

                    _.disableTransition(slideIndex);

                    callback.call();
                }, _.options.speed);
            }

        }

    };

    Slick.prototype.filterSlides = Slick.prototype.slickFilter = function(filter) {

        var _ = this;

        if (filter !== null) {

            _.unload();

            _.$slideTrack.children(this.options.slide).detach();

            _.$slidesCache.filter(filter).appendTo(_.$slideTrack);

            _.reinit();

        }

    };

    Slick.prototype.getCurrent = Slick.prototype.slickCurrentSlide = function() {

        var _ = this;
        return _.currentSlide;

    };

    Slick.prototype.getDotCount = function() {

        var _ = this;

        var breakPoint = 0;
        var counter = 0;
        var pagerQty = 0;

        if (_.options.infinite === true) {
            pagerQty = Math.ceil(_.slideCount / _.options.slidesToScroll);
        } else if (_.options.centerMode === true) {
            pagerQty = _.slideCount;
        } else {
            while (breakPoint < _.slideCount) {
                ++pagerQty;
                breakPoint = counter + _.options.slidesToShow;
                counter += _.options.slidesToScroll <= _.options.slidesToShow ? _.options.slidesToScroll : _.options.slidesToShow;
            }
        }

        return pagerQty - 1;

    };

    Slick.prototype.getLeft = function(slideIndex) {

        var _ = this,
            targetLeft,
            verticalHeight,
            verticalOffset = 0,
            targetSlide;

        _.slideOffset = 0;
        verticalHeight = _.$slides.first().outerHeight();

        if (_.options.infinite === true) {
            if (_.slideCount > _.options.slidesToShow) {
                _.slideOffset = (_.slideWidth * _.options.slidesToShow) * -1;
                verticalOffset = (verticalHeight * _.options.slidesToShow) * -1;
            }
            if (_.slideCount % _.options.slidesToScroll !== 0) {
                if (slideIndex + _.options.slidesToScroll > _.slideCount && _.slideCount > _.options.slidesToShow) {
                    if (slideIndex > _.slideCount) {
                        _.slideOffset = ((_.options.slidesToShow - (slideIndex - _.slideCount)) * _.slideWidth) * -1;
                        verticalOffset = ((_.options.slidesToShow - (slideIndex - _.slideCount)) * verticalHeight) * -1;
                    } else {
                        _.slideOffset = ((_.slideCount % _.options.slidesToScroll) * _.slideWidth) * -1;
                        verticalOffset = ((_.slideCount % _.options.slidesToScroll) * verticalHeight) * -1;
                    }
                }
            }
        } else {
            if (slideIndex + _.options.slidesToShow > _.slideCount) {
                _.slideOffset = ((slideIndex + _.options.slidesToShow) - _.slideCount) * _.slideWidth;
                verticalOffset = ((slideIndex + _.options.slidesToShow) - _.slideCount) * verticalHeight;
            }
        }

        if (_.slideCount <= _.options.slidesToShow) {
            _.slideOffset = 0;
            verticalOffset = 0;
        }

        if (_.options.centerMode === true && _.options.infinite === true) {
            _.slideOffset += _.slideWidth * Math.floor(_.options.slidesToShow / 2) - _.slideWidth;
        } else if (_.options.centerMode === true) {
            _.slideOffset = 0;
            _.slideOffset += _.slideWidth * Math.floor(_.options.slidesToShow / 2);
        }

        if (_.options.vertical === false) {
            targetLeft = ((slideIndex * _.slideWidth) * -1) + _.slideOffset;
        } else {
            targetLeft = ((slideIndex * verticalHeight) * -1) + verticalOffset;
        }

        if (_.options.variableWidth === true) {

            if (_.slideCount <= _.options.slidesToShow || _.options.infinite === false) {
                targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex);
            } else {
                targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex + _.options.slidesToShow);
            }

            targetLeft = targetSlide[0] ? targetSlide[0].offsetLeft * -1 : 0;

            if (_.options.centerMode === true) {
                if (_.options.infinite === false) {
                    targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex);
                } else {
                    targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex + _.options.slidesToShow + 1);
                }
                targetLeft = targetSlide[0] ? targetSlide[0].offsetLeft * -1 : 0;
                targetLeft += (_.$list.width() - targetSlide.outerWidth()) / 2;
            }
        }

        return targetLeft;

    };

    Slick.prototype.getOption = Slick.prototype.slickGetOption = function(option) {

        var _ = this;

        return _.options[option];

    };

    Slick.prototype.getNavigableIndexes = function() {

        var _ = this,
            breakPoint = 0,
            counter = 0,
            indexes = [],
            max;

        if (_.options.infinite === false) {
            max = _.slideCount - _.options.slidesToShow + 1;
            if (_.options.centerMode === true) max = _.slideCount;
        } else {
            breakPoint = _.options.slidesToScroll * -1;
            counter = _.options.slidesToScroll * -1;
            max = _.slideCount * 2;
        }

        while (breakPoint < max) {
            indexes.push(breakPoint);
            breakPoint = counter + _.options.slidesToScroll;
            counter += _.options.slidesToScroll <= _.options.slidesToShow ? _.options.slidesToScroll : _.options.slidesToShow;
        }

        return indexes;

    };

    Slick.prototype.getSlick = function() {

        return this;

    };

    Slick.prototype.getSlideCount = function() {

        var _ = this,
            slidesTraversed, swipedSlide, centerOffset;

        centerOffset = _.options.centerMode === true ? _.slideWidth * Math.floor(_.options.slidesToShow / 2) : 0;

        if (_.options.swipeToSlide === true) {
            _.$slideTrack.find('.slick-slide').each(function(index, slide) {
                if (slide.offsetLeft - centerOffset + ($(slide).outerWidth() / 2) > (_.swipeLeft * -1)) {
                    swipedSlide = slide;
                    return false;
                }
            });

            slidesTraversed = Math.abs($(swipedSlide).attr('data-slick-index') - _.currentSlide) || 1;

            return slidesTraversed;

        } else {
            return _.options.slidesToScroll;
        }

    };

    Slick.prototype.goTo = Slick.prototype.slickGoTo = function(slide, dontAnimate) {

        var _ = this;

        _.changeSlide({
            data: {
                message: 'index',
                index: parseInt(slide)
            }
        }, dontAnimate);

    };

    Slick.prototype.init = function() {

        var _ = this;

        if (!$(_.$slider).hasClass('slick-initialized')) {

            $(_.$slider).addClass('slick-initialized');
            _.buildRows();
            _.buildOut();
            _.setProps();
            _.startLoad();
            _.loadSlider();
            _.initializeEvents();
            _.updateArrows();
            _.updateDots();
        }

        _.$slider.trigger('init', [_]);

    };

    Slick.prototype.initArrowEvents = function() {

        var _ = this;

        if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {
            _.$prevArrow.on('click.slick', {
                message: 'previous'
            }, _.changeSlide);
            _.$nextArrow.on('click.slick', {
                message: 'next'
            }, _.changeSlide);
        }

    };

    Slick.prototype.initDotEvents = function() {

        var _ = this;

        if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {
            $('li', _.$dots).on('click.slick', {
                message: 'index'
            }, _.changeSlide);
        }

        if (_.options.dots === true && _.options.pauseOnDotsHover === true && _.options.autoplay === true) {
            $('li', _.$dots)
                .on('mouseenter.slick', _.setPaused.bind(_, true))
                .on('mouseleave.slick', _.setPaused.bind(_, false));
        }

    };

    Slick.prototype.initializeEvents = function() {

        var _ = this;

        _.initArrowEvents();

        _.initDotEvents();

        _.$list.on('touchstart.slick mousedown.slick', {
            action: 'start'
        }, _.swipeHandler);
        _.$list.on('touchmove.slick mousemove.slick', {
            action: 'move'
        }, _.swipeHandler);
        _.$list.on('touchend.slick mouseup.slick', {
            action: 'end'
        }, _.swipeHandler);
        _.$list.on('touchcancel.slick mouseleave.slick', {
            action: 'end'
        }, _.swipeHandler);

        _.$list.on('click.slick', _.clickHandler);

        if (_.options.autoplay === true) {
            $(document).on(_.visibilityChange, _.visibility.bind(_));
        }

        _.$list.on('mouseenter.slick', _.setPaused.bind(_, true));
        _.$list.on('mouseleave.slick', _.setPaused.bind(_, false));

        if (_.options.accessibility === true) {
            _.$list.on('keydown.slick', _.keyHandler);
        }

        if (_.options.focusOnSelect === true) {
            $(_.$slideTrack).children().on('click.slick', _.selectHandler);
        }

        $(window).on('orientationchange.slick.slick-' + _.instanceUid, _.orientationChange.bind(_));

        $(window).on('resize.slick.slick-' + _.instanceUid, _.resize.bind(_));

        $('[draggable!=true]', _.$slideTrack).on('dragstart', _.preventDefault);

        $(window).on('load.slick.slick-' + _.instanceUid, _.setPosition);
        $(document).on('ready.slick.slick-' + _.instanceUid, _.setPosition);

    };

    Slick.prototype.initUI = function() {

        var _ = this;

        if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {

            _.$prevArrow.show();
            _.$nextArrow.show();

        }

        if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {

            _.$dots.show();

        }

        if (_.options.autoplay === true) {

            _.autoPlay();

        }

    };

    Slick.prototype.keyHandler = function(event) {

        var _ = this;

        if (event.keyCode === 37 && _.options.accessibility === true) {
            _.changeSlide({
                data: {
                    message: 'previous'
                }
            });
        } else if (event.keyCode === 39 && _.options.accessibility === true) {
            _.changeSlide({
                data: {
                    message: 'next'
                }
            });
        }

    };

    Slick.prototype.lazyLoad = function() {

        var _ = this,
            loadRange, cloneRange, rangeStart, rangeEnd;

        function loadImages(imagesScope) {
            $('img[data-lazy]', imagesScope).each(function() {
                var image = $(this),
                    imageSource = $(this).attr('data-lazy'),
                    imageToLoad = document.createElement('img');

                imageToLoad.onload = function() {
                    image.animate({
                        opacity: 1
                    }, 200);
                };
                imageToLoad.src = imageSource;

                image
                    .css({
                        opacity: 0
                    })
                    .attr('src', imageSource)
                    .removeAttr('data-lazy')
                    .removeClass('slick-loading');
            });
        }

        if (_.options.centerMode === true) {
            if (_.options.infinite === true) {
                rangeStart = _.currentSlide + (_.options.slidesToShow / 2 + 1);
                rangeEnd = rangeStart + _.options.slidesToShow + 2;
            } else {
                rangeStart = Math.max(0, _.currentSlide - (_.options.slidesToShow / 2 + 1));
                rangeEnd = 2 + (_.options.slidesToShow / 2 + 1) + _.currentSlide;
            }
        } else {
            rangeStart = _.options.infinite ? _.options.slidesToShow + _.currentSlide : _.currentSlide;
            rangeEnd = rangeStart + _.options.slidesToShow;
            if (_.options.fade === true) {
                if (rangeStart > 0) rangeStart--;
                if (rangeEnd <= _.slideCount) rangeEnd++;
            }
        }

        loadRange = _.$slider.find('.slick-slide').slice(rangeStart, rangeEnd);
        loadImages(loadRange);

        if (_.slideCount <= _.options.slidesToShow) {
            cloneRange = _.$slider.find('.slick-slide');
            loadImages(cloneRange);
        } else
        if (_.currentSlide >= _.slideCount - _.options.slidesToShow) {
            cloneRange = _.$slider.find('.slick-cloned').slice(0, _.options.slidesToShow);
            loadImages(cloneRange);
        } else if (_.currentSlide === 0) {
            cloneRange = _.$slider.find('.slick-cloned').slice(_.options.slidesToShow * -1);
            loadImages(cloneRange);
        }

    };

    Slick.prototype.loadSlider = function() {

        var _ = this;

        _.setPosition();

        _.$slideTrack.css({
            opacity: 1
        });

        _.$slider.removeClass('slick-loading');

        _.initUI();

        if (_.options.lazyLoad === 'progressive') {
            _.progressiveLazyLoad();
        }

    };

    Slick.prototype.next = Slick.prototype.slickNext = function() {

        var _ = this;

        _.changeSlide({
            data: {
                message: 'next'
            }
        });

    };

    Slick.prototype.orientationChange = function() {

        var _ = this;

        _.checkResponsive();
        _.setPosition();

    };

    Slick.prototype.pause = Slick.prototype.slickPause = function() {

        var _ = this;

        _.autoPlayClear();
        _.paused = true;

    };

    Slick.prototype.play = Slick.prototype.slickPlay = function() {

        var _ = this;

        _.paused = false;
        _.autoPlay();

    };

    Slick.prototype.postSlide = function(index) {

        var _ = this;

        _.$slider.trigger('afterChange', [_, index]);

        _.animating = false;

        _.setPosition();

        _.swipeLeft = null;

        if (_.options.autoplay === true && _.paused === false) {
            _.autoPlay();
        }

    };

    Slick.prototype.prev = Slick.prototype.slickPrev = function() {

        var _ = this;

        _.changeSlide({
            data: {
                message: 'previous'
            }
        });

    };

    Slick.prototype.preventDefault = function(e) {
        e.preventDefault();
    };

    Slick.prototype.progressiveLazyLoad = function() {

        var _ = this,
            imgCount, targetImage;

        imgCount = $('img[data-lazy]', _.$slider).length;

        if (imgCount > 0) {
            targetImage = $('img[data-lazy]', _.$slider).first();
            targetImage.attr('src', targetImage.attr('data-lazy')).removeClass('slick-loading').load(function() {
                    targetImage.removeAttr('data-lazy');
                    _.progressiveLazyLoad();

                    if (_.options.adaptiveHeight === true) {
                        _.setPosition();
                    }
                })
                .error(function() {
                    targetImage.removeAttr('data-lazy');
                    _.progressiveLazyLoad();
                });
        }

    };

    Slick.prototype.refresh = function() {

        var _ = this,
            currentSlide = _.currentSlide;

        _.destroy();

        $.extend(_, _.initials);

        _.init();

        _.changeSlide({
            data: {
                message: 'index',
                index: currentSlide
            }
        }, false);

    };

    Slick.prototype.reinit = function() {

        var _ = this;

        _.$slides = _.$slideTrack.children(_.options.slide).addClass(
            'slick-slide');

        _.slideCount = _.$slides.length;

        if (_.currentSlide >= _.slideCount && _.currentSlide !== 0) {
            _.currentSlide = _.currentSlide - _.options.slidesToScroll;
        }

        if (_.slideCount <= _.options.slidesToShow) {
            _.currentSlide = 0;
        }

        _.setProps();

        _.setupInfinite();

        _.buildArrows();

        _.updateArrows();

        _.initArrowEvents();

        _.buildDots();

        _.updateDots();

        _.initDotEvents();

        if (_.options.focusOnSelect === true) {
            $(_.$slideTrack).children().on('click.slick', _.selectHandler);
        }

        _.setSlideClasses(0);

        _.setPosition();

        _.$slider.trigger('reInit', [_]);

    };

    Slick.prototype.resize = function() {

        var _ = this;

        if ($(window).width() !== _.windowWidth) {
            clearTimeout(_.windowDelay);
            _.windowDelay = window.setTimeout(function() {
                _.windowWidth = $(window).width();
                _.checkResponsive();
                _.setPosition();
            }, 50);
        }
    };

    Slick.prototype.removeSlide = Slick.prototype.slickRemove = function(index, removeBefore, removeAll) {

        var _ = this;

        if (typeof(index) === 'boolean') {
            removeBefore = index;
            index = removeBefore === true ? 0 : _.slideCount - 1;
        } else {
            index = removeBefore === true ? --index : index;
        }

        if (_.slideCount < 1 || index < 0 || index > _.slideCount - 1) {
            return false;
        }

        _.unload();

        if (removeAll === true) {
            _.$slideTrack.children().remove();
        } else {
            _.$slideTrack.children(this.options.slide).eq(index).remove();
        }

        _.$slides = _.$slideTrack.children(this.options.slide);

        _.$slideTrack.children(this.options.slide).detach();

        _.$slideTrack.append(_.$slides);

        _.$slidesCache = _.$slides;

        _.reinit();

    };

    Slick.prototype.setCSS = function(position) {

        var _ = this,
            positionProps = {},
            x, y;

        if (_.options.rtl === true) {
            position = -position;
        }
        x = _.positionProp == 'left' ? Math.ceil(position) + 'px' : '0px';
        y = _.positionProp == 'top' ? Math.ceil(position) + 'px' : '0px';

        positionProps[_.positionProp] = position;

        if (_.transformsEnabled === false) {
            _.$slideTrack.css(positionProps);
        } else {
            positionProps = {};
            if (_.cssTransitions === false) {
                positionProps[_.animType] = 'translate(' + x + ', ' + y + ')';
                _.$slideTrack.css(positionProps);
            } else {
                positionProps[_.animType] = 'translate3d(' + x + ', ' + y + ', 0px)';
                _.$slideTrack.css(positionProps);
            }
        }

    };

    Slick.prototype.setDimensions = function() {

        var _ = this;

        if (_.options.vertical === false) {
            if (_.options.centerMode === true) {
                _.$list.css({
                    padding: ('0px ' + _.options.centerPadding)
                });
            }
        } else {
            _.$list.height(_.$slides.first().outerHeight(true) * _.options.slidesToShow);
            if (_.options.centerMode === true) {
                _.$list.css({
                    padding: (_.options.centerPadding + ' 0px')
                });
            }
        }

        _.listWidth = _.$list.width();
        _.listHeight = _.$list.height();


        if (_.options.vertical === false && _.options.variableWidth === false) {
            _.slideWidth = Math.ceil(_.listWidth / _.options.slidesToShow);
            _.$slideTrack.width(Math.ceil((_.slideWidth * _.$slideTrack.children('.slick-slide').length)));

        } else if (_.options.variableWidth === true) {
            _.$slideTrack.width(5000 * _.slideCount);
        } else {
            _.slideWidth = Math.ceil(_.listWidth);
            _.$slideTrack.height(Math.ceil((_.$slides.first().outerHeight(true) * _.$slideTrack.children('.slick-slide').length)));
        }

        var offset = _.$slides.first().outerWidth(true) - _.$slides.first().width();
        if (_.options.variableWidth === false) _.$slideTrack.children('.slick-slide').width(_.slideWidth - offset);

    };

    Slick.prototype.setFade = function() {

        var _ = this,
            targetLeft;

        _.$slides.each(function(index, element) {
            targetLeft = (_.slideWidth * index) * -1;
            if (_.options.rtl === true) {
                $(element).css({
                    position: 'relative',
                    right: targetLeft,
                    top: 0,
                    zIndex: 800,
                    opacity: 0
                });
            } else {
                $(element).css({
                    position: 'relative',
                    left: targetLeft,
                    top: 0,
                    zIndex: 800,
                    opacity: 0
                });
            }
        });

        _.$slides.eq(_.currentSlide).css({
            zIndex: 900,
            opacity: 1
        });

    };

    Slick.prototype.setHeight = function() {

        var _ = this;

        if (_.options.slidesToShow === 1 && _.options.adaptiveHeight === true && _.options.vertical === false) {
            var targetHeight = _.$slides.eq(_.currentSlide).outerHeight(true);
            _.$list.css('height', targetHeight);
        }

    };

    Slick.prototype.setOption = Slick.prototype.slickSetOption = function(option, value, refresh) {

        var _ = this;
        _.options[option] = value;

        if (refresh === true) {
            _.unload();
            _.reinit();
        }

    };

    Slick.prototype.setPosition = function() {

        var _ = this;

        _.setDimensions();

        _.setHeight();

        if (_.options.fade === false) {
            _.setCSS(_.getLeft(_.currentSlide));
        } else {
            _.setFade();
        }

        _.$slider.trigger('setPosition', [_]);

    };

    Slick.prototype.setProps = function() {

        var _ = this,
            bodyStyle = document.body.style;

        _.positionProp = _.options.vertical === true ? 'top' : 'left';

        if (_.positionProp === 'top') {
            _.$slider.addClass('slick-vertical');
        } else {
            _.$slider.removeClass('slick-vertical');
        }

        if (bodyStyle.WebkitTransition !== undefined ||
            bodyStyle.MozTransition !== undefined ||
            bodyStyle.msTransition !== undefined) {
            if (_.options.useCSS === true) {
                _.cssTransitions = true;
            }
        }

        if (bodyStyle.OTransform !== undefined) {
            _.animType = 'OTransform';
            _.transformType = '-o-transform';
            _.transitionType = 'OTransition';
            if (bodyStyle.perspectiveProperty === undefined && bodyStyle.webkitPerspective === undefined) _.animType = false;
        }
        if (bodyStyle.MozTransform !== undefined) {
            _.animType = 'MozTransform';
            _.transformType = '-moz-transform';
            _.transitionType = 'MozTransition';
            if (bodyStyle.perspectiveProperty === undefined && bodyStyle.MozPerspective === undefined) _.animType = false;
        }
        if (bodyStyle.webkitTransform !== undefined) {
            _.animType = 'webkitTransform';
            _.transformType = '-webkit-transform';
            _.transitionType = 'webkitTransition';
            if (bodyStyle.perspectiveProperty === undefined && bodyStyle.webkitPerspective === undefined) _.animType = false;
        }
        if (bodyStyle.msTransform !== undefined) {
            _.animType = 'msTransform';
            _.transformType = '-ms-transform';
            _.transitionType = 'msTransition';
            if (bodyStyle.msTransform === undefined) _.animType = false;
        }
        if (bodyStyle.transform !== undefined && _.animType !== false) {
            _.animType = 'transform';
            _.transformType = 'transform';
            _.transitionType = 'transition';
        }
        _.transformsEnabled = (_.animType !== null && _.animType !== false);

    };


    Slick.prototype.setSlideClasses = function(index) {

        var _ = this,
            centerOffset, allSlides, indexOffset, remainder;

        _.$slider.find('.slick-slide').removeClass('slick-active').attr('aria-hidden', 'true').removeClass('slick-center');
        allSlides = _.$slider.find('.slick-slide');

        if (_.options.centerMode === true) {

            centerOffset = Math.floor(_.options.slidesToShow / 2);

            if (_.options.infinite === true) {

                if (index >= centerOffset && index <= (_.slideCount - 1) - centerOffset) {
                    _.$slides.slice(index - centerOffset, index + centerOffset + 1).addClass('slick-active').attr('aria-hidden', 'false');
                } else {
                    indexOffset = _.options.slidesToShow + index;
                    allSlides.slice(indexOffset - centerOffset + 1, indexOffset + centerOffset + 2).addClass('slick-active').attr('aria-hidden', 'false');
                }

                if (index === 0) {
                    allSlides.eq(allSlides.length - 1 - _.options.slidesToShow).addClass('slick-center');
                } else if (index === _.slideCount - 1) {
                    allSlides.eq(_.options.slidesToShow).addClass('slick-center');
                }

            }

            _.$slides.eq(index).addClass('slick-center');

        } else {

            if (index >= 0 && index <= (_.slideCount - _.options.slidesToShow)) {
                _.$slides.slice(index, index + _.options.slidesToShow).addClass('slick-active').attr('aria-hidden', 'false');
            } else if (allSlides.length <= _.options.slidesToShow) {
                allSlides.addClass('slick-active').attr('aria-hidden', 'false');
            } else {
                remainder = _.slideCount % _.options.slidesToShow;
                indexOffset = _.options.infinite === true ? _.options.slidesToShow + index : index;
                if (_.options.slidesToShow == _.options.slidesToScroll && (_.slideCount - index) < _.options.slidesToShow) {
                    allSlides.slice(indexOffset - (_.options.slidesToShow - remainder), indexOffset + remainder).addClass('slick-active').attr('aria-hidden', 'false');
                } else {
                    allSlides.slice(indexOffset, indexOffset + _.options.slidesToShow).addClass('slick-active').attr('aria-hidden', 'false');
                }
            }

        }

        if (_.options.lazyLoad === 'ondemand') {
            _.lazyLoad();
        }

    };

    Slick.prototype.setupInfinite = function() {

        var _ = this,
            i, slideIndex, infiniteCount;

        if (_.options.fade === true) {
            _.options.centerMode = false;
        }

        if (_.options.infinite === true && _.options.fade === false) {

            slideIndex = null;

            if (_.slideCount > _.options.slidesToShow) {

                if (_.options.centerMode === true) {
                    infiniteCount = _.options.slidesToShow + 1;
                } else {
                    infiniteCount = _.options.slidesToShow;
                }

                for (i = _.slideCount; i > (_.slideCount -
                        infiniteCount); i -= 1) {
                    slideIndex = i - 1;
                    $(_.$slides[slideIndex]).clone(true).attr('id', '')
                        .attr('data-slick-index', slideIndex - _.slideCount)
                        .prependTo(_.$slideTrack).addClass('slick-cloned');
                }
                for (i = 0; i < infiniteCount; i += 1) {
                    slideIndex = i;
                    $(_.$slides[slideIndex]).clone(true).attr('id', '')
                        .attr('data-slick-index', slideIndex + _.slideCount)
                        .appendTo(_.$slideTrack).addClass('slick-cloned');
                }
                _.$slideTrack.find('.slick-cloned').find('[id]').each(function() {
                    $(this).attr('id', '');
                });

            }

        }

    };

    Slick.prototype.setPaused = function(paused) {

        var _ = this;

        if (_.options.autoplay === true && _.options.pauseOnHover === true) {
            _.paused = paused;
            _.autoPlayClear();
        }
    };

    Slick.prototype.selectHandler = function(event) {

        var _ = this;

        var targetElement = $(event.target).is('.slick-slide') ?
            $(event.target) :
            $(event.target).parents('.slick-slide');

        var index = parseInt(targetElement.attr('data-slick-index'));

        if (!index) index = 0;

        if (_.slideCount <= _.options.slidesToShow) {
            _.$slider.find('.slick-slide').removeClass('slick-active').attr('aria-hidden', 'true');
            _.$slides.eq(index).addClass('slick-active').attr("aria-hidden", "false");
            if (_.options.centerMode === true) {
                _.$slider.find('.slick-slide').removeClass('slick-center');
                _.$slides.eq(index).addClass('slick-center');
            }
            _.asNavFor(index);
            return;
        }
        _.slideHandler(index);

    };

    Slick.prototype.slideHandler = function(index, sync, dontAnimate) {

        var targetSlide, animSlide, oldSlide, slideLeft, targetLeft = null,
            _ = this;

        sync = sync || false;

        if (_.animating === true && _.options.waitForAnimate === true) {
            return;
        }

        if (_.options.fade === true && _.currentSlide === index) {
            return;
        }

        if (_.slideCount <= _.options.slidesToShow) {
            return;
        }

        if (sync === false) {
            _.asNavFor(index);
        }

        targetSlide = index;
        targetLeft = _.getLeft(targetSlide);
        slideLeft = _.getLeft(_.currentSlide);

        _.currentLeft = _.swipeLeft === null ? slideLeft : _.swipeLeft;

        if (_.options.infinite === false && _.options.centerMode === false && (index < 0 || index > _.getDotCount() * _.options.slidesToScroll)) {
            if (_.options.fade === false) {
                targetSlide = _.currentSlide;
                if (dontAnimate !== true) {
                    _.animateSlide(slideLeft, function() {
                        _.postSlide(targetSlide);
                    });
                } else {
                    _.postSlide(targetSlide);
                }
            }
            return;
        } else if (_.options.infinite === false && _.options.centerMode === true && (index < 0 || index > (_.slideCount - _.options.slidesToScroll))) {
            if (_.options.fade === false) {
                targetSlide = _.currentSlide;
                if (dontAnimate !== true) {
                    _.animateSlide(slideLeft, function() {
                        _.postSlide(targetSlide);
                    });
                } else {
                    _.postSlide(targetSlide);
                }
            }
            return;
        }

        if (_.options.autoplay === true) {
            clearInterval(_.autoPlayTimer);
        }

        if (targetSlide < 0) {
            if (_.slideCount % _.options.slidesToScroll !== 0) {
                animSlide = _.slideCount - (_.slideCount % _.options.slidesToScroll);
            } else {
                animSlide = _.slideCount + targetSlide;
            }
        } else if (targetSlide >= _.slideCount) {
            if (_.slideCount % _.options.slidesToScroll !== 0) {
                animSlide = 0;
            } else {
                animSlide = targetSlide - _.slideCount;
            }
        } else {
            animSlide = targetSlide;
        }

        _.animating = true;

        _.$slider.trigger("beforeChange", [_, _.currentSlide, animSlide]);

        oldSlide = _.currentSlide;
        _.currentSlide = animSlide;

        _.setSlideClasses(_.currentSlide);

        _.updateDots();
        _.updateArrows();

        if (_.options.fade === true) {
            if (dontAnimate !== true) {
                _.fadeSlide(animSlide, function() {
                    _.postSlide(animSlide);
                });
            } else {
                _.postSlide(animSlide);
            }
            _.animateHeight();
            return;
        }

        if (dontAnimate !== true) {
            _.animateSlide(targetLeft, function() {
                _.postSlide(animSlide);
            });
        } else {
            _.postSlide(animSlide);
        }

    };

    Slick.prototype.startLoad = function() {

        var _ = this;

        if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {

            _.$prevArrow.hide();
            _.$nextArrow.hide();

        }

        if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {

            _.$dots.hide();

        }

        _.$slider.addClass('slick-loading');

    };

    Slick.prototype.swipeDirection = function() {

        var xDist, yDist, r, swipeAngle, _ = this;

        xDist = _.touchObject.startX - _.touchObject.curX;
        yDist = _.touchObject.startY - _.touchObject.curY;
        r = Math.atan2(yDist, xDist);

        swipeAngle = Math.round(r * 180 / Math.PI);
        if (swipeAngle < 0) {
            swipeAngle = 360 - Math.abs(swipeAngle);
        }

        if ((swipeAngle <= 45) && (swipeAngle >= 0)) {
            return (_.options.rtl === false ? 'left' : 'right');
        }
        if ((swipeAngle <= 360) && (swipeAngle >= 315)) {
            return (_.options.rtl === false ? 'left' : 'right');
        }
        if ((swipeAngle >= 135) && (swipeAngle <= 225)) {
            return (_.options.rtl === false ? 'right' : 'left');
        }
        if (_.options.verticalSwiping === true) {
            if ((swipeAngle >= 35) && (swipeAngle <= 135)) {
                return 'left';
            } else {
                return 'right';
            }
        }

        return 'vertical';

    };

    Slick.prototype.swipeEnd = function(event) {

        var _ = this,
            slideCount;

        _.dragging = false;

        _.shouldClick = (_.touchObject.swipeLength > 10) ? false : true;

        if (_.touchObject.curX === undefined) {
            return false;
        }

        if (_.touchObject.edgeHit === true) {
            _.$slider.trigger("edge", [_, _.swipeDirection()]);
        }

        if (_.touchObject.swipeLength >= _.touchObject.minSwipe) {

            switch (_.swipeDirection()) {
                case 'left':
                    slideCount = _.options.swipeToSlide ? _.checkNavigable(_.currentSlide + _.getSlideCount()) : _.currentSlide + _.getSlideCount();
                    _.slideHandler(slideCount);
                    _.currentDirection = 0;
                    _.touchObject = {};
                    _.$slider.trigger("swipe", [_, "left"]);
                    break;

                case 'right':
                    slideCount = _.options.swipeToSlide ? _.checkNavigable(_.currentSlide - _.getSlideCount()) : _.currentSlide - _.getSlideCount();
                    _.slideHandler(slideCount);
                    _.currentDirection = 1;
                    _.touchObject = {};
                    _.$slider.trigger("swipe", [_, "right"]);
                    break;
            }
        } else {
            if (_.touchObject.startX !== _.touchObject.curX) {
                _.slideHandler(_.currentSlide);
                _.touchObject = {};
            }
        }

    };

    Slick.prototype.swipeHandler = function(event) {

        var _ = this;

        if ((_.options.swipe === false) || ('ontouchend' in document && _.options.swipe === false)) {
            return;
        } else if (_.options.draggable === false && event.type.indexOf('mouse') !== -1) {
            return;
        }

        _.touchObject.fingerCount = event.originalEvent && event.originalEvent.touches !== undefined ?
            event.originalEvent.touches.length : 1;

        _.touchObject.minSwipe = _.listWidth / _.options
            .touchThreshold;

        if (_.options.verticalSwiping === true) {
            _.touchObject.minSwipe = _.listHeight / _.options
                .touchThreshold;
        }

        switch (event.data.action) {

            case 'start':
                _.swipeStart(event);
                break;

            case 'move':
                _.swipeMove(event);
                break;

            case 'end':
                _.swipeEnd(event);
                break;

        }

    };

    Slick.prototype.swipeMove = function(event) {

        var _ = this,
            edgeWasHit = false,
            curLeft, swipeDirection, swipeLength, positionOffset, touches;

        touches = event.originalEvent !== undefined ? event.originalEvent.touches : null;

        if (!_.dragging || touches && touches.length !== 1) {
            return false;
        }

        curLeft = _.getLeft(_.currentSlide);

        _.touchObject.curX = touches !== undefined ? touches[0].pageX : event.clientX;
        _.touchObject.curY = touches !== undefined ? touches[0].pageY : event.clientY;

        _.touchObject.swipeLength = Math.round(Math.sqrt(
            Math.pow(_.touchObject.curX - _.touchObject.startX, 2)));

        if (_.options.verticalSwiping === true) {
            _.touchObject.swipeLength = Math.round(Math.sqrt(
                Math.pow(_.touchObject.curY - _.touchObject.startY, 2)));
        }

        swipeDirection = _.swipeDirection();

        if (swipeDirection === 'vertical') {
            return;
        }

        if (event.originalEvent !== undefined && _.touchObject.swipeLength > 4) {
            event.preventDefault();
        }

        positionOffset = (_.options.rtl === false ? 1 : -1) * (_.touchObject.curX > _.touchObject.startX ? 1 : -1);
        if (_.options.verticalSwiping === true) {
            positionOffset = _.touchObject.curY > _.touchObject.startY ? 1 : -1;
        }


        swipeLength = _.touchObject.swipeLength;

        _.touchObject.edgeHit = false;

        if (_.options.infinite === false) {
            if ((_.currentSlide === 0 && swipeDirection === "right") || (_.currentSlide >= _.getDotCount() && swipeDirection === "left")) {
                swipeLength = _.touchObject.swipeLength * _.options.edgeFriction;
                _.touchObject.edgeHit = true;
            }
        }

        if (_.options.vertical === false) {
            _.swipeLeft = curLeft + swipeLength * positionOffset;
        } else {
            _.swipeLeft = curLeft + (swipeLength * (_.$list.height() / _.listWidth)) * positionOffset;
        }
        if (_.options.verticalSwiping === true) {
            _.swipeLeft = curLeft + swipeLength * positionOffset;
        }

        if (_.options.fade === true || _.options.touchMove === false) {
            return false;
        }

        if (_.animating === true) {
            _.swipeLeft = null;
            return false;
        }

        _.setCSS(_.swipeLeft);

    };

    Slick.prototype.swipeStart = function(event) {

        var _ = this,
            touches;

        if (_.touchObject.fingerCount !== 1 || _.slideCount <= _.options.slidesToShow) {
            _.touchObject = {};
            return false;
        }

        if (event.originalEvent !== undefined && event.originalEvent.touches !== undefined) {
            touches = event.originalEvent.touches[0];
        }

        _.touchObject.startX = _.touchObject.curX = touches !== undefined ? touches.pageX : event.clientX;
        _.touchObject.startY = _.touchObject.curY = touches !== undefined ? touches.pageY : event.clientY;

        _.dragging = true;

    };

    Slick.prototype.unfilterSlides = Slick.prototype.slickUnfilter = function() {

        var _ = this;

        if (_.$slidesCache !== null) {

            _.unload();

            _.$slideTrack.children(this.options.slide).detach();

            _.$slidesCache.appendTo(_.$slideTrack);

            _.reinit();

        }

    };

    Slick.prototype.unload = function() {

        var _ = this;

        $('.slick-cloned', _.$slider).remove();
        if (_.$dots) {
            _.$dots.remove();
        }
        if (_.$prevArrow && (typeof _.options.prevArrow !== 'object')) {
            _.$prevArrow.remove();
        }
        if (_.$nextArrow && (typeof _.options.nextArrow !== 'object')) {
            _.$nextArrow.remove();
        }
        _.$slides.removeClass('slick-slide slick-active slick-visible').attr("aria-hidden", "true").css('width', '');

    };

    Slick.prototype.unslick = function() {

        var _ = this;
        _.destroy();

    };

    Slick.prototype.updateArrows = function() {

        var _ = this,
            centerOffset;

        centerOffset = Math.floor(_.options.slidesToShow / 2);

        if (_.options.arrows === true && _.options.infinite !==
            true && _.slideCount > _.options.slidesToShow) {
            _.$prevArrow.removeClass('slick-disabled');
            _.$nextArrow.removeClass('slick-disabled');
            if (_.currentSlide === 0) {
                _.$prevArrow.addClass('slick-disabled');
                _.$nextArrow.removeClass('slick-disabled');
            } else if (_.currentSlide >= _.slideCount - _.options.slidesToShow && _.options.centerMode === false) {
                _.$nextArrow.addClass('slick-disabled');
                _.$prevArrow.removeClass('slick-disabled');
            } else if (_.currentSlide >= _.slideCount - 1 && _.options.centerMode === true) {
                _.$nextArrow.addClass('slick-disabled');
                _.$prevArrow.removeClass('slick-disabled');
            }
        }

    };

    Slick.prototype.updateDots = function() {

        var _ = this;

        if (_.$dots !== null) {

            _.$dots.find('li').removeClass('slick-active').attr("aria-hidden", "true");
            _.$dots.find('li').eq(Math.floor(_.currentSlide / _.options.slidesToScroll)).addClass('slick-active').attr("aria-hidden", "false");

        }

    };

    Slick.prototype.visibility = function() {

        var _ = this;

        if (document[_.hidden]) {
            _.paused = true;
            _.autoPlayClear();
        } else {
            _.paused = false;
            _.autoPlay();
        }

    };

    $.fn.slick = function() {
        var _ = this,
            opt = arguments[0],
            args = Array.prototype.slice.call(arguments, 1),
            l = _.length,
            i = 0,
            ret;
        for (i; i < l; i++) {
            if (typeof opt == 'object' || typeof opt == 'undefined')
                _[i].slick = new Slick(_[i], opt);
            else
                ret = _[i].slick[opt].apply(_[i].slick, args);
            if (typeof ret != 'undefined') return ret;
        }
        return _;
    };

}));
;

/**
 * imagesLoaded PACKAGED v3.2.0
 * JavaScript is all like "You images are done yet or what?"
 * MIT License
 */

/**
 * EventEmitter v4.2.6 - git.io/ee
 * Oliver Caldwell
 * MIT license
 * @preserve
 */

(function () {
	'use strict';

	/**
	 * Class for managing events.
	 * Can be extended to provide event functionality in other classes.
	 *
	 * @class EventEmitter Manages event registering and emitting.
	 */
	function EventEmitter() {}

	// Shortcuts to improve speed and size
	var proto = EventEmitter.prototype;
	var exports = this;
	var originalGlobalValue = exports.EventEmitter;

	/**
	 * Finds the index of the listener for the event in it's storage array.
	 *
	 * @param {Function[]} listeners Array of listeners to search through.
	 * @param {Function} listener Method to look for.
	 * @return {Number} Index of the specified listener, -1 if not found
	 * @api private
	 */
	function indexOfListener(listeners, listener) {
		var i = listeners.length;
		while (i--) {
			if (listeners[i].listener === listener) {
				return i;
			}
		}

		return -1;
	}

	/**
	 * Alias a method while keeping the context correct, to allow for overwriting of target method.
	 *
	 * @param {String} name The name of the target method.
	 * @return {Function} The aliased method
	 * @api private
	 */
	function alias(name) {
		return function aliasClosure() {
			return this[name].apply(this, arguments);
		};
	}

	/**
	 * Returns the listener array for the specified event.
	 * Will initialise the event object and listener arrays if required.
	 * Will return an object if you use a regex search. The object contains keys for each matched event. So /ba[rz]/ might return an object containing bar and baz. But only if you have either defined them with defineEvent or added some listeners to them.
	 * Each property in the object response is an array of listener functions.
	 *
	 * @param {String|RegExp} evt Name of the event to return the listeners from.
	 * @return {Function[]|Object} All listener functions for the event.
	 */
	proto.getListeners = function getListeners(evt) {
		var events = this._getEvents();
		var response;
		var key;

		// Return a concatenated array of all matching events if
		// the selector is a regular expression.
		if (typeof evt === 'object') {
			response = {};
			for (key in events) {
				if (events.hasOwnProperty(key) && evt.test(key)) {
					response[key] = events[key];
				}
			}
		}
		else {
			response = events[evt] || (events[evt] = []);
		}

		return response;
	};

	/**
	 * Takes a list of listener objects and flattens it into a list of listener functions.
	 *
	 * @param {Object[]} listeners Raw listener objects.
	 * @return {Function[]} Just the listener functions.
	 */
	proto.flattenListeners = function flattenListeners(listeners) {
		var flatListeners = [];
		var i;

		for (i = 0; i < listeners.length; i += 1) {
			flatListeners.push(listeners[i].listener);
		}

		return flatListeners;
	};

	/**
	 * Fetches the requested listeners via getListeners but will always return the results inside an object. This is mainly for internal use but others may find it useful.
	 *
	 * @param {String|RegExp} evt Name of the event to return the listeners from.
	 * @return {Object} All listener functions for an event in an object.
	 */
	proto.getListenersAsObject = function getListenersAsObject(evt) {
		var listeners = this.getListeners(evt);
		var response;

		if (listeners instanceof Array) {
			response = {};
			response[evt] = listeners;
		}

		return response || listeners;
	};

	/**
	 * Adds a listener function to the specified event.
	 * The listener will not be added if it is a duplicate.
	 * If the listener returns true then it will be removed after it is called.
	 * If you pass a regular expression as the event name then the listener will be added to all events that match it.
	 *
	 * @param {String|RegExp} evt Name of the event to attach the listener to.
	 * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.addListener = function addListener(evt, listener) {
		var listeners = this.getListenersAsObject(evt);
		var listenerIsWrapped = typeof listener === 'object';
		var key;

		for (key in listeners) {
			if (listeners.hasOwnProperty(key) && indexOfListener(listeners[key], listener) === -1) {
				listeners[key].push(listenerIsWrapped ? listener : {
					listener: listener,
					once: false
				});
			}
		}

		return this;
	};

	/**
	 * Alias of addListener
	 */
	proto.on = alias('addListener');

	/**
	 * Semi-alias of addListener. It will add a listener that will be
	 * automatically removed after it's first execution.
	 *
	 * @param {String|RegExp} evt Name of the event to attach the listener to.
	 * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.addOnceListener = function addOnceListener(evt, listener) {
		return this.addListener(evt, {
			listener: listener,
			once: true
		});
	};

	/**
	 * Alias of addOnceListener.
	 */
	proto.once = alias('addOnceListener');

	/**
	 * Defines an event name. This is required if you want to use a regex to add a listener to multiple events at once. If you don't do this then how do you expect it to know what event to add to? Should it just add to every possible match for a regex? No. That is scary and bad.
	 * You need to tell it what event names should be matched by a regex.
	 *
	 * @param {String} evt Name of the event to create.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.defineEvent = function defineEvent(evt) {
		this.getListeners(evt);
		return this;
	};

	/**
	 * Uses defineEvent to define multiple events.
	 *
	 * @param {String[]} evts An array of event names to define.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.defineEvents = function defineEvents(evts) {
		for (var i = 0; i < evts.length; i += 1) {
			this.defineEvent(evts[i]);
		}
		return this;
	};

	/**
	 * Removes a listener function from the specified event.
	 * When passed a regular expression as the event name, it will remove the listener from all events that match it.
	 *
	 * @param {String|RegExp} evt Name of the event to remove the listener from.
	 * @param {Function} listener Method to remove from the event.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.removeListener = function removeListener(evt, listener) {
		var listeners = this.getListenersAsObject(evt);
		var index;
		var key;

		for (key in listeners) {
			if (listeners.hasOwnProperty(key)) {
				index = indexOfListener(listeners[key], listener);

				if (index !== -1) {
					listeners[key].splice(index, 1);
				}
			}
		}

		return this;
	};

	/**
	 * Alias of removeListener
	 */
	proto.off = alias('removeListener');

	/**
	 * Adds listeners in bulk using the manipulateListeners method.
	 * If you pass an object as the second argument you can add to multiple events at once. The object should contain key value pairs of events and listeners or listener arrays. You can also pass it an event name and an array of listeners to be added.
	 * You can also pass it a regular expression to add the array of listeners to all events that match it.
	 * Yeah, this function does quite a bit. That's probably a bad thing.
	 *
	 * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add to multiple events at once.
	 * @param {Function[]} [listeners] An optional array of listener functions to add.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.addListeners = function addListeners(evt, listeners) {
		// Pass through to manipulateListeners
		return this.manipulateListeners(false, evt, listeners);
	};

	/**
	 * Removes listeners in bulk using the manipulateListeners method.
	 * If you pass an object as the second argument you can remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.
	 * You can also pass it an event name and an array of listeners to be removed.
	 * You can also pass it a regular expression to remove the listeners from all events that match it.
	 *
	 * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to remove from multiple events at once.
	 * @param {Function[]} [listeners] An optional array of listener functions to remove.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.removeListeners = function removeListeners(evt, listeners) {
		// Pass through to manipulateListeners
		return this.manipulateListeners(true, evt, listeners);
	};

	/**
	 * Edits listeners in bulk. The addListeners and removeListeners methods both use this to do their job. You should really use those instead, this is a little lower level.
	 * The first argument will determine if the listeners are removed (true) or added (false).
	 * If you pass an object as the second argument you can add/remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.
	 * You can also pass it an event name and an array of listeners to be added/removed.
	 * You can also pass it a regular expression to manipulate the listeners of all events that match it.
	 *
	 * @param {Boolean} remove True if you want to remove listeners, false if you want to add.
	 * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add/remove from multiple events at once.
	 * @param {Function[]} [listeners] An optional array of listener functions to add/remove.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.manipulateListeners = function manipulateListeners(remove, evt, listeners) {
		var i;
		var value;
		var single = remove ? this.removeListener : this.addListener;
		var multiple = remove ? this.removeListeners : this.addListeners;

		// If evt is an object then pass each of it's properties to this method
		if (typeof evt === 'object' && !(evt instanceof RegExp)) {
			for (i in evt) {
				if (evt.hasOwnProperty(i) && (value = evt[i])) {
					// Pass the single listener straight through to the singular method
					if (typeof value === 'function') {
						single.call(this, i, value);
					}
					else {
						// Otherwise pass back to the multiple function
						multiple.call(this, i, value);
					}
				}
			}
		}
		else {
			// So evt must be a string
			// And listeners must be an array of listeners
			// Loop over it and pass each one to the multiple method
			i = listeners.length;
			while (i--) {
				single.call(this, evt, listeners[i]);
			}
		}

		return this;
	};

	/**
	 * Removes all listeners from a specified event.
	 * If you do not specify an event then all listeners will be removed.
	 * That means every event will be emptied.
	 * You can also pass a regex to remove all events that match it.
	 *
	 * @param {String|RegExp} [evt] Optional name of the event to remove all listeners for. Will remove from every event if not passed.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.removeEvent = function removeEvent(evt) {
		var type = typeof evt;
		var events = this._getEvents();
		var key;

		// Remove different things depending on the state of evt
		if (type === 'string') {
			// Remove all listeners for the specified event
			delete events[evt];
		}
		else if (type === 'object') {
			// Remove all events matching the regex.
			for (key in events) {
				if (events.hasOwnProperty(key) && evt.test(key)) {
					delete events[key];
				}
			}
		}
		else {
			// Remove all listeners in all events
			delete this._events;
		}

		return this;
	};

	/**
	 * Alias of removeEvent.
	 *
	 * Added to mirror the node API.
	 */
	proto.removeAllListeners = alias('removeEvent');

	/**
	 * Emits an event of your choice.
	 * When emitted, every listener attached to that event will be executed.
	 * If you pass the optional argument array then those arguments will be passed to every listener upon execution.
	 * Because it uses `apply`, your array of arguments will be passed as if you wrote them out separately.
	 * So they will not arrive within the array on the other side, they will be separate.
	 * You can also pass a regular expression to emit to all events that match it.
	 *
	 * @param {String|RegExp} evt Name of the event to emit and execute listeners for.
	 * @param {Array} [args] Optional array of arguments to be passed to each listener.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.emitEvent = function emitEvent(evt, args) {
		var listeners = this.getListenersAsObject(evt);
		var listener;
		var i;
		var key;
		var response;

		for (key in listeners) {
			if (listeners.hasOwnProperty(key)) {
				i = listeners[key].length;

				while (i--) {
					// If the listener returns true then it shall be removed from the event
					// The function is executed either with a basic call or an apply if there is an args array
					listener = listeners[key][i];

					if (listener.once === true) {
						this.removeListener(evt, listener.listener);
					}

					response = listener.listener.apply(this, args || []);

					if (response === this._getOnceReturnValue()) {
						this.removeListener(evt, listener.listener);
					}
				}
			}
		}

		return this;
	};

	/**
	 * Alias of emitEvent
	 */
	proto.trigger = alias('emitEvent');

	/**
	 * Subtly different from emitEvent in that it will pass its arguments on to the listeners, as opposed to taking a single array of arguments to pass on.
	 * As with emitEvent, you can pass a regex in place of the event name to emit to all events that match it.
	 *
	 * @param {String|RegExp} evt Name of the event to emit and execute listeners for.
	 * @param {...*} Optional additional arguments to be passed to each listener.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.emit = function emit(evt) {
		var args = Array.prototype.slice.call(arguments, 1);
		return this.emitEvent(evt, args);
	};

	/**
	 * Sets the current value to check against when executing listeners. If a
	 * listeners return value matches the one set here then it will be removed
	 * after execution. This value defaults to true.
	 *
	 * @param {*} value The new value to check for when executing listeners.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.setOnceReturnValue = function setOnceReturnValue(value) {
		this._onceReturnValue = value;
		return this;
	};

	/**
	 * Fetches the current value to check against when executing listeners. If
	 * the listeners return value matches this one then it should be removed
	 * automatically. It will return true by default.
	 *
	 * @return {*|Boolean} The current value to check for or the default, true.
	 * @api private
	 */
	proto._getOnceReturnValue = function _getOnceReturnValue() {
		if (this.hasOwnProperty('_onceReturnValue')) {
			return this._onceReturnValue;
		}
		else {
			return true;
		}
	};

	/**
	 * Fetches the events object and creates one if required.
	 *
	 * @return {Object} The events storage object.
	 * @api private
	 */
	proto._getEvents = function _getEvents() {
		return this._events || (this._events = {});
	};

	/**
	 * Reverts the global {@link EventEmitter} to its previous value and returns a reference to this version.
	 *
	 * @return {Function} Non conflicting EventEmitter class.
	 */
	EventEmitter.noConflict = function noConflict() {
		exports.EventEmitter = originalGlobalValue;
		return EventEmitter;
	};

	// Expose the class either via AMD, CommonJS or the global object
	if (typeof define === 'function' && define.amd) {
		define('eventEmitter/EventEmitter',[],function () {
			return EventEmitter;
		});
	}
	else if (typeof module === 'object' && module.exports){
		module.exports = EventEmitter;
	}
	else {
		this.EventEmitter = EventEmitter;
	}
}.call(this));

/*!
 * eventie v1.0.4
 * event binding helper
 *   eventie.bind( elem, 'click', myFn )
 *   eventie.unbind( elem, 'click', myFn )
 */

/*jshint browser: true, undef: true, unused: true */
/*global define: false */

( function( window ) {



var docElem = document.documentElement;

var bind = function() {};

function getIEEvent( obj ) {
  var event = window.event;
  // add event.target
  event.target = event.target || event.srcElement || obj;
  return event;
}

if ( docElem.addEventListener ) {
  bind = function( obj, type, fn ) {
    obj.addEventListener( type, fn, false );
  };
} else if ( docElem.attachEvent ) {
  bind = function( obj, type, fn ) {
    obj[ type + fn ] = fn.handleEvent ?
      function() {
        var event = getIEEvent( obj );
        fn.handleEvent.call( fn, event );
      } :
      function() {
        var event = getIEEvent( obj );
        fn.call( obj, event );
      };
    obj.attachEvent( "on" + type, obj[ type + fn ] );
  };
}

var unbind = function() {};

if ( docElem.removeEventListener ) {
  unbind = function( obj, type, fn ) {
    obj.removeEventListener( type, fn, false );
  };
} else if ( docElem.detachEvent ) {
  unbind = function( obj, type, fn ) {
    obj.detachEvent( "on" + type, obj[ type + fn ] );
    try {
      delete obj[ type + fn ];
    } catch ( err ) {
      // can't delete window object properties
      obj[ type + fn ] = undefined;
    }
  };
}

var eventie = {
  bind: bind,
  unbind: unbind
};

// transport
if ( typeof define === 'function' && define.amd ) {
  // AMD
  define( 'eventie/eventie',eventie );
} else {
  // browser global
  window.eventie = eventie;
}

})( this );

/*!
 * imagesLoaded v3.2.0
 * JavaScript is all like "You images are done yet or what?"
 * MIT License
 */

( function( window, factory ) { 'use strict';
  // universal module definition

  /*global define: false, module: false, require: false */

  if ( typeof define == 'function' && define.amd ) {
    // AMD
    define( [
      'eventEmitter/EventEmitter',
      'eventie/eventie'
    ], function( EventEmitter, eventie ) {
      return factory( window, EventEmitter, eventie );
    });
  } else if ( typeof module == 'object' && module.exports ) {
    // CommonJS
    module.exports = factory(
      window,
      require('wolfy87-eventemitter'),
      require('eventie')
    );
  } else {
    // browser global
    window.imagesLoaded = factory(
      window,
      window.EventEmitter,
      window.eventie
    );
  }

})( window,

// --------------------------  factory -------------------------- //

function factory( window, EventEmitter, eventie ) {



var $ = window.jQuery;
var console = window.console;

// -------------------------- helpers -------------------------- //

// extend objects
function extend( a, b ) {
  for ( var prop in b ) {
    a[ prop ] = b[ prop ];
  }
  return a;
}

var objToString = Object.prototype.toString;
function isArray( obj ) {
  return objToString.call( obj ) == '[object Array]';
}

// turn element or nodeList into an array
function makeArray( obj ) {
  var ary = [];
  if ( isArray( obj ) ) {
    // use object if already an array
    ary = obj;
  } else if ( typeof obj.length == 'number' ) {
    // convert nodeList to array
    for ( var i=0; i < obj.length; i++ ) {
      ary.push( obj[i] );
    }
  } else {
    // array of single index
    ary.push( obj );
  }
  return ary;
}

  // -------------------------- imagesLoaded -------------------------- //

  /**
   * @param {Array, Element, NodeList, String} elem
   * @param {Object or Function} options - if function, use as callback
   * @param {Function} onAlways - callback function
   */
  function ImagesLoaded( elem, options, onAlways ) {
    // coerce ImagesLoaded() without new, to be new ImagesLoaded()
    if ( !( this instanceof ImagesLoaded ) ) {
      return new ImagesLoaded( elem, options, onAlways );
    }
    // use elem as selector string
    if ( typeof elem == 'string' ) {
      elem = document.querySelectorAll( elem );
    }

    this.elements = makeArray( elem );
    this.options = extend( {}, this.options );

    if ( typeof options == 'function' ) {
      onAlways = options;
    } else {
      extend( this.options, options );
    }

    if ( onAlways ) {
      this.on( 'always', onAlways );
    }

    this.getImages();

    if ( $ ) {
      // add jQuery Deferred object
      this.jqDeferred = new $.Deferred();
    }

    // HACK check async to allow time to bind listeners
    var _this = this;
    setTimeout( function() {
      _this.check();
    });
  }

  ImagesLoaded.prototype = new EventEmitter();

  ImagesLoaded.prototype.options = {};

  ImagesLoaded.prototype.getImages = function() {
    this.images = [];

    // filter & find items if we have an item selector
    for ( var i=0; i < this.elements.length; i++ ) {
      var elem = this.elements[i];
      this.addElementImages( elem );
    }
  };

  /**
   * @param {Node} element
   */
  ImagesLoaded.prototype.addElementImages = function( elem ) {
    // filter siblings
    if ( elem.nodeName == 'IMG' ) {
      this.addImage( elem );
    }
    // get background image on element
    if ( this.options.background === true ) {
      this.addElementBackgroundImages( elem );
    }

    // find children
    // no non-element nodes, #143
    var nodeType = elem.nodeType;
    if ( !nodeType || !elementNodeTypes[ nodeType ] ) {
      return;
    }
    var childImgs = elem.querySelectorAll('img');
    // concat childElems to filterFound array
    for ( var i=0; i < childImgs.length; i++ ) {
      var img = childImgs[i];
      this.addImage( img );
    }

    // get child background images
    if ( typeof this.options.background == 'string' ) {
      var children = elem.querySelectorAll( this.options.background );
      for ( i=0; i < children.length; i++ ) {
        var child = children[i];
        this.addElementBackgroundImages( child );
      }
    }
  };

  var elementNodeTypes = {
    1: true,
    9: true,
    11: true
  };

  ImagesLoaded.prototype.addElementBackgroundImages = function( elem ) {
    var style = getStyle( elem );
    // get url inside url("...")
    var reURL = /url\(['"]*([^'"\)]+)['"]*\)/gi;
    var matches = reURL.exec( style.backgroundImage );
    while ( matches !== null ) {
      var url = matches && matches[1];
      if ( url ) {
        this.addBackground( url, elem );
      }
      matches = reURL.exec( style.backgroundImage );
    }
  };

  // IE8
  var getStyle = window.getComputedStyle || function( elem ) {
    return elem.currentStyle;
  };

  /**
   * @param {Image} img
   */
  ImagesLoaded.prototype.addImage = function( img ) {
    var loadingImage = new LoadingImage( img );
    this.images.push( loadingImage );
  };

  ImagesLoaded.prototype.addBackground = function( url, elem ) {
    var background = new Background( url, elem );
    this.images.push( background );
  };

  ImagesLoaded.prototype.check = function() {
    var _this = this;
    this.progressedCount = 0;
    this.hasAnyBroken = false;
    // complete if no images
    if ( !this.images.length ) {
      this.complete();
      return;
    }

    function onProgress( image, elem, message ) {
      // HACK - Chrome triggers event before object properties have changed. #83
      setTimeout( function() {
        _this.progress( image, elem, message );
      });
    }

    for ( var i=0; i < this.images.length; i++ ) {
      var loadingImage = this.images[i];
      loadingImage.once( 'progress', onProgress );
      loadingImage.check();
    }
  };

  ImagesLoaded.prototype.progress = function( image, elem, message ) {
    this.progressedCount++;
    this.hasAnyBroken = this.hasAnyBroken || !image.isLoaded;
    // progress event
    this.emit( 'progress', this, image, elem );
    if ( this.jqDeferred && this.jqDeferred.notify ) {
      this.jqDeferred.notify( this, image );
    }
    // check if completed
    if ( this.progressedCount == this.images.length ) {
      this.complete();
    }

    if ( this.options.debug && console ) {
      console.log( 'progress: ' + message, image, elem );
    }
  };

  ImagesLoaded.prototype.complete = function() {
    var eventName = this.hasAnyBroken ? 'fail' : 'done';
    this.isComplete = true;
    this.emit( eventName, this );
    this.emit( 'always', this );
    if ( this.jqDeferred ) {
      var jqMethod = this.hasAnyBroken ? 'reject' : 'resolve';
      this.jqDeferred[ jqMethod ]( this );
    }
  };

  // --------------------------  -------------------------- //

  function LoadingImage( img ) {
    this.img = img;
  }

  LoadingImage.prototype = new EventEmitter();

  LoadingImage.prototype.check = function() {
    // If complete is true and browser supports natural sizes,
    // try to check for image status manually.
    var isComplete = this.getIsImageComplete();
    if ( isComplete ) {
      // report based on naturalWidth
      this.confirm( this.img.naturalWidth !== 0, 'naturalWidth' );
      return;
    }

    // If none of the checks above matched, simulate loading on detached element.
    this.proxyImage = new Image();
    eventie.bind( this.proxyImage, 'load', this );
    eventie.bind( this.proxyImage, 'error', this );
    // bind to image as well for Firefox. #191
    eventie.bind( this.img, 'load', this );
    eventie.bind( this.img, 'error', this );
    this.proxyImage.src = this.img.src;
  };

  LoadingImage.prototype.getIsImageComplete = function() {
    return this.img.complete && this.img.naturalWidth !== undefined;
  };

  LoadingImage.prototype.confirm = function( isLoaded, message ) {
    this.isLoaded = isLoaded;
    this.emit( 'progress', this, this.img, message );
  };

  // ----- events ----- //

  // trigger specified handler for event type
  LoadingImage.prototype.handleEvent = function( event ) {
    var method = 'on' + event.type;
    if ( this[ method ] ) {
      this[ method ]( event );
    }
  };

  LoadingImage.prototype.onload = function() {
    this.confirm( true, 'onload' );
    this.unbindEvents();
  };

  LoadingImage.prototype.onerror = function() {
    this.confirm( false, 'onerror' );
    this.unbindEvents();
  };

  LoadingImage.prototype.unbindEvents = function() {
    eventie.unbind( this.proxyImage, 'load', this );
    eventie.unbind( this.proxyImage, 'error', this );
    eventie.unbind( this.img, 'load', this );
    eventie.unbind( this.img, 'error', this );
  };

  // -------------------------- Background -------------------------- //

  function Background( url, element ) {
    this.url = url;
    this.element = element;
    this.img = new Image();
  }

  // inherit LoadingImage prototype
  Background.prototype = new LoadingImage();

  Background.prototype.check = function() {
    eventie.bind( this.img, 'load', this );
    eventie.bind( this.img, 'error', this );
    this.img.src = this.url;
    // check if image is already complete
    var isComplete = this.getIsImageComplete();
    if ( isComplete ) {
      this.confirm( this.img.naturalWidth !== 0, 'naturalWidth' );
      this.unbindEvents();
    }
  };

  Background.prototype.unbindEvents = function() {
    eventie.unbind( this.img, 'load', this );
    eventie.unbind( this.img, 'error', this );
  };

  Background.prototype.confirm = function( isLoaded, message ) {
    this.isLoaded = isLoaded;
    this.emit( 'progress', this, this.element, message );
  };

  // -------------------------- jQuery -------------------------- //

  ImagesLoaded.makeJQueryPlugin = function( jQuery ) {
    jQuery = jQuery || window.jQuery;
    if ( !jQuery ) {
      return;
    }
    // set local variable
    $ = jQuery;
    // $().imagesLoaded()
    $.fn.imagesLoaded = function( options, callback ) {
      var instance = new ImagesLoaded( this, options, callback );
      return instance.jqDeferred.promise( $(this) );
    };
  };
  // try making plugin
  ImagesLoaded.makeJQueryPlugin();

  // --------------------------  -------------------------- //

  return ImagesLoaded;

});

;

/**

	Base setup for the IBMCore namespace.
	<br />
	<br />This file is SHARED for both WWW and W3.
	<br />DO NOT put anything specific to WWW or W3 in here. Common stuff only.

	@module IBMCore
	@main IBMCore
	
*/

jQuery.noConflict();

var IBMCore = {};

(function($, IBM) {
	/**
		Utility to verify and create namespaces/object paths if they don't already exist.
		<br />
		<br />Similar to $.extend : The first param is an object, and the second param is an object/namespace path to create in the first object (recursively).
		<br />Unlike a merge, it will not overwrite an existing object/path. It will only create an object/path if it doesn't already exist.
		<br />Specifying the last node of a namespace implicitly creates all prior nodes.
		<br />Returns the last/deepest object from the second parameter string path.
		<br />
		<br />Usage:
		
			IBMCore.namespace(IBMCore, "common.util.someUtilityName");

		@class IBMCore.namespace
		@param {String} Existing namespace/object path to extend.
		@param {String} (Multiple) Namespace/object paths to verify and create in first param. Can be multiple params/paths to create.
		@return {Object} The deepest namespace object. (If multiple arguments are passed, this will be the last namespace created)
	**/
    IBM.namespace = function() {
        var scope = arguments[0],
            ln = arguments.length,
            i, value, split, x, xln, parts, object;

        // debugger

        for (i = 1; i < ln; i++) {
            value = arguments[i];
            parts = value.split(".");
            object = scope[parts[0]] = Object(scope[parts[0]]);
            for (x = 1, xln = parts.length; x < xln; x++) {
                object = object[parts[x]] = Object(object[parts[x]]);
            }
        }
        return object;
    };

	// Pre-set namespace objects. COMMON ones only.
    IBM.namespace(
        IBM,
        "performance",
		"common",
        "common.config",
        "common.meta",
        "common.module",
        "common.util",
        "common.vendor",
        "common.widget",
        "currentPage"
    );

})(jQuery, IBMCore);

;

/**

	Extra base setup for www ONLY.
	
*/

(function($, IBM) {

	/**
		Add www specific namespaces.
	**/
    IBM.namespace(
        IBM,
        "www",
        "www.module",
        "www.util",
        "www.widget"
    );
	
})(jQuery, IBMCore);

;

/**

	Helpers to set the page configuration.
	<br />
	<br />Hierarchy of final page config settings is as follows:
	<br /> 1. Defaults out of IBMCore.www.config or IBMCore.w3.config (depending on the build).
	<br /> 2. Any settings by page developer using IBMCore.common.util.config.set. 
	<br />
	<br />Usage:
		
		IBMCore.common.util.config.set({
			megamenu: {
				linksonly: true
			}
		});

	@class IBMCore.common.util.config
	
**/

(function ($, IBM) {

	// Create name space for this thing and make a shortcut to it for ourselves.
	var me = IBM.namespace(IBM, "common.util.config");

	/**
		Merging settings into the existing page's common.config settings.
		
		@method set
		@param setting {Object} The setting object to merge into the existing IBMCore.common.config object.
	
	**/
	me.set = function (setting) {
		if (jQuery.type(setting) === "object") {
			$.extend(true, IBM.common.config, setting);
		}
	};

	
	/**
		Gets a current config setting. Accepts object dot syntax for deep property values. Example:
		<br />
		<br /> <code>IBMCore.common.util.config.get("sbs");</code>
		<br /> -or-
		<br /> <code>IBMCore.common.util.config.get("megamenu.animations.enabled");</code>
		
		@method get
		@param setting {String} The setting to get the value for, in string object notation.
	**/
	me.get = function (setting) {
		var settingParts = setting.split('.'),
			property = "",
			currentConfigSetting = IBM.common.config;
		
		while (currentConfigSetting && settingParts.length) {
			property = settingParts.shift();
			currentConfigSetting = currentConfigSetting[property];
		}

		return currentConfigSetting;
	};

	
	/**
		Helper to determine if a service/module is enabled or not for the page. 
		<br />This is simply a shortcut that uses config.get. Don't really need it, but what the hell. 
		Only works for services that have a ".enabled" property. 
		It ensures consistency if we change the convention of "enabled: true" settings.
		
		@method isEnabled
		@param serviceName {String} The service to check if enabled or not, in string object notation.
		@return {Boolean} true or false
	**/
	me.isEnabled = function (serviceName) {
		var enabled = me.get(serviceName + ".enabled");
		
		// If all modules were disabled via config, return false.
		if (IBM.common.util.config.get("coremodules.enabled") === false) {
			enabled = false;
		}
		 
		return enabled;
	};


})(jQuery, IBMCore);

;

/**

	This is where all the defaults are set for WWW. 
	Configurations and what"s enabled or not by default.
	This is WWW ONLY. W3 has it"s own version of this in the /W3/ dir.
	
	@requires: IBMCore.common.config
	
*/
(function ($, IBM) {

	// OPTIONALLY force a configuration/environment using this var.
	// ONLY use/set this var if you want to build with something other than production URLs/paths/etc.
	//IBM.common.config.ibmForceConfig = "staging";
	
	// Production settings == common/default, then we merge in/override them with any non-prod settings if needed.
	// Purposely used "setting" instead of "config" to avoid confusion when using with common.config object.
	var settings = {
			production: {
				config: "www",
				usedSettings: "production",  // Tell us these settings are being used.
				forced: false,  // Tell us if the settings are forced by the build
			
				/*
					NOTE: The below settings are the production settings.
					These are what are used by default unless you use the forceConfig setting which will override these (see below).
				
					DO NOT CHANGE THIS HERE OR IT WILL BREAK PRODUCTION!
				*/	
				// URL where the dynamicnav-translations are loaded from (header, footer info); must end with a slash /
				//dataUrl: "//1.www.s81c.com/common/v18/js/data/",
				dataUrl: "//www.ibm.com/common/v18/js/data/",
				coreservicesUrl: "https://www.ibm.com/gateway/secstate/?",
				coreservicesUrlSecure: "https://www.ibm.com/gateway/sec/?",
				notificationServiceUrl: "https://wwwpoc.ibm.com/myibm/notifications/api/notifications/unread/count",
				//photoServiceUrl: "https://wwwpoc.ibm.com/myibm/photouploader/services/photo",

				// Set to the location of the v18 files
				imageUrl: "//1.www.s81c.com/common/v18/i/",
				jsFilesUrl: "//1.www.s81c.com/common/v18/js/",
				
				// A flag to disable *all* dynamic modules... masthead, footer, greeting.. anything that"s classified as a "module" below. 
				coremodules: {
					enabled: true
				},
				// A flag to disable *all* content space widgets (tooltips, overlay, etc). 
				// Allows a page to use standard mast/footer, but all their own Dojo stuff in content space.
				contentwidgets: {
					enabled: true
				},
				eluminate: {
					enabled: true
				},
				
				/**
					Module default configurations below 
				**/
						  
				// appmast: {
				// 	enabled: false
				// },
				backtotop: {
					enabled: true
				},
				contactModuleWidget: { 
					enabled: true 
				},
				dynamicContactModule: { 
					enabled: false 
				},
				easyaccess:{ 
					enabled: false,
					// seconds to cache results - 12 hours by default
					lifetime: 43200
				},
				// Legacy. Remove in 4 weeks.
				enabledLocales: [],
				errorchecking: {
					enabled: true
				},
				footer: {
					enabled: true, 
					socialLinks: {
						enabled: false
					},
					type: "default"
				},
				footermenu: {
					enabled: true
				},
				greeting: { 
					enabled: true
				},
				localeselector: { 
					enabled: true
				},
				masthead: {
					enabled: true,
					logoanimation: {
						enabled: false
					},
					megamenu: { 
						enabled: true 
					},
					mobilemenu: { 
						enabled: true 
					},
					notifications: {
						enabled: true
					},
					profile: {
						enabled: true
					},
					search: {
						enabled: true,
						typeahead: {
							enabled: true
						}
					},
					sticky: {
						enabled: true
					},
					type: "default"
				},
				merchandising: { 
					enabled: true 
				},
				sharethispage: {
					enabled: true
				},
				scrolltracker: {
					enabled: false
				},
				// TODO: Santelia: This is old. Eval after profile menu is sorted out if we need this, or just use defatul + 
				//  masthead.profile setting.
				// signin: {
				// 	enabled: false,
				// 	//signoutUrl: "https://www-304.ibm.com/pkmslogout?page=http://www.ibm.com/account/${cc}/${lc}/signout.html"
				// 	signoutUrl: "https://www-304.ibm.com/pkmslogout?page="
				// },	
				// 	// URL to use for the signin/register overlay iframes
				// 	// details are in the files in /common/v17/register
				// 	signinUrl: "https://www.ibm.com/gss/instantprofile/InstantSignin?",
				// 	registerUrl: "https://www.ibm.com/gss/instantprofile/InstantRegisterServlet?requestType=registerPart1&",
				// 	// path to where the signin/register files are stored
				// 	codeRepository: "//1.www.s81c.com/common/v17/register/${NAME}.js"
				// },
				// The bit.ly API key
				bitly: {
					login: "ibmdigital",
					key: "R_1ed9169df98d3b072731d88ec80d18a7",
					timeout: 3000	// in milliseconds
				},
				noticechoice: {
					jsonUrl: "//1.www.s81c.com/common/translations"
				},
				opinionlab: {
					footer: {
						enabled: false,
						type: "overlay"
					},
					floating: { 
						enabled: false,
						//type: "overlay"
						//RTC #349997 - change default set on "popup"
						type: "popup",
						//RTC #555671 - enable vertical position on default
						verticalFloating: true
					},
					intercept: {
						enabled: false
					}
				},
				tealeaf: {
					enabled: false
				}
				// This was sunset.
				// idm: {
				// 	profiling: {
				// 		expliciturl: "https://www.ibm.com/gateway/profile_id/{INPUT_profile_id}/",
				// 		anonymousurl: "https://www.ibm.com/instantprofile/iwmoverlay/service/anouser",
				// 		filter: "//www.ibm.com/common/v17/instantprofile/blackwhite_lists.json",
				// 		profilingjs: "//www.ibm.com/common/v17/instantprofile/profiling.js"
				// 	}
				// }
			},
		
			staging: {
				usedSettings: "staging",  // Tell us these settings are being used.
				dataUrl: "//1.wwwstage.s81c.com/common/v18/js/data/",
				//coreservicesUrl: "https://www-sso.toronto.ca.ibm.com/gateway/?",
				coreservicesUrl: "https://www-sso.toronto.ca.ibm.com/gateway/secstate/?",
				coreservicesUrlSecure: "https://www-sso.toronto.ca.ibm.com/gateway/sec/?",
				
				// Set to the location of the v18 files
				jsFilesUrl: "//1.wwwstage.s81c.com/common/v18/js/",
				imageUrl: "//1.wwwstage.s81c.com/common/v18/i/",
				
				notificationServiceUrl: "https://wwwpoc.ibm.com/myibm/notifications/api/notifications/unread/count",
				//photoServiceUrl: "https://wwwpoc.ibm.com/myibm/photouploader/services/photo",
				
				noticechoice: {
					jsonUrl: "//1.wwwstage.s81c.com/common/translations"
				},
				// signin: {
				// 	formAction: "https://www-wi-sso3.toronto.ca.ibm.com:445/usrsrvc/account/userservices/ait/jsp/login.jsp?persistPage=true&PD-REFERER=none&error=&page=${page}",
				// 	signoutUrl: "https://www-sso.toronto.ca.ibm.com/pkmslogout?page=http://wwwstage.ibm.com/account/${cc}/${lc}/signout.html",
				// 	signinUrl: "https://wwwstage.ibm.com/gss/instantprofile/InstantSignin?",
				// 	registerUrl: "https://wwwstage.ibm.com/gss/instantprofile/InstantRegisterServlet?requestType=registerPart1&",
				// 	codeRepository: "//1.wwwstage.s81c.com/common/v17/register/${NAME}.js"
				// },
				idm: {
					profiling: {
						expliciturl: "https://wwwstage.ibm.com/gateway/profile_id/{INPUT_profile_id}/",
						anonymousurl: "https://wwwstage.ibm.com/instantprofile/iwmoverlay/service/anouser",
						filter: "//wwwstage.ibm.com/common/v17/instantprofile/blackwhite_lists.json",
						profilingjs: "//wwwstage.ibm.com/common/v17/instantprofile/profiling.js"
					}
				}
			},
			
			preview: {
				usedSettings: "preview",  // Tell us these settings are being used.
				dataUrl: "//1.wwwpreview.s81c.com/common/v18/js/data/",
				//coreservicesUrl: "https://www-sso.toronto.ca.ibm.com/gateway/?",
				coreservicesUrl: "https://www-sso.toronto.ca.ibm.com/gateway/secstate/?",
				coreservicesUrlSecure: "https://www-sso.toronto.ca.ibm.com/gateway/sec/?",
				
				// Set to the location of the v18 files
				jsFilesUrl: "//1.wwwpreview.s81c.com/common/v18/js/",
				imageUrl: "//1.wwwpreview.s81c.com/common/v18/i/",
				
				//notificationServiceUrl: "https://myibm-notifications-prod.mybluemix.net/myibm/notifications/api/notifications/unread/count",
				//photoServiceUrl: "https://photouploaderapi.eu-gb.mybluemix.net/myibm/photouploader/services/photo",
				//photoServiceUrl: "https://wwwpoc.ibm.com/myibm/photouploader/services/photo",
				notificationServiceUrl: "https://wwwpoc.ibm.com/myibm/notifications/api/notifications/unread/count",
				
				noticechoice: {
					jsonUrl: "//1.wwwpreview.s81c.com/common/translations"
				},
				// signin: {
				// 	formAction: "https://www-wi-sso3.toronto.ca.ibm.com:445/usrsrvc/account/userservices/ait/jsp/login.jsp?persistPage=true&PD-REFERER=none&error=&page=${page}",
				// 	signoutUrl: "https://www-sso.toronto.ca.ibm.com/pkmslogout?page=http://wwwstage.ibm.com/account/${cc}/${lc}/signout.html",
				// 	signinUrl: "https://wwwstage.ibm.com/gss/instantprofile/InstantSignin?",
				// 	registerUrl: "https://wwwstage.ibm.com/gss/instantprofile/InstantRegisterServlet?requestType=registerPart1&",
				// 	codeRepository: "//wwwstage.ibm.com/common/v17/register/${NAME}.source.js"
				// },
				idm: {
					profiling: {
						expliciturl: "https://wwwstage.ibm.com/gateway/profile_id/{INPUT_profile_id}/",
						anonymousurl: "https://wwwstage.ibm.com/instantprofile/iwmoverlay/service/anouser",
						filter: "//wwwstage.ibm.com/common/v17/instantprofile/blackwhite_lists.json",
						profilingjs: "//wwwstage.ibm.com/common/v17/instantprofile/profiling.js"
					}
				}
			},
			
			development: {
				usedSettings: "development",  // Tell us these settings are being used.
				dataUrl: "//1.wwwpreview.s81c.com/common/js/dynamicnav/www/",
				coreservicesUrl: "https://www.ibm.com/gateway/secstate/?",
				imageUrl: "/i/v17/",
				annotatorServUrl: "https://iebalpha.cdtdp.toronto.ca.ibm.com:3443/transform/public/service/common_profile_test/profile/shared/",	
				noticechoice: {
					jsonUrl: "//1.www.s81c.com/common/translations"
				},
				// signin: {
				// 	formAction: "https://www-sso.toronto.ca.ibm.com/usrsrvc/account/userservices/ait/jsp/login.jsp?persistPage=true&PD-REFERER=none&error=&page=${page}",
				// 	signoutUrl: "https://wwwbeta-sso.toronto.ca.ibm.com:444/pkmslogout?page=http://v17ecmpreview.webmaster.ibm.com/accoun/${cc}/${lc}/signout.html",
				// 	signinUrl: "https://wwwtest.ibm.com/gss/instantprofile/InstantSignin?",
				// 	registerUrl: "https://wwwtest.ibm.com/gss/instantprofile/InstantRegisterServlet?requestType=registerPart1&",
				// 	codeRepository: "//wwwtest.ibm.com/common/v17/register/${NAME}.source.js"
				// },
				idm: {
					profiling: {
						expliciturl: "https://wwwtest.ibm.com/gateway/profile_id/{INPUT_profile_id}/",
						anonymousurl: "https://wwwtest.ibm.com/ibmweb/idm/instantprofile/iwmoverlay/service/anouser",
						filter: "//wwwtest.ibm.com/common/v17/instantprofile/blackwhite_lists.json",
						profilingjs: "//wwwtest.ibm.com/common/v17/instantprofile/profiling.js"
					}
				}		
			}
		};
	
	
	// Everything below is the same for both w3 and www versions of this file.
	// It"s just easier (maintenance-wise) to keep the setter function with the settings, 
	//   instead of splitting it into a separate common JS file.
	
	/**
		Check to see if we need to override some of the production settings with different environment settings.
		Allows you to set/force a build using non-production values. The order is:
			1. Production.
			2. FORCED through the build.
			3. COOKIE through our special cookie.
	*/	
	function applyAlternateSettings ()  {
		var envCookie = document.cookie.match(/__forcev18env=(\w*)/),  // "dev|staging|preview|".
			configName = IBM.common.config.ibmForceConfig || "";  // "dev|staging|preview|".
		
		// #1. Check if we forced a config thru the build (var at top), and set flag if so.
		if (configName) {
			IBM.common.config.forced = true;
		}
		
		// #2. Check for environment cookie that overrides whatever the build says to use.
		if (envCookie && envCookie[1] !== "") {
			configName = envCookie[1];
			IBM.common.config.forced = false;
		}

		// Now apply the alternate settings if we need to and they are valid settings.
		if (configName !== "" && configName !== "production" && settings[configName]) {
			$.extend(true, IBM.common.config, settings[configName]);
		}
	}
	
	// Hierarchy of config settings on a page:
	// 1. v18: DEFAULT: Use production settings.
	// 2. v18: Check for config cookie to merge in non-production settings.
	// 3. Page-level: Merge in settings from digitalData object to override (requirement to exist before www.js).
	// 4. Page-level: Any ad-hoc config.sets util calls from the page JS.

	// DEFAULT: Use all production settings.
	$.extend(true, IBM.common.config, settings.production);
	
	// Check if we need to override with non-prod settings and merge them in.
	applyAlternateSettings();
	
	// Page level: Merge in anything from digitalData object.
	if (window.digitalData && window.digitalData.page && window.digitalData.page.pageInfo && window.digitalData.page.pageInfo.ibm) {
		$.extend(true, IBM.common.config, window.digitalData.page.pageInfo.ibm.config || {});
	}
	
})(jQuery, IBMCore);
;

/**

	Great little URL helpers.
	<br />
	<br />Utilities to help with misc URL-related functionality.
	
	@class IBMCore.common.util.url
		
**/

(function ($, IBM) {

	// Create our namespace and make a shortcut to it for ourselves.
	var me = IBM.namespace(IBM, "common.util.url");


	/**
		Internal function that does the URL editing of adding/removing params.
		<br />The add/remove APIs call this to do the actual work.

		@method editUrl
		@private
		@param dataObj {Object} Object with data:
		@param dataObj.action {String} What to do... add (replace) or remove a param.
		@param dataObj.url {String} The URL string to modify.
		@param dataObj.paramName {String} The name of the param to add.
		@param dataObj.paramValue {String} The value of the param to add.
		@return {String} The new URL string with the new name/value param added (or replaced if it existed).
	**/
	function editUrl (dataObj) {
		var url = dataObj.url,
			urlBase = url,
			qs = (url.indexOf("?") > -1 ? url.substr(url.indexOf("?")+1) : "").split("#")[0],
			hash = url.indexOf("#") > -1 ? url.substr(url.indexOf("#")) : "",
			params = {};

		// If the URL has a QS, (re)set the base URL and convert param string to obj.
		if (qs !== "") {
			urlBase = url.substr(0, url.indexOf("?"));
			params = me.paramsToObject(qs);
		}

		// If the URL has a hash, (re)set the base URL.
		if (hash !== ""){
			urlBase = url.substr(0, url.indexOf("#"));
		}

		// Add/Remove the param to the object.
		if (dataObj.action === "add") {
			params[dataObj.paramName] = dataObj.paramValue;
		}
		else if (dataObj.action === "remove") {
			delete params[dataObj.paramName];
		}

		// Concat the URL pieces back and return to requestor.
		return urlBase + "?" + me.objectToQuerystring(params) + hash;
	}


	/**
		Adds a name/value pair (URL param) to the passed URL string and returns the new URL string.
		<br />If param already exists, it will replace the value.
	
		@method addParam
		@param dataObj {Object} Object with settings:
		@param dataObj.url {String} The URL string to modify.
		@param dataObj.paramName {String} The name of the param to add.
		@param dataObj.paramValue {String} The value of the param to add.
		@return {String} The new URL string with the new name/value param added (or replaced if it existed).
		@example
			var newUrl = IBMCore.common.util.url.addParam({
				url: window.location.href
				paramName: "showtabs",
				paramValue: "yes"
			});
	**/
	me.addParam = function (dataObj) {
		dataObj.action = "add";
		return editUrl(dataObj);
	};

	/**
		Removes a param from the passed URL string (if exists) and returns the new URL string.
	
		@method removeParam
		@param dataObj {Object} Object with settings:
		@param dataObj.url {String} The URL string to modify.
		@param dataObj.paramName {String} The name of the param to remove.
		@return {String} The new URL string with the param removed (if it existed).
		@example
			var newUrl = IBMCore.common.util.url.removeParam({
				url: window.location.href
				paramName: "showtabs",
			});
	**/
	me.removeParam = function (dataObj) {
		dataObj.action = "remove";
		return editUrl(dataObj);
	};

	/**
		Get all URL params from the browser's current URL as a single object.
		<br />__Note:__ If you just want a single URL param by name, use the "getParam" function instead.

		@method getAllParams
		@param [url] {String} The URL to parse the params out of. If none passed, the browser's URL is used.
		@return {Object} All params from the URL used as object properties.
		@example
			var urlParams = IBMCore.common.util.url.getAllParams();
			var refCode = urlParams.cm_re;
	**/
	me.getAllParams = function (url) {
		var params = me.urlParams;

		// If they passed in a string, extract the params from the custom string instead of the page's loaded URL.
		if (url && url !== "") {
			params = {};

			if (url.indexOf("?") > -1) {
				params = me.paramsToObject(url);
			}
		}

		return params;
	};

	/**
		Get a single URL param from a URL string.
		<br />You can pass in a custom URL string to use, otherwise the browser's URL is used.
		<br />__NOTE:__ If you want to get all params from a URL in one shot, use the "getAllParams" function instead.

		@method getParam
		@param paramName {String} The param you want to get the value for.
		@param [str] {String} A custom URL string to parse. Otherwise the browser's URL is used (default).
		@return {String} The value of the param *if the param exists*, else returns undefined.
		@example
			var refCode = IBMCore.common.util.url.getParam("cm_re");
	**/
	me.getParam = function (paramName, str) {
		var customParams = {},
			paramValue = me.urlParams[paramName];

		// If they passed in a string, extract the param from the custom string instead of the page's loaded URL.
		if (str && str !== "") {
			customParams = me.paramsToObject(str);
			paramValue = customParams[paramName];
		}

		return paramValue;
	};
	
	/**
		Get the page's URL. Uses the canonical meta value if exists, else the current browser URL.

		@method getUrl
		@return {String} The URL as found in the canonical meta tag value, else the current browser URL minus tracking params.
	**/
	me.getUrl = function () {
		var url = $('link[rel="canonical"]').attr('href');

		// If canoncial tag exists, returned it as-is.
		if (url) {
			return url;
		}

		// If no canonical, remove some metrics/tracking parameters from currentl browser URL, then return a clean URL.
		url = location.href;

		// Strip misc parameters used for metrics tracking.
		if (url.indexOf('?') !== -1) {
			var prefix = url.substr(0, url.indexOf('?')),
				parts = url.substr(url.indexOf('?') + 1).split('&'),
				regex = /^(cm_re|ca|me|met|re|lnk)=/,
				newparts = [],
				i, j;

			for (i = 0, j = parts.length; i < j; i++) {
				if (!regex.test(parts[i])) {
					newparts.push(parts[i]);
				}
			}

			if (newparts.length > 0) {
				url = prefix + '?' + newparts.join('&');
			} 
			else {
				url = prefix;
			}
		}

		return url;
	};

	/**
		Parses all name/value params from a querystring and returns them all in a single object.
		<br />Used onload and automatically puts all URL params into common object.
		<br />See "parseCurrentUrlParams" method.

		@method paramsToObject
		@param str {String} The string to parse out name/value pair parameters from.
		@return {Object} An object with all name/value pairs as properties.
	**/
	me.paramsToObject = function (str) {
		var paramObj = {};

		if (!str || str === "") {
			return paramObj;
		}

		// If they accidentally passed a full URL that has ? in it, parse out just the querystring.
		// Otherwise we HAVE to assume they passed just the querystring b/c there's no way to tell.
		if (str.indexOf("?") > -1) {
			str = str.substr(str.indexOf("?")+1);
		}

		$.each(str.split("&"), function (k,v) {
			var nameVal = v.split('=');

			// Trim to remove leading/trailing spaces, then only add if there's a value param name.
			nameVal[0] = $.trim(nameVal[0]);
			nameVal[1] = $.trim(nameVal[1]) || "";

			// If there's a param name (required) process it.
			if (nameVal[0]) {
				// If it's a basic name/value URL param, add it as key/value.
				// Else if it's an array type URL param, add name to object as an array and pust the values into it.
				if (nameVal[0].indexOf("[]") === -1) {
					paramObj[decodeURIComponent(nameVal[0])] = decodeURIComponent(nameVal[1]);
				}
				else if (nameVal[0].indexOf("[]") > -1) {
					// If it doesn't yet exist, create it, then append value to array.
					if (!paramObj[decodeURIComponent(nameVal[0])]) {
						paramObj[decodeURIComponent(nameVal[0])] = [];
					}
					paramObj[decodeURIComponent(nameVal[0])].push(decodeURIComponent(nameVal[1]));
				}
			}
		});
		
		return paramObj;
	};
	
	/**
		Concats a basic object of name/value pairs into a URL param string. Like a "stringify" function.
		
		@method objectToQuerystring
		@param dataObj {Object} An object with all name/value pairs as properties.
		@return {String} The name/value pairs from the inbound object represented as URL params string (separated with &).
	**/
	me.objectToQuerystring = function (dataObj) {
		var querystring = "",
			i = 0;

		// For each param in the object, stringify it.
		// If it's an array, we need to do a special loop to build a name/value pair for each value.
		$.each(dataObj, function (k, v) {
			if (k !== "" && typeof v === "string") {
				querystring += "&" + k + "=" + v;
			}
			else if (typeof v === "object") {
				for (i = 0; i < v.length; i++) {
					querystring += "&" + k + "=" + v[i];
				}
			}
		});

		querystring = querystring.substr(1);

		return querystring;
	};

	/**
		Gets the browser's current URL's querystring and parses into common object for use by utilities: getParam &amp; getAllParams.

		@method parseCurrentUrlParams
		@private
	**/
	function parseCurrentUrlParams () {
		me.urlParams = me.paramsToObject(window.location.search.substr(1));
	}
	
	// Automatically parse out the browser's current URL params into public object.
	// Used by by getAllParams and getParam functions... they just pull from public object.
	parseCurrentUrlParams();
	
})(jQuery, IBMCore);

;

/**

	Color utilities. 
	<br />
	<br />Takes a color and does various things with it (awesome description, I know).
	<br />Used for overlay and tooltips to easily support cross-browser color support on custom colored overlay and tooltips.
	<br />
	<br />Usage:
		
		// Using the background color, figure out and set the proper text color 
		//  for the proper contrast ratio for accessibility.
		var bgColor = IBM.common.util.color.createColor("#f3ac89");
		$("#someContentId").css("color", bgColor.accessibleTextColor);

	@class IBMCore.common.util.color

**/

(function ($, IBM) {

	// Create our namespace and make a shortcut to it for ourselves.
	var colorUtil = IBM.namespace(IBM, "common.util.color");

	/**
		Method to creates a new color object using color and optional alpha values. Returns new color object instance.
		
		@method createColor {Function} 
		@param [color] {Varies} Color code. Can be hex, rgb(), or rgba(). If an alpha param is passed, it will override the rgba's alpha value.
		@param [alpha] {Integer} Alpha value to use for the color.
		@return {Object} "Color" object with properties. This returned object has methods: .xxxxxx
	**/
	colorUtil.createColor = function (color, alpha) {
		return new Color(color, alpha);
	};
	
	/** 
		The Color object.
		<br />Instantiated with our one and only public util function.
		
		@method Color
		@constructor
		@private
		@param [color] {Varies} Color code. Can be hex, rgb(), or rgba(). If an alpha param is passed, it will override the rgba's alpha value.
		@param [alpha] {Integer} Alpha value to use for the color.
	**/
	function Color(color, alpha) {
		var me = this;

		me.red = 0;
		me.green = 0;
		me.blue = 0;
		me.alpha = 0;
		me.accessibleTextColor = null;

		/**
			Automatically called on new Color instance constructor if a color is provided. 
			Sets object's R,G,B,A and accessible text color values.
			
			@method <yourObj>.setColor
			@param color {Varies} Color code. Can be hex, rgb(), or rgba(). If an alpha param is passed, it will override the rgba's alpha value.
		**/
		me.setColor = setColor;
		function setColor(newColor) {
			var color = newColor,
				s;
				
			// If the color is a hex, convert it to RGB values and set properties.
			// Otherwise it's already RGB, so set properties.
			if (color.charAt(0) === "#") {
				if (color.length === 4){
					color = "#" + color.charAt(1) + color.charAt(1) + color.charAt(2) + color.charAt(2) + color.charAt(3) + color.charAt(3);
				}
				me.red = (rgbToDec(color.charAt(1)) * 16) + rgbToDec(color.charAt(2));
				me.green = (rgbToDec(color.charAt(3)) * 16) + rgbToDec(color.charAt(4));
				me.blue = (rgbToDec(color.charAt(5)) * 16) + rgbToDec(color.charAt(6));
				me.alpha = 1;
				
				// Tell them what the proper accessible opposite text color is, black or white.
				me.accessibleTextColor = generateAccessibleTextColor(color);
				
			} 
			else {
				s = color.substring(color.indexOf("(") + 1, color.indexOf(")"));
				s = s.split(",");
				me.red = parseInt(s[0], 10);
				me.green = parseInt(s[1], 10);
				me.blue = parseInt(s[2], 10);
				me.alpha = parseFloat(s[3], 10);
				
				// Tell them what the proper accessible opposite text color is, black or white.
				// This converts the RGB to hex then passes it to the function.
				me.accessibleTextColor = generateAccessibleTextColor(me.hex());
				
			}
		}
		
		/**
			Returns the hex value of the color.
			
			@method <yourObj>.hex
			@return {String} Hex value of the color.

		**/
		me.hex = hex;
		function hex() {
			return "#" + decToRGB(me.red) + decToRGB(me.green) + decToRGB(me.blue);
		}
		
		/**
			Returns the rgb() value of the color.
			
			@method <yourObj>.rgb
			@return {String} Value of the color in syntax: "rgb(x,x,x)"

		**/
		me.rgb = rgb;
		function rgb() {
			return "rgb(" + me.red + "," + me.green + "," + me.blue + ")";
		}

		/**
			Returns the rgba() value of the color. If IE8 or lower, returns rgb().
			
			@method <yourObj>.rgba
			@return {String} Value of the color in syntax: "rgba(x,x,x,x)"

		**/
		me.rgba = rgba;
		function rgba() {
			if ($.browser.msie && $.browser.versionNumber < 8) {
				return rgb();
			}
			
			return "rgba(" + me.red + "," + me.green + "," + me.blue + "," + me.alpha + ")";
		}

		/**
			__NOTE: Currently not working as designed. Needs fixing.__
			<br />Take a Color object and mix it with another color to create a new one.
		
			@method <yourObj>.generateMix
			@param addedColor {Varies} Hex color, or another color object.
			@param [alpha] {Integer} Alpha value to use for the color.
			@return {Object} Returns a new Color object.
		**/
		me.generateMix = generateMix;
		function generateMix(addedColor, alpha) {
			if (typeof addedColor === "string") {
				addedColor = colorUtil.createColor(addedColor);
			}

			if (alpha) {
				addedColor.alpha = alpha;
			}

			var generated = colorUtil.createColor();

			generated.red = Math.floor(me.red + ((addedColor.red - me.red) * addedColor.alpha));
			generated.green = Math.floor(me.green + ((addedColor.green - me.green) * addedColor.alpha));
			generated.blue = Math.floor(me.blue + ((addedColor.blue - me.blue) * addedColor.alpha));
			generated.alpha = me.alpha + Math.min(1, Math.max(0, (1 - me.alpha) * addedColor.alpha));

			return generated;
		}

		
		/**
			Converts a single hex value (0-9a-f) to the RGB equivalent (then later is multiplied by 16).
			
			@method rgbToDec
			@private
			@param rgb {String|Integer} 0-9 or a-f. Gets normalized by lowercasing, so value is case insensitive.
			@return {Integer} Position # of parameter in 0-9A-F array, to be used in RGB color code.

		**/
		function rgbToDec(rgb) {
			return "0123456789abcdef".indexOf(rgb.toLowerCase());
		}

		/**
			Converts a r, g or b number to the two character hex value equivalent (0-9a-f)(0-9a-f).
			
			@method decToRGB
			@private
			@param dec {Integer} The r, g, or b value from a rgb() color code.
			@return {String} 0-9 or a-f.

		**/
		function decToRGB(dec) {
			var a = Math.floor(dec / 16),
				b = dec % 16,
				codes = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];
			return codes[a] + codes[b];
		}
		
		/**
			Takes a color and returns the accessible correct color that text should be if used on that color background: black or white.
			@method generateAccessibleTextColor
			@private
			@param hexcolor {String} Hex color.
			@return {String} "black" or "white".
		**/
		function generateAccessibleTextColor (hexcolor){
			// Remove the leading "#" in case we get it passed to us in the hex color.
			hexcolor = hexcolor.substr(0,1) === "#" ? hexcolor.substr(1) : hexcolor ;
			var r = parseInt(hexcolor.substr(0,2),16),
				g = parseInt(hexcolor.substr(2,2),16),
				b = parseInt(hexcolor.substr(4,2),16),
				yiq = ((r*299) + (g*587) + (b*114)) / 1000;

			return (yiq >= 128) ? "black" : "white";
		}
	
		if (typeof color !== "undefined") {
			me.setColor(color);
		}

		if (typeof alpha !== "undefined") {
			me.alpha = alpha;
		}
	}
	
})(jQuery, IBMCore);

;

/** 

	Cookie utilities.
	<br />
	<br />Use this wherever possible so only one common and secure cookie implementation exists.
	<br />Use these functions and don't write your own.

	@class IBMCore.common.util.cookie
	
**/

(function($, IBM) {

	var me = IBM.namespace(IBM, "common.util.cookie");

	/**
		Sets a new cookie with the given data. Name and value are required.

		@method set
		@param {String} name Name of the cookie.
		@param {String} value Value to set.
		@param {Object} [options] Object with optional cookie settings:
		@param {String} [options.expires] Expire date or TTL in seconds.
		@param {String} [options.path] Path of the cookie.
		@param {String} [options.domain] Domain of the cookie.
		@param {Boolean} [options.secure] Flag if the cookie should be secure.
	**/
	me.set = function (name, value, options) {
        var expiresDate = null,
			expires;
			
		options = options || {};
		expires = options.expires;
			
        if (expires) {
            if (expires.toUTCString) {
                expiresDate = expires;
            } 
			else if (typeof expires === "number") {
                expiresDate = new Date();
                expiresDate.setTime(expiresDate.getTime() + 1000 * parseInt(expires, 10));
            }
        }

        document.cookie = name + "=" + encodeURIComponent(value) + 
			((expiresDate) ? "; expires=" + expiresDate.toUTCString() : "") + 
			((options.path) ? "; path=" + options.path : "") + 
			((options.domain) ? "; domain=" + options.domain : "") + 
			((options.secure) ? "; secure" : "");
    };
	
	
    /**
		Returns the value of a cookie, if set.
		
		@method get
		@param {String} name Name of the cookie.
		@return {Varies} Value stored in the cookie, null otherwise.
	**/
    me.get = function (name) {
        // Find beginning of cookie value in document.cookie
        // Note: cookie with more specific path comes first!
        var prefix = name + "=",
			begin = document.cookie.indexOf(prefix),
			end;
        
		if (begin === -1) {
            return null;
        }
		
		if (begin > 0) {
            begin = document.cookie.indexOf("; " + prefix);
            
			if (begin === -1) {
                return null;
            }
			
			begin += 2;
        }

        // Find end of cookie value
        end = document.cookie.indexOf(";", begin);
        if (end === -1) {
			end = document.cookie.length;
		}

        // Return cookie value
        return decodeURIComponent(document.cookie.substring(begin + prefix.length, end));
    };
	

    /**
		Removes a cookie
		
		@method remove
		@param {String} name Name of the cookie.
		@param {String} [path] Path of the cookie.
		@param {String} [domain] Domain of the cookie.
		@return {Varies} The value of the cookie we removed.
	**/
    me.remove = function (name, path, domain) {
        var value = me.get(name);
        
		if (value !== null) {
			document.cookie = name + '=' + ((path) ? '; path=' + path : '') + ((domain) ? '; domain=' + domain : '') + '; expires=' + new Date(0).toUTCString();
		}
		
        return value;
    };

	
    /**
		Checks if a certain cookie can be set and read again.
		To check if cookies are enabled, use the "isSupported()" method instead.
		
		@method isAllowed
		@private
		@param {String} [expires] Expiration date for the cookie.
		@param {String} [path] Path of the cookie.
		@param {String} [domain] Domain of the cookie.
		@param {Boolean} [secure] Secure flag for the cookie.
		@return {Boolean} True if the cookie can be set, false otherwise.
	**/
	function isAllowed (expires, path, domain, secure) {
        var name = "allowsCookies",
			value = Math.random(),
			returnBool = false;

        me.set(name, value, (expires||""), (path||""), (domain||""), (secure||""));

        if (me.get(name) === value) {
            me.remove(name, path, domain);
            returnBool = true;
        }
		
		return returnBool;
	}

	
    /**
		Quick check to see if user has cookies enabled.
		
		@method isSupported
		@param {String} [path] Specific path to test.
		@return {Boolean} True if cookies are allowed, false otherwise.
	**/
    me.isSupported = function (path) {
        return isAllowed(0, (path||""));
    };

})(jQuery, IBMCore);
;

/**

	This namespace provides functions to load data (=JS objects) for JavaScript,
	depending on the cc/lc settings of the page. Its aim is simplicity in using it and being able
	to re-use for i.e. translations.
	<br />
	By default all URLs are loaded from //www.ibm.com/common/translations/{TOKEN}/{CC}/{LC}/{ENC}.js,
	which is the location where ECM prints out the translation files. The files have to be in a specific
	format to work with the data framework:
	<br />
	<br />Usage:
			
		// Sample static file contents:
		IBMCore.common.util.data.provide("TOKEN", {
			"title": "My Title in German",
			"desc": "Well, this is the GERMAN translation"
		});

	The static file must call the provide() callback and pass in the unqiue token and  any object containing data.
	<br /><br />Custom JS on page usage:
		
	// Once the static files are in place the user can call the get function to say "I need these translations, and when you get them, call my callback function passing them to me" ex:
	IBMCore.common.util.data.get("test1", function(trans) {
		jQuery("#trans1_title").html(trans.test1.title); // You can reference the locally passed object.
		jQuery("#trans1_desc").html(IBMcore.common.translations.data.test1.desc); // Or you can reference the full global object path.
	});

	In the above sample the translation identified by the token "test1" is being loaded from ibm.com and once loaded 
	the callback function is executed and is passed the specific translations object that was requested. The JS then uses the translations and changes the text in the specified DOM elements.
	<br />
	<br />
	__NOTE:__ Certain tokens are not allowed: get, provide, settings, exists

	@class IBMCore.common.util.data
	
**/

(function($, IBM) {

	// Create name space for this thing and make a shortcut to it for ourselves.
	var me = IBM.namespace(IBM, "common.util.data"),
		settings = {
			"url": "//www.ibm.com/common/translations/{TOKEN}/{CC}/{LC}/{ENC}.js",
			"cc": null,
			"lc": null,
			"enc": null
		};

	/**
		Private helper function to check if a specific key/object in the translations data exists and return true|false.
		
		@method objExists
		@private
		@param token {String} The unique translation data object/token.
	**/
	function objExists (token) {
		return !!IBM.common.translations.data[token];
	}

	/**
		Gets the requested data file and executes the callback once it has been loaded.
		<br />The token can be an array, i.e. ["token1", "token2"]. In this case the callback is executed
		after all tokens have been loaded.
		<br />If we already have those translation sets then the callback is executed immediately and no file request is made (DUH).
		<br />This works by replacing the vars in the standard URL naming convention for translations with the token and CC and LC to build the URL of the JS to get. LC, CC and ENC are used from the page's meta, or you can override them by passing them as optional param object values:
		<br />//www.ibm.com/common/translations/{TOKEN}/{CC}/{LC}/{ENC}.js
		
		@method get
		@param token {String|Array} The unique data token to load or URL to load. Can be an array for bundled translation requests.
		@param [callback] {Function} Callback to execute once the translations have been loaded.
		@param [params] {Object} An object with settings that override the default settings (cc, lc, encoding to use).
	**/
	me.get = function (token, callback, params) {
		var translationsExist = true,
			appliedSettings,
			i, j;

		if (!token) {
			return;
		}

		// Convert a string to an array to normalize it.
		if (!$.isArray(token)) {
			token = [token];
		}

		// Use as a flag so we know if we need to request any files or not.
		for (i = 0, j = token.length; i < j; i++) {
			translationsExist = translationsExist && objExists(token[i]);
		}

		// If not all of the requested translation objects exist, request ones we need then exec the callback.
		if (!translationsExist) {
			appliedSettings = $.extend(settings, params);

			// Wait for meta data to be ready. Don't do pub/sub because we have inbound params we need to keep here.
			IBM.common.util.queue.push(function() {
				return IBM.common.meta.isLoaded;
			}, function() {
				// Function called that replaces vars in URL then gets JS file.
				var getScript = function (singleToken) {
						var url = appliedSettings.url
							.replace('{CC}', appliedSettings.cc || IBM.common.meta.page.pageInfo.ibm.cc)
							.replace('{LC}', appliedSettings.lc || IBM.common.meta.page.pageInfo.ibm.lc)
							.replace('{TOKEN}', singleToken)
							.replace('{ENC}', appliedSettings.enc || IBM.common.meta.page.pageInfo.ibm.encoding);

						// Request the file.
						//$.getScript(url);

						$.ajax({
								url: url,
								dataType: "script",
								cache: true
							}).fail(function (message) {
								console.error('Error while loading translation file for token: ' + singleToken, message);
							});
					},
					i, j;

				// Loop thru each requested token and get it if we don't have it already.
				for (i = 0, j = token.length; i < j; i++) {
					if (!objExists(token[i])) {
						getScript(token[i]);
					}
				}

				// Wait until all of the requested tokens exist, then execute the callback.
				IBM.common.util.queue.push(function () {
					var translationsExist = true,
						i, j;
					
					for (i = 0, j = token.length; i < j; i++) {
						translationsExist = translationsExist && objExists(token[i]);
					}

					return translationsExist;
				}, function () {
					if (typeof callback === "function") {
						callback(IBM.common.translations.data);
					}
				});
			});

		} 
		else {
			// All requested tokens (translation objects) already exist, so just exec their callback.
			if (typeof callback === "function") {
				callback(IBM.common.translations.data);
			}
		}
	};

	/**
		Function used/called by static translation JS files. 
		<br /Provides a standard API to put translations into the common translations.data object.
		<br />Provide the unique data token as first argument (what the translations are for) and any object as second argument (the translations).
		
		@method provide
		@param token {String} The unique data token to use as the translation object key: translations.data.<$token>
		@param data {Object} The translation data object put inside the $token namespace.
	**/
	me.provide = function(token, dataObject) {
		IBM.common.translations.data[token] = dataObject;
	};

	// Add legacy function alias until the ECM translations are changed for v18 for expert locator widget.
	window.ibmweb = window.ibmweb || {};
	IBM.namespace(window.ibmweb, "data");
	window.ibmweb.data.provide = me.provide;

})(jQuery, IBMCore);
;

/**

	Publish/subscribe messaging utility. 
	<br />
	<br />An event messaging utility that allows owners to publish messages that any other script can subscribe to and be notified when they happen. The event coordinator performs a store and forward function to route messages from publishers to subscribers.
	<br />A "notify me when ____ happens" utility that provides a far more efficient way to know when events happen, rather than setting up a listener loop and continuously polling to see if something happened yet. For example... instead of asking your dad "are we there yet?" every 5 minutes on a 2 hour drive, you say "tell me when we're there."
	<br />
	<br />Usage:
		
		// Setup events to publish and let other code subscribe to.
		myEvents = IBMCore.common.util.eventCoordinator(myPublicObject "my nice name", [
			"ready",
			"loading",
			"error"
		]);
		
		// Publish an event.
		myEvents.publish("ready");
		
		// Subscribe to someone's event:
		someoneElsesPublicObject.subscribe("ready", "my name", myCallbackFunctionName);

	@class IBMCore.common.util.eventCoordinator

**/

(function (IBM) {

	/**
		The main utility that creates your events messaging system for your class/object/code.
		
		@method eventCoordinator 
		@param that {Object} Your object which you are setting up events for. It gets pub/sub object and methods merged into it.
		@param class_name {String} The nice-name of your object. Used for debugging purposes.
		@param event_names {Array} An array of names of events (strings) you will publish, and to which other JS can subscribe to.
		@return {Object} A new EventsCoordinator object with all messaging and methods setup for the named events.
	**/
	IBM.common.util.eventCoordinator = function (that, class_name, event_names) {
		return new EventsCoordinator(that, class_name, event_names);
	};

	var stop_propagation = false;

	/**
		This is the actual internal class constructor that the public utility abstracts.
		
		@method EventsCoordinator
		@constructor
		@private
	**/
	function EventsCoordinator(that, class_name, event_names) {
		var me = this,
			handlers = {},
			run_now = null,
			instance_name = null,
			i,
			len = event_names.length;
			
		for (i = 0; i < len; i++) {
			handlers[event_names[i].toLowerCase()] = new EventHandler(that, event_names[i].toLowerCase());
		}

		me.handlers = function () {
			return handlers;
		};

		/**
			Internal utility. Used to merge pub/sub events into the object that owns the events we're setting up.

			@method mergeWith
			@param obj {Object} The event owning object to merge the pub/sub methods into.
		**/
		me.mergeWith = function (obj) {
			run_now = null;

			var merge_methods = [
					"subscribe",
					"unsubscribe",
					"resumeSubscription",
					"pauseSubscription",
					"publish",
					"handlers",
					"stopPropagation"],
				i,
				len = merge_methods.length,
				method;

			for (i = 0; i < len; i++) {
				method = merge_methods[i];
				if (typeof(that[method]) === "undefined") {
					that[method] = me[method];
				}
				else {
					console.warn("Cannot merge event handler method '" + method + "' for " + that.toString() + ".");
				}
			}

			that.instanceName = function (new_name) {
				if (arguments.length === 0) {
					return instance_name;
				}

				instance_name = new_name;
			};

			that.toString = function () {
				if (instance_name) {
					return ("[ {{class_name}}: {{instance_name}} ]")
						.replace("{{class_name}}", class_name)
						.replace("{{instance_name}}", instance_name);
				}

				return ("[ {{class_name}} ]").replace("{{class_name}}", class_name);
			};

			that.event_coordinator = me;
		};

		/**
			Subscribe to the object's event and be notified when it happens (runs callback function.)

			@method subscribe
			@param event_name {String} The name of the owning object's event to subscribe to.  
			@param owner {String} The name of your code/object that's subscribing. (Same name is used for unsubscribing.)
			@param fn {Function} The function to call when the event happens.
			@param [prepend] {Boolean} Set to true if you have multiple subscriptions to the same event and you want this one prepended to the event's callback array.
			@return {Object} Returns your event coordinator object.
			@example
				some_widget_object.subscribe("ready", "my name", myCallbackFunctionName);
		**/
		me.subscribe = subscribe;
		function subscribe(event_name, owner, fn, prepend) {
			run_now = null; // overwritten later

			if (typeof owner === "undefined") {
				console.warn("Cannot call on() with an undefined owner.");
				return me;
			}

			var handler = handlers[event_name.toLowerCase()];
			if (handler) {
				handler.add(owner, fn, prepend);
			}
			else {
				console.warn("on() - No event name found: " + event_name);
			}

			run_now = {
				fn : fn,
				owner : owner,
				event_name : event_name
			};

			return me;
		}

		/**
			Unsubscribe from the object's event.

			@method unsubscribe
			@param event_name {String} The name of the event to unsubscribe to.
			@param owner {String} The name of your code/object that's unsubscribing. (Same name is used for subscribing.)
			@return {Object} Returns your event coordinator object.
			@example
				some_widget_object.unsubscribe("ready", "my name");
		**/
		me.unsubscribe = unsubscribe;
		function unsubscribe(event_name, owner) {
			run_now = null;

			if (typeof event_name === "undefined") {
				console.warn("Cannot call unsubscribe() with an undefined event_name.");
				return me;
			}

			var handler = handlers[event_name.toLowerCase()];
			if (owner) {
				handler.remove(owner);
			}
			else {
				//console.warn("unsubscribe() - No event name found: " + event_name);
				handler.reset();
			}

			return me;
		}

		/**
			Resume a paused subscription.

			@method resumeSubscription
			@param event_name {String} The name of the event to resume the subscription for.
			@param owner {String} The name of your code/object that's resuming the subscription for (same name is used for subscribing.)
			@return {Object} Returns your event coordinator object.
			@example
				some_widget_object.resumeSubscription("ready", "my name");
		**/
		me.resumeSubscription = resumeSubscription;
		function resumeSubscription(event_name, owner) {
			run_now = null;

			if (typeof event_name === "undefined") {
				console.warn("Cannot call resumeSubscription() with an undefined event_name.");
				return me;
			}

			var handler = handlers[event_name.toLowerCase()];
			if (handler) {
				if (typeof owner !== "undefined") {
					handler.resumeSubscription(owner);
				}
				else {
					handler.resumeAllSubscriptions();
				}
			}
			else {
				console.warn("resumeSubscription() - No event name found: " + event_name);
			}

			return me;
		}

		/**
			Temporarily pause a subscription.

			@method pauseSubscription
			@param event_name {String} The name of the event to pause the subscription for.
			@param owner {String} The name of your code/object that's pausing the subscription for (same name is used for subscribing.)
			@return {Object} Returns your event coordinator object.
			@example
				some_widget_object.pauseSubscription("ready", "my name");
		**/
		me.pauseSubscription = pauseSubscription;
		function pauseSubscription(event_name, owner) {
			run_now = null;

			if (typeof event_name === "undefined") {
				console.warn("Cannot call pauseSubscription() with an undefined event_name.");
				return me;
			}

			var handler = handlers[event_name.toLowerCase()];
			if (handler) {
				if (typeof owner !== "undefined") {
					handler.pauseSubscription(owner);
				}
				else {
					handler.pauseAllSubscriptions();
				}
			}
			else {
				console.warn("pauseSubscription() - No event name found: " + event_name);
			}

			return me;
		}

		/**
			Publish an event. Anyone subscribed to the named event will get their callback function run.

			@method publish
			@param event_name {String} The name of the event to publish.
			@return {Object} Returns your event coordinator object.
			@example
				myEvents.publish("ready");
		**/
		me.publish = publish;
		function publish(event_name) {
			run_now = null;

			if (typeof event_name === "undefined") {
				console.warn("Cannot call publish() with an undefined event_name.");
				return me;
			}

			var handler = handlers[event_name.toLowerCase()],
				active_owners;
				
			if (handler) {
				active_owners = handler.activeOwners();
				if (active_owners.length > 0) {
					//console.groupCollapsed(that.toString() + " publishing event \"" + event_name + "\" [" + active_owners.join(",") + "]");
					
					switch (arguments.length) {
						case 1:
							handler.publish();
							break;
						case 2:
							handler.publish(arguments[1]);
							break;
					}
					
					console.groupEnd();
				}
			}
			else {
				console.warn("publish() - No event name found: " + event_name);
			}

			return me;
		}

		/**
			Stops event publishing propagation.

			@method stopPropagation
			@deprecated
		**/
		me.stopPropagation = stopPropagation;
		function stopPropagation() {
			stop_propagation = true;
		}

		/**
			Internal utility. This is what actually runs the callback function.

			@method runNow
		**/
		me.runNow = runNow;
		function runNow() {
			if (run_now) {
				//console.groupCollapsed("Publishing event '" + run_now.event_name + "' now for '" + run_now.owner + "' via runNow()");
				
				try {
					switch (arguments.length) {
						case 0:
							run_now.fn.call(that);
							break;
						case 1:
							run_now.fn.call(that, arguments[0]);
							break;
						case 2:
							run_now.fn.call(that, arguments[0], arguments[1]);
							break;
					}
				}
				catch (er) {
					console.warn("Owner function[" + i + "] failed: " + run_now.owner);
					console.error(er);
				}
				
				console.groupEnd();
			}
		}

		/**
			Runs the named callback function if the event you're subscribing to has already happened. Use in conjunction with .subscribe() in cases where you're not sure if the event will happen before your code runs.

			@method runAsap
			@example 
				// When translations (from service) are ready, call auto init to build footer, or call immediately if already ready.
				// Translations can be cached so we need to use runAsap() also.
				IBMCore.common.translations.subscribe("dataReady", "footermenu", me.autoInit).runAsap(me.autoInit);

		**/
		me.runAsap = runAsap;
		function runAsap() {
			if (run_now) {
				var count = handlers[run_now.event_name.toLowerCase()].runCount(); // Everywhere else lowercases the event name.
				if (count > 0) {
					//console.log("asap count for '"+run_now.owner+"' - '"+run_now.event_name+"': " + count + ". Running now.");
					runNow();
				}
				// else {
				// 	console.log("Event '" + run_now.event_name + "' for '" + run_now.owner + "' will not runNow() because the event has not happened yet. But it has been bound, so will run as soon as the event occurs.");
				// }
			}
			else {
				console.warn("Event '" + run_now.event_name + "' for '" + run_now.owner + " has no function available to run.");
			}
		}

		me.mergeWith(that);
	}

	/**
		This is the actual internal class constructor that handles the events. Used by EventsCoordinator internal class.
		
		@method EventHandler
		@constructor
		@private
	**/
	function EventHandler(that, name) {
		var me = this,
			run_count = 0,
			remove_count = 0,
			active_owners = {},
			events = [];

		// Returns an array of current active owners.
		me.activeOwners = activeOwners;
		function activeOwners() {
			var ns = [],
				key;

			for (key in active_owners) {
				if (active_owners[key]) {
					ns.push(key);
				}
			}

			return ns;
		}

		me.events = events;

		// Returns the # of times an event has been run.
		me.runCount = function () {
			return run_count;
		};

		// Adds an owner to the active owner array if not there already then adds the callback to the event queue.
		me.add = add;
		function add(owner, fn, prepend) {
			if (typeof active_owners[owner] === "undefined") {
				active_owners[owner] = true;
			}

			events[prepend ? "unshift" : "push"]({
				owner : owner,
				fn : fn,
				runs : 0
			});
		}

		// Removes an event subscription for a named owner.
		me.remove = remove;
		function remove(owner) {
			var i = -1;
			while (++i < events.length) {
				if (events[i].owner === owner) {
					events.splice(i, 1);
					i--;
					remove_count++;
					//console.log("Removed " + that + " event '" + name + "' for owner " + owner);
				}
			}
		}

		// Resets all event props.
		me.reset = reset;
		function reset() {
			run_count = 0;
			active_owners = {};
			remove_count = events.length;
			events = [];
		}

		// Resume an event subscription for the named subscriber.
		me.resumeSubscription = resumeSubscription;
		function resumeSubscription(owner) {
			if (active_owners[owner]) {
				active_owners[owner] = true;
			}
			else {
				console.warn("Cannot resumeSubscription function with an unknown owner: " + name);
			}
			return me;
		}

		// Pauses an event subscription for the named subscriber.
		me.pauseSubscription = pauseSubscription;
		function pauseSubscription(owner) {
			if (active_owners[owner]) {
				active_owners[owner] = false;
			}
			else {
				console.warn("Cannot pauseSubscription function with an unknown owner: " + name);
			}
			return me;
		}

		// Resume an event subscription for the ALL subscribers.
		me.resumeAllSubscriptions = resumeAllSubscriptions;
		function resumeAllSubscriptions() {
			var key;
			for (key in active_owners) {
				active_owners[key] = true;
			}
			return me;
		}

		// Pauses an event subscription for ALL subscribers.
		me.pauseAllSubscriptions = pauseAllSubscriptions;
		function pauseAllSubscriptions() {
			var key;
			for (key in active_owners) {
				active_owners[key] = false;
			}
			return me;
		}

		// Publishes the actual event for the publisher and calls all active subscribers' callback functions.
		me.publish = publish;
		function publish() {
			stop_propagation = false;

			run_count++;

			remove_count = 0;

			var i,
				len = events.length,
				ev,
				owner,
				fn;
				
			for (i = 0; i < len; i++) {
				/*if (remove_count > 0)
				console.log("%cRunning event at an offset remove_count: "+remove_count, "background-color:#f90;color:#fff;");*/

				ev = events[i - remove_count];

				if (typeof ev === "undefined") {
					console.warn("Failed event on:");
					console.log(that);
					throw "Cannot publish event: " + name;
				}

				owner = ev.owner;

				if (stop_propagation) {
					console.log("Propagation stopped. " + owner + " will not publish this time.");
				}
				else if (!active_owners[ev.owner]) {
					console.log(owner + " is not active.");
				}
				else {
					ev.runs++;

					fn = ev.fn;
					
					//console.groupCollapsed(owner);
					
					try {
						switch (arguments.length) {
							case 0:
								fn.call(that);
								break;
							case 1:
								fn.call(that, arguments[0]);
								break;
							case 2:
								fn.call(that, arguments[0], arguments[1]);
								break;
						}
					}
					catch (er) {
						console.warn("Event function[" + i + "] failed. Owner: " + owner);
						console.error(er);
					}
					
					//console.groupEnd();
					
				}
			}
		}
	}

})(IBMCore);
;

/** 

	Random small utilities that don't deserve their own file.

	@class IBMCore.common.util
	
**/

(function($, IBM) {

	var util = IBM.namespace(IBM, "common.util");

	/**
		Utility to dynamically inject a CSS style/rule into the head.

		@method addCssRule
		@param selector (String) The CSS path/element you want to apply the style to.
		@param css {Varies} The style to apply to the CSS path/element. Can be a string (CSS style syntax) or an object.
		@example
			// Style as an object.
			IBM.common.util.addCssRule(".someClassName", {
				overflow: "hidden"
			});

			// Style as a string.
			IBM.common.util.addCssRule(".someClassName", "overflow: hidden");
	**/
	util.addCssRule = (function () {
		// Do some setup to determine how to inject the style element.
		// This is single run private shit. 
		// Returned function below.
		var style = document.createElement("style"),
			sheet;
			
		try {
			sheet = document.head.appendChild(style).sheet;
		} 
		catch (er) {
			sheet = document.getElementsByTagName("head")[0].appendChild(style).styleSheet;
		}
		
		window.custom_css = sheet;
		
		// Function definition that this returns. This is what the callable function is.
		return function (selector, css) {
			var propText = "";

			if (typeof css === "string") {
				propText = css;
			}
			else {
				try {
					propText = Object.keys(css).map(function (p) {
							return p + ":" + (p === "content" ? "'" + css[p] + "'" : css[p]);
						}).join(";");
				}
				catch (er) {
					var k;
					for (k in css) {
						propText += k + ":" + (k === "content" ? "'" + css[k] + "'" : css[k]) + ';';
					}
				}
			}
			try {
				sheet.insertRule(selector + "{" + propText + "}", sheet.cssRules.length);
			}
			catch (err) {
				sheet.addRule(selector, propText, sheet.rules.length);
			}
		};
	})();

	// Placeholder for now. This might move to it's own file as/if it grows.
	util.checkClearance = function() {
		return true;
	};
	
	/**
		Takes a time/number in seconds and formats it to HH:MM:SS, but hours are optionally shown only if hours are > 1.
		method convertSecondsToHMS
		@return {String} Returns a formatted time using convention:  HH:MM:SS
	**/
	util.convertSecondsToHMS = function (timeInSeconds) {
		var sec_num = parseInt(timeInSeconds, 10),
			hours   = Math.floor(sec_num / 3600),
			minutes = Math.floor((sec_num - (hours * 3600)) / 60),
			seconds = sec_num - (hours * 3600) - (minutes * 60);

		// Hours is optional display, so make the : optional as well.
		if (hours < 10) {
			hours = "0" + hours;
		}
		if (minutes < 10) {
			minutes = "0" + minutes;
		}
		if (seconds < 10) {
			seconds = "0" + seconds;
		}

		hours = hours < 1 ? "" : hours + ":";
		
		return hours + minutes + ":" + seconds;
	};

	/**
		Returns a unique DOM id that is not used by any other element on the page. Useful for dynamically added elements. 
		<br />All IDs are in the format: ibm-dynid-<num>
		@method generateId
		@return {String} Unique ID.
	**/
	util.generateId = function () {
		var nid;
		do {
			IBM.common.util.idcount++;
			nid = 'ibm-dynid-' + IBM.common.util.idcount;
		} 
		while (document.getElementById(nid) !== null);

		return nid;
	};

	util.idcount = 0;
	
	/**
		A helper that simply returns the current page content body grid size being show/used in the browser.

		@method getCurrentGridSize
		@return {Integer} Returns the width (in px) of the current grid size being used.
	**/
	util.getCurrentGridSize = function () {
		return ($("#ibm-content-main .ibm-columns:first").width() > 539 ? $("#ibm-content-main .ibm-columns:first").width() : 0);
	};

	util.getDataAttributes = function (el, dataPrefix) {
		var $el = $(el),
			dataObj = $el.data() || {};

		if ($(el)[0] && dataPrefix !== "") {
			dataObj = {};

			$.each($(el).data(), function(k, v) {
				var varName = "";
				if (k.indexOf(dataPrefix) === 0) {
					varName = k.substring(dataPrefix.length);
					dataObj[varName] = v;
				}
			});
		}

		return dataObj;
	};

	/**
		Gets the scrollbar width of the browser being used.
		<br />Used for the freezeScrollbars utility (which is used for overlays.)

		@method getScrollbarWidth
		@return {Integer} Returns the width (in px) of the browser's scrollbar element.
	**/
	util.getScrollbarWidth = function () {
		var outer = document.createElement("div"),
			inner = document.createElement("div"),
			widthNoScroll,
			widthWithScroll;
		outer.style.visibility = "hidden";
		outer.style.width = "100px";
		document.body.appendChild(outer);

		widthNoScroll = outer.offsetWidth;
		// Force scrollbars.
		outer.style.overflow = "scroll";

		// Add innerdiv.
		inner.style.width = "100%";
		outer.appendChild(inner);

		widthWithScroll = inner.offsetWidth;

		// Remove divs.
		outer.parentNode.removeChild(outer);

		return widthNoScroll - widthWithScroll;
	};

	/**
		Tells you if the element has scrollbars showing or not.
		method hasScrollbars
		@return {Boolean}
	**/
	util.hasScrollbars = function(el) {
        return $(el)[0] ? $(el)[0].scrollHeight > $(el).innerHeight() : false;
    };

	/**
		This is a way to pause JS. __NOTE:__ This will freeze the browser! Use sparingly and with short MS times!
		
		@method pause
		@deprecated
		@param ms {Integer} The # of milliseconds to pause the JS and make it wait to continue.
	**/
	util.pause = function (ms) {
        var date = new Date(),
			curDate = null;
        do {
            curDate = new Date();
		} 
		while (curDate - date < ms);
    };

	/**
		Utility that escapes strings to they are safe for DOM injection.
		<br />It behaves the same as the PHP function htmlspecialchars and encodes &amp;, &lt;, &gt; and &quot;.
		<br />__NOTE:__ Available to all Strings via string prototype (shortcut) setup that simply calls this utility for ease of use. 
		(See example below)

		@method string.htmlspecialchars
		@param str {String} String to replace/escape HTML special characters in.
		@return {String} Returns a string with special HTML characters escaped.
		@example
			// Using the built-in String method.
			comments = someUserInputText.htmlspecialchars();

			// Or the long way using the actual utility:
			comments = IBMCore.common.util.string.htmlspecialchars(someUserInputText);
	**/
	IBM.common.util.string = {};
	util.string.htmlspecialchars = function (str) {
		return str.replace(/&/g, '&amp;')
		.replace(/</g, '&lt;')
		.replace(/>/g, '&gt;')
		.replace(/'/g, '&#039;')
		.replace(/"/g, '&quot;');
	};

	// String prototype (shortcut) that simply calls/binds the above utility to the string object.
	String.prototype.htmlspecialchars = function () {
		return IBM.common.util.string.htmlspecialchars(this);
	};

	
})(jQuery, IBMCore);
;

/** 

	Utility that adds/removes class to hide the browser scrollbars. Used for overlays.
	<br />
	<br />Class sets overflow: hidden, and adjusts page x pixels over to compensate for the missing scrollbars so the page doesn't shift/jitter when we show/hide overlays.

	@class IBMCore.common.util.freezeScrollbars

**/

(function($, IBM) {

	/**
		Adds a class to the body that acts like freezes the scrollbars (hides them).

		@method freezeScrollbars
		@param bool (Boolean) Pass true to hide the scrollbars, pass false to show them.
		@example
			IBMCore.common.util.freezeScrollbars(true);
			
	**/
	IBM.common.util.freezeScrollbars = function (bool) {
		$("body")[bool  ? "addClass" : "removeClass"]("ibm-no-scroll");
	};

	
	// Onready, get the scrollbar width, 
	//   then inject our dynamic styles for the elements that need a frozen scrollbar option.
	$(function(){
		var scrollbarWidth = IBM.common.util.getScrollbarWidth();
	
		// Dynamic CSS styles to inject.
		
		IBM.common.util.addCssRule(".ibm-no-scroll #ibm-content-wrapper", {
			"margin-left": -scrollbarWidth + "px"
		});
	});

	
})(jQuery, IBMCore);
;

/**

	This file is an add-on to the event coodinator.
	This allows you to subscribe to multiple events. 
	Ex:  "After all three of these events happen: ____ && ____ && ____ , tell me."

	@class IBMCore.common.util.gatekeeper

**/

(function (IBM) {


	IBM.common.util.gatekeeper = function (starting_holds) {
		return new Gatekeeper(starting_holds);
	};

	/**
		Publishes "ready" event when all holds/events have happened that were subscribed to.

		@event ready
	**/
	/**
		Getkeeper object/constructor.
		<br />Called by "IBM.common.util.gatekeeper".
		<br />You can't use this directly. Use "new IBM.common.util.gatekeeper()" method.

		@method Gatekeeper
		@constructor
		@private
		@param starting_holds {Object} Events to wait to happen.
	**/
	function Gatekeeper (starting_holds) {
		var me = this,
			myEvents = IBM.common.util.eventCoordinator(me, "Gatekeeper", ["ready"]),
			holds = {};

		if (starting_holds instanceof Array) {
			addHolds(starting_holds);
		}
		else if (typeof starting_holds === "string") {
			addHold(starting_holds);
		}

	    /**
			This is a method of the "Gatekeeper" constructor.
			<br />Takes an array of holds/events and adds each one to the array of events to wait for.
			
			@method addHolds
			@param names {Array} An array of events to wait for to happen.
		**/
		me.addHolds = addHolds;
		function addHolds (names) {
			var i,
				name,
				len = names.length;

			for (i = 0; i < len; i++) {
				name = names[i];
				addHold(name);
			}
		}

	    /**
			This is a method of the "Getkeeper" constructor.
			<br />Takes a hold/event and adds it to the ones to wait for.
			
			@method addHolds
			@param name {String} A name of an event to wait for to happen.
			@return {Object} The Gatekeeper widget object (me).
		**/
		me.addHold = addHold;
		function addHold (name) {
			holds[name] = true;
			return me;
		}

	    /**
			This is a method of the "Getkeeper" constructor.
			<br />Removes a hold from the ones to wait for.
			
			@method removeHold
			@param name {String} A name of an event to remove.
			@return {Object} The Gatekeeper widget object (me).
		**/
		me.removeHold = removeHold;
		function removeHold (name) {
			if (holds[name] !== true) {
				console.warn("Removing a hold that does not exist: " + name + ". If the hold is added after, this removal will have no effect.");
			}
			else {
				holds[name] = false;
				tryRunningReady();
			}

			return me;
		}

	    /**
			This is a method of the "Getkeeper" constructor.
			<br />Gets a list of holds and returns them in an array.
			
			@method getHolds
			@return {Array} An array of holds we're waiting for.
		**/
		me.getHolds = getHolds;
		function getHolds () {
			var hlds = [],
				key;

			for (key in holds) {
				if (holds[key]) {
					hlds.push(key);
				}
			}

			return hlds;
		}

	    /**
			This is a method of the "Getkeeper" constructor.
			<br />Removes all holds/events we're waiting for.
			
			@method removeAllHolds
			@return {Object} The Gatekeeper widget object (me).
		**/
		me.removeAllHolds = removeAllHolds;
		function removeAllHolds () {
			holds = {};
			tryRunningReady();
		}

		function tryRunningReady () {
			var is_ready = isReady();

			if (is_ready) {
				myEvents.publish("ready");
			}

			return me;
		}

	    /**
			This is a method of the "Getkeeper" constructor.
			<br />Checks if all holds/events have happened so the Gatekeeper can fire the ready event or not.
			
			@method isReady
			@return {Object} The Gatekeeper widget object (me).
		**/
		me.isReady = isReady;
		function isReady () {
			var is_ready = true,
				key;

			for (key in holds) {
				if (holds[key]) {
					is_ready = false;
				}
			}

			return is_ready;
		}
	}

})(IBMCore);
;

/**

	__NOTE:__ Please use the publish/subscribe event utility. Only use this for listening to non-DOM events, multiple async coordination, other scripts, or script events that you can't setup an event publisher for.

	<br />
	<br />The queue utility supports a waiting queue - for example some code might only be ready for execution
	once a certain page element exists on the page. Waiting for the whole page to be ready is too slow if your element is at the top.
	<br />
	<br />
	Just add the elements to the queue and it will execute the callback function once the condition returns true.
	<br />
	<br />
	Unless you know the condition is guaranteed to happen, set a timeout to remove the listener so it doesn't infinitely
	keep listening for the condition and eat up memory.
	<br />
	<br />
	Usage:
		
		// Add a listener
		myQueueItem = IBMcore.common.util.queue.push(
			function(){
				return $("ul#dynamicList li").length !== 0;
			},
			function(){
				alert("#dynamicList is populated");
			}
		);
		
		// Kill the listener after 5 seconds b/c it would have happened by now, or it never will.
		setTimeout(function(){
			IBMCore.common.util.queue.remove(myQueueItem);
		}, 5000);
	
	@class IBMCore.common.util.queue

**/

(function ($, IBM) {

	var me = IBM.namespace(IBM, "common.util.queue");
	
	// Used internally.
	me._queue = [];
	me._timer = null;
	me._count = 0;
	me._lock = false;

	/**
		Adds a new element to the end of the queue and returns a unique id for that element. As soon as
		an element is added the queue starts checking the condition callback (every 50ms) and once this
		function returns true the callback is executed once. Afterwards the element is removed from the queue.
		
		@method push
		@param {function} condition Function reference that has to return true or false.
		@param {function} callback Function to be executed once the condition function returns true.
		@return {Integer} Unique ID for this queue'd listener item.
	**/
	me.push = function (condition, callback) {
		me._count++;
		me._queue.push([me._count, condition, callback]);
		me._work();
		return me._count;
	};
	
	/**
		Adds a new element to the beginning of the queue. Other then that it does exactly the same as
		the push function.
		
		@method unshift
		@param {function} condition Function reference that has to return true or false.
		@param {function} callback Function to be executed once the condition function returns true.
		@return {Integer} Unique ID for this queue'd listener item.
	**/
	me.unshift = function (condition, callback) {
		me._count++;
		me._queue.unshift([me._count, condition, callback]);
		me._work();
		return me._count;
	};

	/**
		Removes the element with the given id from the queue.
		
		@method remove
		@param {Integer} id The unique item-ID returned by the push or unshift function.
		@return {Boolean} true in case the item id was valid and removed, false otherwise.
	**/
	me.remove = function (itemid) {
		var i = 0, 
			j = me._queue.length;
		for (i = 0, j = me._queue.length; i < j; i++) {
			if (me._queue[i][0] === itemid) {
				me._queue.splice(i, 1);
				return true;
			}
		}
		return false;
	};
	
	/** 
		Internal worker function that works off the queue.
		
		@method _work
		@private
	**/
	me._work = function () {
		if (me._lock)  {
			return; // Should only run once.
		}
		if (me._queue.length === 0) {
			return;
		}
		
		me._lock = true;
		
		var i = 0, 
			j = me._queue.length;
		
		for (i = 0, j = me._queue.length; i < j; i++) {
			if (me._queue[i][1]()) {
				me._queue[i][2]();
				me._queue.splice(i, 1);
				i--;
				j = me._queue.length; // reset
			}
		}
		
		me._lock = false;

		// Set the timer again.
		me._timer = setTimeout(me._work, 50);
	};

	/**
		Waits until a given element is available in the DOM and executes the passed callback function. 
		It utilizes the queue system and the call might be some time after the element is available, 
		not exactly when it is available. But overall the performance should be significantly faster than ready function.
		NOTE: If the last parameter "onload" is set and the element is not ready once the DOM is loaded
		the callback function is executed on load. Like a "whichever is faster" or a failsafe if you need it.
		
		@method waitForElement
		@param {String} element Element to be waited for, i.e. ibm-com
		@param {function} callback Function to be called once the element is available
		@param {Boolean} [onload] Optional parameter; if set to true the callback is loaded once the DOM is ready.
	**/
	me.waitForElement = function (element, callback, onload) {
		// Add a listener to the queue for this element to be ready.
		// "done" used to cancel the callback for whichever doesn't run first.. element load or DOM ready.
		var done = false,  
			eid = me.push(
				function () {
					return document.getElementById(element) !== null;
				}, 
				function () {
					if (done) {
						return;
					}
					done = true;
					callback();
				}
			);

		// If the "onload" flag is set, add the callback to onready, so whichever comes first runs it.
		if (typeof onload !== "undefined" && onload === true) {
			$(function(){
				if (done) {
					return;
				}
				done = true;
				me.remove(eid);
				callback();
			});
		}
	};

})(jQuery, IBMCore);
;

/**

	Utility to capture all meta information on the page.
	<br />
	<br />Waits for the body element to load, then merges in the digitalData object into meta object, and normalized some country/language and other misc meta data. Also contains the utility to swap the page shell's locale.

	__Special feature: Changing the page shell locale__ 
	<br />For pages that want to do personalization or "language first" in an effort to provide the user with more relevant content. If you detect that the user is in a different country than your page is coded for, you can easily change the page shell masthead/footer/SBS locale by running the following JS snippet using any proper locale using standard $lc-$cc format:
	
		IBMCore.common.util.meta.changePageLocale("fr-ca"); // EX: French Canada

	@class IBMCore.common.util.meta

**/ 

(function ($, IBM) {

	/**
		Publishes this event after the &lt;head> has been loaded and all meta data parsed and setup from it.

		@event dataReady
	**/
	var me = IBM.namespace(IBM, "common.meta"),
		utilMeta = IBM.namespace(IBM, "common.util.meta"),
		myEvents = IBM.common.util.eventCoordinator(me, "Meta", ["dataReady"]);
		
	me.isLoaded = false;

	// Setup placeholder object in case DD obj. isn't defined on page.
	// We probably don't need this. Should just check if exists below and stop and throw error instead.
	// TODO: Santelia: Remove and check if undefined and stop and throw JS error.
	me.page = { 
		pageInfo: {}
	};
	
	/**
		Automatically runs onload ASAP when the body element is available (means full &lt;head> has loaded.)
		Merges in the digitalData object into meta object, and normalizes some country/language and other misc meta data.
		<br />__Note:__ Calling this function manually causes all meta "ready" event subscribers' callbacks functions to run (again).

		@method init
	**/
	me.init = function() {
		window.digitalData = window.digitalData || {};
		
		// Merge the digitalData object into our meta obj.
		// DO NOT MODIFY THE ORIGINAL DIGITALDATA OBJECT.
		$.extend(true, me, window.digitalData);
		
		// Setup vars
		var ourPageInfo = me.page.pageInfo,
			doclang = document.getElementsByTagName("html")[0].lang,
			langCorrectionTable = { pt: "br", zh: "cn", de: "de", es: "es", fr: "fr", it: "it", ja: "jp", ko: "kr" };
		
		// Special tags & formats.
		ourPageInfo.ibm.wwCase = "";
		ourPageInfo.ibm.cc = ""; 
		ourPageInfo.ibm.lc = "";
		
		// Set proper CC for us to use.
		if (!!ourPageInfo.ibm.country) {
			ourPageInfo.ibm.cc = $.trim(ourPageInfo.ibm.country.toLowerCase());
			
			// If there are multiple countries use just the first one for the CC value
			if (ourPageInfo.ibm.cc.indexOf(",") > -1) {
				ourPageInfo.ibm.cc = $.trim(ourPageInfo.ibm.cc.substring(0, ourPageInfo.ibm.cc.indexOf(",")));
			}
			
			// GB is UK in the real world :)
			if (ourPageInfo.ibm.cc === "gb") {
				ourPageInfo.ibm.cc = "uk";
			}
			
			// Map worldwide (ZZ) pages to US, set a flag
			if (ourPageInfo.ibm.cc === "zz") {
				ourPageInfo.ibm.cc = "us";
				ourPageInfo.ibm.wwCase = "Y";
			}
		}
		
		// Set proper LC for us to use.
		if (!!ourPageInfo.language) {
			ourPageInfo.ibm.lc = ourPageInfo.language.substring(0, 2).toLowerCase();
		}
		
		// Meta tag not set & if language is set on HTML tag.
		// In other words... account for incorrect coding.
		if (!!doclang){ 
			ourPageInfo.ibm.lc = ourPageInfo.ibm.lc || doclang.substring(0,2).toLowerCase();
			ourPageInfo.ibm.cc = ourPageInfo.ibm.cc || doclang.substring(3,5).toLowerCase();
		}
		
		// Account for more incorrect coding.
		ourPageInfo.ibm.lc = ourPageInfo.ibm.lc || "en";
		ourPageInfo.ibm.cc = ourPageInfo.ibm.cc || "us";
		
		// Might be overridden by ibmweb.config.meta (for applications that cannot set the meta tags)
		ourPageInfo.ibm.cc = IBM.common.util.config.get("meta.cc") || ourPageInfo.ibm.cc;
		ourPageInfo.ibm.lc = IBM.common.util.config.get("meta.lc") || ourPageInfo.ibm.lc;
		
		
		// WTF?? On w3 in html 'lang' attribute is <lc> instead of <cclc> which is causing the masthead to load in default 'usen'
		ourPageInfo.ibm.cpi = ourPageInfo.ibm.cc + ourPageInfo.ibm.lc;

		if (ourPageInfo.ibm.cc === "us" && ourPageInfo.ibm.lc !== "en") {
			if (langCorrectionTable[ourPageInfo.ibm.lc]) {
				ourPageInfo.ibm.cpi = langCorrectionTable[ourPageInfo.ibm.lc] + ourPageInfo.ibm.lc;
			}
		}
		
		// Set default subject if not exist.
		if (!ourPageInfo.ibm.subject) {
			ourPageInfo.ibm.subject = "ZZ999";
		}
		
		// Store encoding.
		ourPageInfo.ibm.encoding = "utf8";
		ourPageInfo.ibm.encodingRaw = "UTF-8";
		
		if ($("meta[charset]")[0]) {
			ourPageInfo.ibm.encodingRaw = $("meta[charset]").attr("charset");
			ourPageInfo.ibm.encoding = ourPageInfo.ibm.encodingRaw.replace("-", "").replace("_", "").toLowerCase();
		}
		
		// Get the page title.
		ourPageInfo.ibm.title = "";
		if ($("title")[0]) {
			ourPageInfo.ibm.title = $("title")[0].innerHTML;
		}

		// Check if they disabled core modules or content widgets using the body data attributes. 
		// This is used by pages that load v18 asyncronously and can't set config using config.set() to disable widgets.
		if ($("body").data("coremodules_enabled") === false) {
			IBM.common.util.config.set({
				coremodules: {enabled: false}
			});
		}
		if ($("body").data("contentwidgets_enabled") === false) {
			IBM.common.util.config.set({
				contentwidgets: {enabled: false}
			});
		}

		// Tell subscribers we done.
		myEvents.publish("dataReady");
	};
	
	/**
		Changes the page locale to the passed locale (format: lc-cc), then re-inits meta so that it gets new translations and 
		recreates masthead/footer/SBS/anything else that waits for meta publish. 
		Locale param format uses indusry standard:  "lc-cc" (case insensitive b/c we set it properly).
		
		@method changePageLocale
		@param locale {String} Industry standard locale (language and country code) in format "lc-cc", case insensative.
		@example
			IBMCore.common.util.meta.changePageLocale("ca-fr");
	**/
	utilMeta.changePageLocale = function (locale) {
		var lc = locale.substr(0,2).toLowerCase(),
			cc = locale.substr(3).toUpperCase();
		
		window.digitalData.page.pageInfo.ibm.country = cc;  // Ex: ca
		window.digitalData.page.pageInfo.language = lc + "-" + cc;  // Ex: fr-CA
		
		// Run meta.init which will reset meta data, get new translations, 
		//  and recreate the masthead, footer, and SBS bar in the county/language version specified above.
		me.init();		
	};
	
	// Set our "loaded" var when we publish "ready" in case someone is just checking to see if this === true.
	me.subscribe("dataReady", "self", function() {
		me.isLoaded = true;
	});

	// Once #ibm-top is available *or* the page finished loading... whichever is first (ibm-top).
	IBM.common.util.queue.waitForElement("ibm-top", me.init, true);
	
})(jQuery, IBMCore);
;

/**

	Custom modernizr tests/detection setups.
	
**/

(function ($, IBM) {

	// Add Modernizr test for hires so it's publically available for all pages.
	Modernizr.addTest("hires", function() {
		var dpr = window.devicePixelRatio || (window.screen.deviceXDPI / window.screen.logicalXDPI) || 1;
		return (dpr > 1);
	});
	
})(jQuery, IBMCore);

;

/**

	Tells you if an element is visible in the viewport window.
	<br />Use this when you want to wait to animate something or do an action when the element is "in view", or use as a helper for infinite scroll functionality.
	
	@class IBMCore.common.util.scrolledintoview
	
**/

(function($, IBM) {

	var util = IBM.namespace(IBM, "common.util");

	util.scrolledintoview = function (el) {
		var $elem = $(el), // Allows string or actual jq selector.
			$window = $(window),
			docViewTop = $window.scrollTop(),
			docViewBottom = docViewTop + $window.height(),
			elemTop = $elem.offset().top,
			elemBottom = elemTop + $elem.height();

		return ((elemBottom <= docViewBottom) && (elemTop >= docViewTop));
	};

})(jQuery, IBMCore);;

/**

	Scroller tracker utility.
	<br />
	<br />Utility to track user's scrolling and fire an every every ### pixels.

	@class IBMCore.common.util.scrolltracker

**/

(function ($, IBM) {

	// Create util namespace and make a shortcut to it for ourselves.
	var me = IBM.namespace(IBM, "common.util.scrolltracker"),
		trackingInterval = 400;

	/**
		Callback from subscription to meta 'dataReady' event publisher.

		@method autoInit
	**/
	me.autoInit = function () {
		if (IBM.common.util.config.isEnabled("scrolltracker")) {
			me.init();
		}
	};

	me.init = function () {
		var trackedMarker = 0,
			curMarker = 0,
			didScroll = false;

		$(window).on("scroll", function () {
			didScroll = true;
		});

		setInterval(function() {
			if (didScroll) {
				didScroll = false;
				
				curMarker = Math.floor($(window).scrollTop()/trackingInterval);

				if (curMarker > trackedMarker) {
					trackedMarker = curMarker;

					// Fire event that they scrolled this # pixels.
					IBM.common.util.statshelper.fireEvent({
						ibmEV: "scroll distance",
						ibmEvGroup: IBM.common.util.getCurrentGridSize() + " grid",
						ibmEvAction: trackingInterval * trackedMarker,
						ibmEvModule: $("body").height() 
					});
				}
			}
		}, 50);
	};
	

	// When meta data is ready (config), call auto init.
	IBM.common.meta.subscribe("dataReady", "scrolltracker", me.autoInit);
	
})(jQuery, IBMCore);

;

/**

	Uses getCurrentGridSize utility to add a class to HTML element so CSS can be applied generically 
	per-grid size by pages without needing to do media queries or match v18 media queries.
	<br />Grid classes are same conventin as hidden-xxxx classes so everything matches up.

**/
(function($, IBM) {
	var existingGridSize,
		gridClassMap = {
			0: "small",
			540: "medium",
			720: "medium",
			960: "large",
			1200: "xlarge",
			1440: "xlarge"
		};

	function init () {
		var didResize = false;

		// Set grid size class on dom ready.
		$(setGridClass);

		$(window).resize(function() {
			didResize = true;
		});

		setInterval(function() {
			if (didResize) {
				didResize = false;
				setGridClass();
			}
		}, 50);
	}

	function setGridClass () {
		var resizedGrid = IBM.common.util.getCurrentGridSize();

		resizedGrid = resizedGrid > 540 && resizedGrid < 546 ? 0 : resizedGrid;
			
		if (resizedGrid === existingGridSize) {
			return;
		}
		else {
			existingGridSize = resizedGrid;
			$("html").removeClass("ibm-grid-small ibm-grid-medium ibm-grid-large ibm-grid-xlarge").addClass("ibm-grid-" + gridClassMap[resizedGrid]);
		}
	}

	init();
	
})(jQuery, IBMCore);

;

/**

	Stats events helper utility.
	<br />
	<br />Utility to use to fire a stats/metrics event for an action that you want to be able to pull reports on for your page.

	@class IBMCore.common.util.statshelper

**/

(function ($, IBM) {

	// Create util namespace and make a shortcut to it for ourselves.
	var me = IBM.namespace(IBM, "common.util.statshelper");

	/**
		This fires an event in Netinsight (ibmStats.Event) which also now fires the new Coremetrics event cmCreateElementTag().
		<br />On Jan 1, 2015 this will fork and for WWW we will remove the ibmStats.event call and only call cmCreateElementTag(). 
		<br />On July 1, 2015 we will do the same and no longer use Netinsight ever.

		@method fireEvent
		@param eventData {Object} Object with standard Netinsight properties and values to store in the metrics database for reporting.
	**/
	me.fireEvent = function (eventData) {
		var h1Element = $("h1:first"),
			eventParams = ["Group", "Name", "Module", "Section", "Target", "FileSize", "LinkTitle"],
			i,
			thisParamName;
		

		// If the inbound object hasn't specified a link title param, us the title of the page.
		if (!eventData.ibmEvLinkTitle && !eventData.ibmEvLinktitle){
			if (h1Element.length > 0 && h1Element[0].innerHTML){
				$.extend(eventData, {"ibmEvLinkTitle": h1Element[0].innerHTML});
			}
		}
		
		// Set null for all params that don't exist.
		for (i = eventParams.length - 1; i >= 0; i--) {
			thisParamName = "ibmEv" + eventParams[i];
			if (!eventData[thisParamName]) {
				eventData[thisParamName] = "null";
			}
		}

		if (typeof ibmStats !== "undefined" && ibmStats.event) {
			ibmStats.event(eventData);
		}
	};

	/**
		This will get the list of custom metrics events set on an element via data-attr and return an object with the IBM metrics event parameters and values. Used on videoplayer to extend the default tagging for page owners that want to override the default tagging.
		<br />Syntax for the HTML data-attr is:  data-ibmevent_<event param lowercased>="some value"

		@method getCustomEventParams
		@param $el {jQuery DOM selector} The element you want to get the custom data-attr metrics event params from.
		@return eventData {Object} Object with IBM metrics event params and values that were set on the passed element.
	**/
	me.getCustomEventParams = function ($el) {
		var dataAttrs = IBM.common.util.getDataAttributes($el, "ibmevent_"),
			eventParamMappingArr = {
				ibmev: "ibmEV",
				ibmevaction: "ibmEvAction",
				ibmevname: "ibmEvName",
				ibmevmodule: "ibmEvModule",
				ibmevgroup: "ibmEvGroup",
				ibmevsection: "ibmEvSection",
				ibmevlinktitle: "ibmEvLinkTitle",
				ibmevfilesize: "ibmEvFileSize",
				ibmevtarget: "ibmEvTarget"
			},
			ibmevParams = {};

		$.each(dataAttrs, function (k, v) {
			ibmevParams[eventParamMappingArr[k]] = v;
		});

		return ibmevParams;
	};

})(jQuery, IBMCore);

;

/**
	
	Browser localStorage utilities.
	<br />
	<br />Just like the common cookie utility, this provides a standardized way to work with browser localStorage.
	<br />This util uses JSON (browser API), so this storage utility is only supported in IE8+.
	 In IE7 it acts the same as if the user has cookies disabled... it simply does nothing.

	@class IBMCore.common.util.storage
	
**/

(function ($, IBM) {

	var me = IBM.namespace(IBM, "common.util.storage");

	/**
		Clears the user's browser localStorage (for the owning domain).
		<br />CAUTION: This is the localStorage equivalent of clearing all of the user's cookies for your domain.
		
		@method clear
		@return {Boolean} True if localStorage is supported, else false.
	**/
	me.clear = function () {
		if (!me.isSupported()) {
			return false;
		}

		localStorage.clear();
		return true;
	};

	/**
		Gets the requested item from browser localStorage.
		<br />
		
		@method getItem
		@param key {String} The name of the key/item to get from localStorage.
		@return {Varies} The data for the key if localStorage is supported &amp;&amp; if key exists &amp;&amp; key is not expired,
		<br />else returns: null.
	**/
	me.getItem = function (key) {
		var storageData = null,
			expires = 0, // 0 means no expiration.
			timeNow = new Date().getTime();
			
		if (!me.isSupported()) {
			return null;
		}

		// If it has an expiration date (has a # other than 0) that has passed, remove it b/c it's invalid data now.
		// else parse the storage data and set it for return.
		if (localStorage.getItem(key) !== null) {
			expires = JSON.parse(localStorage.getItem(key)).expires;

			if (expires !== 0 && expires < timeNow) {
				me.removeItem(key);
			}
			else {
				storageData = JSON.parse(localStorage.getItem(key)).value;
			}
		}
		
		return storageData;

	};

	/**
		Checks if browser localStorage is supported by the current user's browser.
		<br />This is used by every method in this utility class so you don't need to use this unless you have special case use for it.
		<br />Provided as a public method purely for your convenience.
		
		@method isSupported
		@return {Boolean} True if localStorage is supported, else false.
	**/
	me.isSupported = function () {
		return Modernizr.localstorage && typeof JSON !== "undefined";
	};
	
	/**
		Deletes the requested item from browser localStorage.
		
		@method removeItem
		@param key {String} The name of the key/item to delete from localStorage.
		@return {Boolean} True if localStorage is supported, else false.
	**/
	me.removeItem = function (key) {
		if (!me.isSupported()) {
			return false;
		}
		localStorage.removeItem(key);
		return true;
	};

	/**
		Stores data in browser localStorage.
		
		@method setItem
		@param key {String} The name of the key to use for this data store in localStorage.
		@param value {String} The value/data to store in localStorage.
		@param [lifetime] {String} The storage item's TTL (time to live), in <strong>SECONDS</strong>. AKA: How long until it expires.
		 If lifetime is not supplied, the storage item TTL is session-only.
		@return {Boolean} True if localStorage is supported, else false.
	**/
	me.setItem = function (key, value, lifetime) {
		var expireTime = 0,
			storageObject = {},
			timeNow = new Date().getTime();
		
		// Can't do shit if localStorage isn't supported.
		if (!me.isSupported()) {
			return false;
		}

		// First we should remove this key if it already exists.
		me.removeItem(key);

		// If lifetime is specified...
		if (lifetime) {
			expireTime = lifetime * 1000;
			expireTime += timeNow;
		}

		// Build our storage object.
		storageObject = {
			"value": value, 
			"expires": expireTime
		};
		
		// Do it.
		localStorage.setItem(key, JSON.stringify(storageObject));
		
		return true;
	};
	
})(jQuery, IBMCore);


;

/**

	Provides the functionality to call the SWWIF services/bundled service call.
	<br />
	<br />Doesn't have to be bundled, can be called single request instantly, but bundled saves # of requests.
	<br />It's like a bus leaving the station... Give everyone time to buy a ticket and get on the bus. 
	At a certain time the bus is leaving the station with whomever is on it. 
	However, if you miss the bus you can always just hail a taxi for yourself whenever you want ("makeRequest" function).

	@class IBMCore.common.util.coreservices

**/

/**
	LEGACY Service ID List - just to have it somewhere.
	Some of these are turned off.
	100 - Greeting 
	101 - Scoped Search // SERVICE DISABLED
	102 - Merchandising
	103 - Easy Access link displayed on Public site.
	104 - My Interests display // SERVICE DISABLED
	105 -  Incremental profiling // SERVICE DISABLED
	106 -  InterCountry navigation // SERVICE DISABLED
	107 - Pre-filled forms // SERVICE DISABLED
	109 - Sign in/FastPath
	110 - E-mail this page
	115 - IBM Bookmarks // SERVICE DISABLED
	125 - IBM Social Share Service // SERVICE DISABLED
	119 -  Instant Signin // SERVICE DISABLED
	1000 - Masthead links and rollover menus // SERVICE DISABLED
	1001 - Print this page // SERVICE DISABLED
	1002 - Turn off All Page tools // SERVICE DISABLED
	1003 - Turn off Masthead Greeting and Sign in services (Don't display grey bar below masthead.) // SERVICE DISABLED
	1004 - All page tools / Also handles IBM Feeds // SERVICE DISABLED
	1005 - Delicious page tool // SERVICE DISABLED
	1006 - Digg page tool // SERVICE DISABLED
	1007 - Turn off SBS icons (leaves Print and Mail intact) // SERVICE DISABLED
	1010 -  Social navigation // SERVICE DISABLED
	122 - IBM QuickPoll // SERVICE DISABLED

	Details on https://w3.tap.ibm.com/w3ki07/display/CWTBNG/Dynamivnav%20Regression%20Test
**/

(function ($, IBM) {

	/**
		Publishes this event if the service throws us an error and we don't get data back.

		@event error
	**/
	var me = IBM.namespace(IBM, "common.util.coreservices"),
		myEvents = IBM.common.util.eventCoordinator(me, "Coreservice", ["error"]);

	me._bundleCallbacks = [];
	me._bundleParams = {};
	
	me.bundledRequest = {
		/**
			Allows modules to add a request to the bundled core services (SWWIF) call as they are read in the JS. 
			Execution of the bundle doesn't happen until translations + DOM ready event is published. 
			This ensures meta & translations are loaded, and waiting for DOM ensures any other shit is loaded and ready.

			@method bundledRequest.add
			@param serviceId {Integer} The service's ID/#.
			@param callback {Function} The function to call on service response.
			@param params {Object} Data/Parameters to add to the service call.
			@return {Function} The callback function.

		**/
		add: function (serviceId, callback, params, secureUrl) {
			me._bundleCallbacks.push(serviceId + ":" + callback);
			
			// Mix in parameters.
			$.extend(me._bundleParams, params, {useSecureUrl: secureUrl});
			
			return callback;
		},
		/**
			Joins all service calls that have been added to the bundle and makes the WSR (web service request). Then clears the params and callbacks.

			@method bundledRequest.execute
		**/
		execute: function () {
			// Join all callbacks that have been added to the array.
			var allCallbacks = me._bundleCallbacks.join('@'),
				allParams = {},
				ip = /ip=([0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3})/.exec(document.location.search),
				domain = /domain=([a-zA-Z\.\-0-9]+)/.exec(document.location.search),
				servicesUrl = IBM.common.config.coreservicesUrl;
			
			// No callbacks, do nothing.
			if (!allCallbacks) {
				return;
			}
			
			// Mix in default parameters
			// 1. Defaults (cc, lc, ts), which might be overridden by a module
			// 2. Whatever comes from the module(s)
			// 3. The cb = parameter can't be overridden - contains the service->callback mappings
			allParams = $.extend({
					cc: IBM.common.meta.page.pageInfo.ibm.cc,
					lc: IBM.common.meta.page.pageInfo.ibm.lc,
					format: 'json',
					ts: (new Date().getTime())
				}, 
				me._bundleParams, 
				{cb: allCallbacks}
			);
				
			if (ip && domain){
				allParams.ip = ip[1];
				allParams.domain = domain[1];
			}
	
			// Fire the request. 
			// Publish event if there was an error. Else the return data callbacks will fire so no need to fire event on success.
			if (me._bundleParams.useSecureUrl) {
				servicesUrl = IBM.common.config.coreservicesUrlSecure;
			}

			$.ajax({
				url: servicesUrl + $.param(allParams),
				dataType: 'script',
				error: function (data) {
					console.error("Error calling service:", servicesUrl + $.param(allParams));
					myEvents.publish("error");
				}
			});

			// Clear our data.
			me._bundleParams = {};
			me._bundleCallbacks = [];
		}
	};
		
	/**
		Simple helper to make an immediate single service request. If you want to bundle multiple services into one request use the "bundleRequest" functions.

		@method makeRequest
		@param serviceId {Integer} The service's ID/#.
		@param callback {Function} The function to call on service response.
		@param params {Object} Data/Parameters to add to the service call.

	**/
	me.makeRequest = function (serviceId, callback, params, secureUrl) {
		me.bundledRequest.add(serviceId, callback, params, secureUrl);
		me.bundledRequest.execute();
	};
		
	
	// Wait until all JS has a chance to run and buy a ticket to the service train.
	// .meta fires after head is fully loaded, so we just wait till meta is ready 
	//   and that infers that all JS in the head has had a change to run/add to bundle.
	// Added a timeout so other services that also rely on meta data have a chance to add to the bundled call.
	IBM.common.meta.subscribe("dataReady", "coreservices", function () {
		setTimeout(me.bundledRequest.execute, 300);
	});
	
})(jQuery, IBMCore);

;

/**

	Automatically gets the v18 common translations for all the UI text and links.
	<br />
	<br />Automatically runs onload. Waits until meta fires dataReady event, then gets the page locale's translation files, then publishes event for subscribers.
	<br />Any time that the meta init is run and publishes "dataReady", this translation init will run then publish "dataReady".

	@class IBMCore.common.translations

**/


(function ($, IBM) {

	/**
		Publishes this event after __main__ translations have been merged __and__ the DOM is ready. 
		<br />Kinda dumb, but just a helper so other JS doesn't have to do $(function().. themselves after translation ready event is fired.

		@event dataAndDomReady
	**/
	/**
		Publishes this event after __main__ translations have been merged into common.translations.data{}

		@event dataReady
	**/
	/**
		Publishes this event if there is an error getting the __main__ translations.

		@event error
	**/
	
	// Declare the translations object, events, and get stored xlations (if exist.)
	var me = IBM.namespace(IBM, "common.translations"),
		myEvents = IBM.common.util.eventCoordinator(me, "meta", [
			"dataAndDomReady", 
			"dataReady", 
			"error"
			]),
		currStoredTranslations = IBM.common.util.storage.getItem("v18mainxl8ns") || {},
		translations = {
			// TODO: Santelia: We don't need "misc" anymore b/c we consolidated xlations into 1 v18main file.
			// Validate after new xlation file is working and remove.
			v18: {
				data: {},
				ready: false
			}
		};

	me.data = {};
	me.isDataLoaded = false;
	
	/**
		Callback from subscription to meta "dataReady" event publisher. 
		<br />Validates cc and lc, etc. If translations exist in storage, 
		uses cached copy and passes them to callback, else makes two requests for main and misc translations.
		<br />__Note:__ When this runs and publishes ready event, it calls all active subscribers' callback function (including masthead/footer/sbs).
		
		@method init
	**/
	me.init = function () {
		// Reset data object in the case when we change the page shell locale/wrapper.
		me.data = {};
		translations.v18.ready = false;

		// Check a few required meta tags exist. Can't do shit without these.
		if (!IBM.common.meta.page.pageInfo.ibm.lc || !IBM.common.meta.page.pageInfo.ibm.cc) {
			return;
		}
		
		// Setup our listener to wait until all 3 translation files are ready/loaded, then fire the overall "dataReady" event.
		setupTranslationsReadyListener();

        // If we have this locale's translations in storage already, 
        //  check which ones we already have and set the flag for them.
        // A bit of a gamble matching a child object name/property to check for existance, but they won't change. Just a FYI.
		if (currStoredTranslations[IBM.common.meta.page.pageInfo.ibm.cpi]) {
			if (currStoredTranslations[IBM.common.meta.page.pageInfo.ibm.cpi].v18main) {
				translations.v18.ready = true;
			}
		}

		// If all of the above are true, it means they are all in localstorage, so none of the below will fire.
		// The listener we setup (setupTranslationsReadyListener) will trigger the publish("dataReady").
		
		// Each of these gets the associated translation file and then sets the var to true 
		//  for our "setupTranslationsReadyListener" listener.
		
		// TODO: Santelia: We don't need this anymore b/c we consolidated xlations into 1 v18main file.
		// Validate after new xlation file is working and remove.
		if (!translations.v18.ready) {
			getV18Translations();
		}
	};


	// Listens for all translation data/files to be loaded and ready and then fires "dataReady" event.
	function setupTranslationsReadyListener () {
		IBM.common.util.queue.push(function(){
			return translations.v18.ready;
		}, function(){
			// Merge all the translations into our local single data object "me.data" (public).
			// Keep any existing ones (merge in first) in case some other main module wants to share this storage facility.
			mergeTranslations(currStoredTranslations[IBM.common.meta.page.pageInfo.ibm.cpi]);
			mergeTranslations(translations.v18.data);

			// No do the actual storing.
			storeTranslations();

			// Now fire events that the data is ready to be used
			myEvents.publish("dataReady");
			
			$(function() {
				myEvents.publish("dataAndDomReady");
			});
		});
	}

	// This uses the data util "provide" and automatically puts the translation object as a named child in translation.data.
	// Example: This file is namespaced with "v18main" so it puts it in:  translations.data.v18main
	// Basically this allows any JSON translation file to have it's own namespace in the .data object and not overwrite others.
	
	// PICKUP: Change to use data.get utility.
	function getV18Translations () {
		var useUrl = IBM.common.config.dataUrl + IBM.common.meta.page.pageInfo.ibm.cpi + ".js";

		$.ajax({
				url: useUrl,
				dataType: "script",
				cache: true
			}).done(function () {
				translations.v18.ready = true;
			}).fail(function (message) {
				console.error('Error while loading main v18 translation file', message);
				translations.v18.ready = true;
				myEvents.publish("error");
			});
	}

	// TODO: Santelia: We don't need this anymore b/c we consolidated xlations into 1 v18main file.
	// Validate after new xlation file is working and remove.
	/**
		Async WSR to get secondary misc translations from second ECM gen'd file.
		<br />Merges returned translations into common.translations.data{}, stores, then __publishes event__.

		@method getMainTranslations
		@private
	**/
	// function getMiscTranslations () {
	// 	$.ajax({
	// 			url: "//www.ibm.com/common/translations/" + IBM.common.meta.page.pageInfo.ibm.cc + "/" + IBM.common.meta.page.pageInfo.ibm.lc + "/translations.js",
	// 			dataType: "script",
	// 			cache: true
	// 		}).done(function() {
	// 			translations.misc.data = {
	// 				"misc": (window.ECM_translation || {})
	// 			};
				
	// 			translations.misc.ready = true;
	// 			myEvents.publish("miscDataReady");
	// 		}).fail(function (message) {
	// 			console.error('Error while loading misc translation file', message);
	// 			translations.misc.ready = true;
	// 			myEvents.publish("miscError");
	// 		});	
	// }
	
	/**
		Merges the inbound param into data{}.

		@method mergeTranslations
		@private
		@param data {Object} An object (of translations) to merge into common.translations.data{}
	**/
	function mergeTranslations (data) {
		$.extend(true, me.data, data);
	}
	
	/**
		Adds the current locale translations into currStoredTranslations{} then saves into localStorage.
		<br />Current TTL for stored translations is 4 hours.

		@method storeTranslations
		@private
	**/
	function storeTranslations () {
        currStoredTranslations[IBM.common.meta.page.pageInfo.ibm.cpi] = me.data;
        IBM.common.util.storage.setItem("v18mainxl8ns", currStoredTranslations, 3600 * 4);
	}

	// Set our "loaded" var when we publish "ready" in case someone is just checking to see if this === true.
	me.subscribe("dataReady", "self", function () {
		me.isDataLoaded = true;
	});

	// META is a requirement. Listen for Meta to be finished, then get the translations.
	IBM.common.meta.subscribe("dataReady", "translations", me.init).runAsap(me.init);

})(jQuery, IBMCore);
;

/**

	Web page user object.
	<br />
	<br />Sets up a common user object with data retrieved from the Demandbase service (or cached data).
	<br />Fires an event with user info onload for metrics tagging purposes.
	<br />Stores user info in localStorage object (if supported) with a TTL so we don't call the service on every page view.
	<br />Every x# days (set in a var) stored data object expires and we "refresh" it by calling DB and storing again.
	<br />
	<br />To retrieve user info:
		IBMCore.common.util.user.getInfo()

	@class IBMCore.common.util.user

**/

(function ($, IBM) {

	/**
		Publishes this event after we've retrieved and loaded the user object's data.

		@event ready
	**/
	/**
		Publishes this event if there's an error requesting user data, ex: if it's a non-IBM domain.

		@event error
	**/
	var me = IBM.namespace(IBM, "common.util.user"),
		myEvents = IBM.common.util.eventCoordinator(me, "User", ["ready", "userstateReady", "error"]),
		dataFields = [
			"annual_sales",
			"company_name",
			"country",
			"employee_count",
			"industry",
			"information_level",
			"ip",
			"primary_sic",
			"registry_country_code",
			"sub_industry"
		],
		encryption = {
			cryptKey: "yxsdpqmouenictjarzvkbfhwlg",
			decode: function (encodedStr) {
				var ciphertext = encodedStr,
					i,
					plaintext = "",
					re = /[a-z]/;

				for (i = 0; i < ciphertext.length; i++) {
					if (re.test(ciphertext.charAt(i))) {
						plaintext += String.fromCharCode(encryption.cryptKey.indexOf(ciphertext.charAt(i)) + 97);
					}
					else {
						plaintext += ciphertext.charAt(i);
					}
				}

				return decodeURIComponent(plaintext);
			},
			encode: function (str) {
				if (!str || str === "") {
					return str;
				}

				var plaintext = str.toLowerCase(),
					ciphertext = "",
					i,
					re = /[a-z]/;

				for (i = 0; i < plaintext.length; i++) {
					if (re.test(plaintext.charAt(i))) {
						ciphertext += encryption.cryptKey.charAt(plaintext.charCodeAt(i) - 97);
					}
					else {
						ciphertext += plaintext.charAt(i);
					}
				}

				return encodeURIComponent(ciphertext);
			}
		},
		ipForced = IBM.common.util.url.getParam("ip") || "",
		signedin = false,
		storage = {
			expireDaysBasic: 7,
			expireDaysDetailed: 7,
			key: "comusrtag"
		},
		user = {};

	/**
		Called from the callback from the user data request to Demandbase.
		<br />Loops thru the fields we want and adds them to a data object and returns to the caller.

		@method buildUserdataFromServiceRequest
		@private
		@param data {Object} The JSON object returned from Demandbase.
		@return {Object} A data object to merge into the common user object.
	**/
	function buildUserdataFromServiceRequest (data) {
		var value,
			userObjData = {};

		// Loop thru our fields and set user data. If basic, set all to N/A.
		$.each(dataFields, function () {
			value = !data[this] ? "n/a" : data[this].toString();
			
			userObjData[this] = value.toLowerCase();
		});

		// Always keep this intact and never replace with "n/a" b/c it's used as a flag.
		userObjData.information_level = data.information_level.toLowerCase();

		return userObjData;
	}

	/**
		Fires a web metric event for tracking types of users on your page.
		<br />If you want to pull a report the unique "Event" is "common user tag".

		@method fireEvent
		@private
	**/
	function fireEvent () {
		// Map event params to our data fields.
		IBM.common.util.statshelper.fireEvent({
			ibmEV: "common user tag",
			ibmEvAction: user.company_name,
			ibmEvGroup: user.employee_count,
			ibmEvLinkTitle: user.industry,
			ibmEvModule: user.sub_industry,
			ibmEvName: user.primary_sic,
			ibmEvFileSize: user.annual_sales,
			ibmEvSection: "n/a", // unused for now but need it to preserve reporting when changed.
			ibmEvTarget: "n/a" // unused for now but need it to preserve reporting when changed.
		});
	}

	/** 
		Returns the user object with known data about the user. ALL NON-PII stuff.

		@method getInfo
		@return {Object} The user object populated with available data.
	**/
	me.getInfo = getInfo;
	function getInfo () {
		return user;
	}

	/** 
		Merges the object into the existing user object

		@method setInfo
		@param setInfo {Object} The object to merge with existing user data.
		@return {Object} The user object populated.
	**/
	me.setInfo = setInfo;
	function setInfo (dataObj) {
		$.extend(user, dataObj);

		return user;
	}

	/**
		Tries to get our data from local storage and decrypts the key & value and returns the decrypted object.

		@method getUserdataFromStorage
		@private
		@return {Object} The stored/cached user data if exists and not expired.
	**/
	function getUserdataFromStorage () {
		var key,
			userObjData = {},
			encryptedObj = IBM.common.util.storage.getItem(storage.key);

		if (typeof encryptedObj === "object") {
			for (key in encryptedObj) {
				if (encryptedObj.hasOwnProperty(key)) {
					userObjData[(encryption.decode(key))] = encryption.decode(encryptedObj[key]);
				}
			}
		}

		return userObjData;
	}

	/**
		The main gig. Called at run-time of this script since there is no DOM dependency and we can do this ASAP.
		<br />Subscribes and fires event when user data is ready.
		<br />Tries to get data from local storage. If expired, invalid, or the "ip" param was used, it makes a service request.
		<br />The common user object gets populated after data retrieved from storage or on WSR callback.

		@method init
		@private
	**/
	function init () {		
		// Subscribe to ourself to fire a metric event when the user data is ready to use for the metrics.
		IBM.common.util.user.subscribe("ready", "User self-subscription", function(){
			fireEvent();
		});

		// Some wackyness with pub/sub, sometimes requires a subscription to make it subscribable. Weird.
		IBM.common.util.user.subscribe("userstateReady", "User self-subscription", function(){});

		IBM.common.meta.subscribe("dataReady", "userstaterequest", function () {
			IBM.common.util.coreservices.makeRequest("777", "IBMCore.common.util.user.setUserSigninState", {});
		}).runAsap(function () {
			IBM.common.util.coreservices.makeRequest("777", "IBMCore.common.util.user.setUserSigninState", {});
		});

		setUserdataObject();
	}


	/**
		API to call to find out if the user is signed in or not.
		<br />This should be called after subscribing to the user object "userstateReady" event. Else it will always return false.

		@method isSignedin
		@return {Boolean} True/false whether we know that the user is signed in or not to IBMID/WI.
	**/
	me.isSignedin = isSignedin;
	function isSignedin () {
		return signedin;
	}

	/**
		Try and get user data from local storage, else calls IPlookup service.
		<br />In the end, populates user object with data which is retrievable via the "getInfo" API.

		@method setUserdataObject
		@private
	**/
	function setUserdataObject () {
		// Try and get user data from local storage. Returns null or data. 
		var storageData = getUserdataFromStorage();

		/**
			Call the web service only if:
				they force an IP lookup via URL param, 
				or no data was retrieved from storage, 
				or storage data was compromised (Ex: user screws with localstorage values)
			Else the user had valid stored data, so set our user obj.
		**/
		if (ipForced !== "" || !storageData || !storageData.information_level) {
			requestUserdataFromService();
		}
		else {
			populateUserObject(storageData);
		}
	}

	/**
		Method to determine if user is signed into ID or WI.
		<br />Default signin state is false. This sets to true if we detect they are signed in.
		<br />Publishes event when we make the determination and status is available via the user object "isSignedin" API,
		<br /> or the standard user object via "user.getInfo" API.

		@method setUserSigninState
		@private
	**/
	me.setUserSigninState = setUserSigninState;
	function setUserSigninState (data) {
		// OLD WAY: Example return data:
		// 
		// "results": [{
		// 	  "regLinkVal": "",
		// 	  "userstate": "3",
		// 	  "fPathName": "IBM Sign in",
		// 	  "regLinkName": ""
		// }]
		if (data && data.results && data.results.signinstate === "1") {
			// if (data.results[0].userstate === "4") {
			// 	signedin = true;
			// }
			// If the initial service says they are logged in, CONFIRM it using the true SSO secured URL.
			IBM.common.util.coreservices.makeRequest("777", "IBMCore.common.util.user.confirmUserState", {}, true);
		}
		else {
			myEvents.publish("userstateReady");	
		}

		// Uses image check, which breaks blueid.
		// var imgCheck = $('<div><img src="https://idaas.iam.ibm.com/pics/iv30.gif" style="display:none;" /></div>').appendTo("body");
		
		// imgCheck.imagesLoaded(function(){
		// 	var loadedImg = imgCheck.children("img");
			
		// 	if (loadedImg[0].naturalWidth > 0) {
		// 		signedin = true;
		// 	}
			
		// 	myEvents.publish("userstateReady");	
		// });
	}

	// If the initial service says they are logged in, this CONFIRMS it using the true secured URL.
	me.confirmUserState = confirmUserState;
	function confirmUserState (data) {
		if (data && data.results && data.results.signinstate === "1") {
			signedin = true;
		}

		myEvents.publish("userstateReady");
	}

	// Adds the signed-in state to the user object, when the user object is ready.
	function addStateToUserObject () {
		me.subscribe("ready", "User self-subscription", function(){
			user.signedin = signedin;
		}).runAsap(function(){
			user.signedin = signedin;
		});
	}

	/**
		Populates our user object by merging in the inbound data object (from web service or localstorage or wherever).
		<br />Adds any additional misc user data from other places as needed to the user object.
		<br />Fires event that the user data is ready for use.

		@method populateUserObject
		@private
		@param dataObj {Object} The data to merge into the common user object.
	**/
	function populateUserObject (dataObj) {
		// Example cookie value:  "cc=us;lc=en;ac=all"
		var ipcCookie = IBM.common.util.cookie.get("ipcInfo"),
			ipcCookieParts = [],
			ipcCookieCC = "",
			ipcCookieLC = "";

		// Merge the inbound data object into our common user object.
		$.extend(user, dataObj);

		// Add brower language to user object.
		user.browser_lang = window.navigator.userLanguage || window.navigator.language;

		// If they have the ipcInfo cookie (from locale/planetwide page selector) add it to the user object.
		if (ipcCookie) {
			ipcCookieParts = ipcCookie.split(";");

			$.each(ipcCookieParts, function(){
				var itemParts = this.split("=");
				if (itemParts[0] === "cc") {
					ipcCookieCC = itemParts[1];
				}
				else if (itemParts[0] === "lc") {
					ipcCookieLC = itemParts[1];
				}
			});
			user.ipcinfo = ipcCookieLC + "-" + ipcCookieCC;
		}
		else {
			user.ipcinfo = "n/a";
		}

		// Publish event to tell subscribers the user data is ready for them to use.
		myEvents.publish("ready");
	}

	/**
		Requests data from the Demandbase service.
		<br />This is only called if no storage data exists (or it was past expiration date).
		<br />If the site is not *.ibm.com (referrer rules for web service), then "error" event is published.
		<br />Calls methods to populate and store user data if valid.

		@method requestUserdataFromService
		@private
	**/
	function requestUserdataFromService () {
		// If the page isn't on an ibm.com domain, don't even call the service b/c it won't work and will throw a JS error.
		if (window.location.hostname.indexOf(".ibm.com") === -1) {
			myEvents.publish("error");
			return;
		}
		
		// Allows you to pass any IP address via "?ip=x.x.x.x" in page URL for testing.
		// Build user data from returned data from service and populate our user object with it.
		// Then store it in localstorage for caching.
		$.getJSON("//www.ibm.com/webmaster/dbip/ip/?callback=?" + (ipForced !== "" ? "&query=" + ipForced : "")).done(function (data) {
			var userData = buildUserdataFromServiceRequest(data);

			populateUserObject(userData);
			storeUserData();
		});
	}

	/**
		Loops thru each of our fields (all non-PII) in the user object and encodes and stores them in localstorage.
		
		@method storeUserData
		@private
	**/
	function storeUserData () {
		var key,
		storageData = {};

		// Loop thru user object and encode each name/value.
		for (key in user) {
			if (user.hasOwnProperty(key)) {
				storageData[(encryption.encode(key))] = encryption.encode(user[key]);
			}
		}

		IBM.common.util.storage.setItem(storage.key, storageData, 3600 * 24 * (user.information_level === "basic" ? storage.expireDaysBasic : storage.expireDaysDetailed));
	}

	/** Run now.
	********************************************************************************************/
	init();

	// When we've gotten the user's signed-in state, add it to the common user object.
	// Add the user's signed-in state into the user object for peeps to use.
	me.subscribe("userstateReady", "userstatesubscription", addStateToUserObject).runAsap(addStateToUserObject);

})(jQuery, IBMCore);
;

/**

	As much as we don't want to do this, it's inevitable that we're gonna need this file.
	<br />
	<br />Things in here are only extreme cases where it's not feasible nor realistic for the page dev to put 
	proper accessibility tagging (required by JS) on an element. Item here are for __page shell elements only__.
	<br />
	<br />This file is not a crutch and should not be used as one. No module, no widgets, no content space HTML accessibility 
	goes in here at all or else I (Michael Santelia) will personally remove it! 
	<br />
	<br />Accessibility is responsibility of the thing that generates the HTML element on the page:
	<br />Template generator or widget's JS or page developer (for content space HTML).

	@class IBMCore.common.util.a11y
	
**/

(function ($, IBM) {

	var me = IBM.namespace(IBM, "common.util.a11y");

	/**
		Take a named list element (UL) and setup standard tree (WAI tree widget) keyboard accessibility controls for it.
		<br />What's special: A "tree" is a specifially designed a11y widget which is simply a list with items and nested lists.
		<br />There's not much flexibility in the core structure: UL > LI > A + UL > LI > A, etc. and because of this, this a11y 
		widget can be applied to *any* tree-type HTML structure to satisfy a11y requirements b/c it relies on the required HTML 
		structure and can easily use .next() and .prev() and .parent() successfully.
		<br />How it works: This widget uses .on() and delegated event handling, which means tree items/links can be dynamically 
		injected at any time and they will automatically work in the flow of the keyboard controls without needing to re-init 
		or specifically bind the new items.
		
		@method makeTreeAccessible
		@param settings {Object} Settings for the tree accessibility widget.
		@param settings.el {jQuery selector} The UL to apply the tree a11y controls to.
		@param [settings.focus] {Function} A custom function to call on focus of an element in the tree. Gets passed the element and 
		the event object.
		@param [settings.keydown] {Function} A custom function to call on keydown on an element in the tree. Gets passed the element 
		and the event object.	
	**/
	me.makeTreeAccessible = function (settings) {
		// Stop if the element we need to make accessible doesn't exist.
		var $rootEl = $(settings.el);
		if ($rootEl.length !== 1) {
			return;
		}
		
		// Setup left nav so only the ONE link with aria-selected="true" is the one that gets the tabstop (set index: -1 on everyone but it).
		// Once we set tabindex here, it never changes. Only focus changes. Tabindex ALWAYS stays on the aria-selected link.
		setLinkAsActive($rootEl, $("a[aria-selected='true']", $rootEl), true);
		
		// Setup left nav for single tab stop and inter-nav keyboard control.
		// Uses delegated event binding so any dynamic links added post load will be binded.
		// On focus of a link in the tab set: ONLY CHANGE FOCUS.
		// On keydown of a link in the tab set: Goto start/end/prev/next or click depending what key was pressed.
		$rootEl.on("focus", "a", function(evt) {
			// Since this is false, it just updates the UL indexnum value which is used for prev/next control to know where to go.
			//setLinkAsActive($rootEl, $(this), false);
			
			// If a focus callback was defined, call it.
			if (settings.focus) {
				settings.focus(this, evt);
			}
		}).on("keydown", "a", function(evt) {
			var $currentLink = $(this);

			switch (evt.keyCode) {
				case 9:  // Tab
					// Do nothing. Let browser goto next tabstop.
					break;
					
				case 32:  // Spacebar
					evt.preventDefault();
					$currentLink.click();
					break;
					
				case 35:  // End key
					evt.preventDefault();
					gotoLastItem($rootEl);
					break;
				
				case 36:  // Home key
					evt.preventDefault();
					gotoFirstItem($rootEl);
					break;
				
				case 37:  // Left arrow
					evt.preventDefault();
					gotoParentTreeLink($currentLink);
					break;
				
				case 38:  // Up arrow
					evt.preventDefault();
					gotoPrevTreeLink($currentLink);
					break;
					
				case 39:  // Right arrow
					evt.preventDefault();
					gotoChildTreeLink($rootEl);
					break;
					
				case 40:  // Down arrow
					evt.preventDefault();
					gotoNextTreeLink($rootEl);
					break;
			}
			
			// If a keydown callback was defined, call it.
			if (settings.keydown) {
				settings.keydown(this, evt);
			}
		});
	};
	














	// NEW: ===========================================================================================
	






	/**
		TODO: Santelia: Needs documentation.

		A "menu" is a horizontal row of (main) items which each can have a drop-down list of menu items.
	**/
	me.makeMenuAccessible = function (settings) {
		// Stop if the element we need to make accessible doesn't exist.
		var $rootEl = $(settings.el);
		if ($rootEl.length !== 1) {
			return;
		}

		// A menu system shouldn't have a pre-focused item. We can say it's selected/highlighted, but jumping to 
		//  a focused item would be wonky that's why you don't do it.

		// A menu looks like this with ARIA attrs:
		//  (UL)menubar (top-level UL)
		//	  (button)menuitem    menuitem    menuitem    menuitem  
		//	  (UL)menu        menu        menu        menu
		//	    (A)menuitem    menuitem    menuitem    menuitem  
		
		// For a11y example how it's supposed to work:  
		// Keyboard controls: https://www.w3.org/WAI/GL/wiki/Using_ARIA_menus#Success_Criteria_2.1.1_Keyboard
		// Example (from URL above): http://oaa-accessibility.org/examplep/menubar1/
		
		// Controls are based on aria-role tagging. 
		// If a web dev doesn't tag them properly, then we don't know how to control it with arrow keys!

		// Uses delegated event binding so any dynamic links added post load will be binded.
		// NOTE: The "rootEl" is the outermost, main UL.

		// Take all menu items out of the tab order except the first one. Tabbing onto the menu system always goes to first item.
		$rootEl.find(":focusable").attr("tabindex", -1).filter(":first").attr("tabindex", 0);

		$rootEl.on("focus", "a, button", function (evt) {
			// If a focus callback was defined, call it.
			if (settings.focus) {
				settings.focus(this, evt);
			}
		}).on("keydown", "a, button", function (evt) {
			var $currentLink = $(this);

			switch (evt.keyCode) {
				case 9:  // Tab
					// Remove any active classes and let browser goto next tabstop.
					$(".ibm-active", $rootEl).removeClass("ibm-active");
					break;
					
				case 27:  // Esc
					// Close menu
					$(".ibm-active", $rootEl).removeClass("ibm-active");
					break;
					
				case 32:  // Spacebar
					evt.preventDefault();
					$currentLink.click();
					break;
					
				case 35:  // End key
					evt.preventDefault();
					gotoLastItem($rootEl);
					break;
				
				case 36:  // Home key
					evt.preventDefault();
					gotoFirstItem($rootEl);
					break;
				
				case 37:  // Left arrow
					evt.preventDefault();
					menuLeftArrowControl($currentLink);
					break;
				
				case 38:  // Up arrow
					evt.preventDefault();
					menuUpArrowControl($currentLink);
					break;
					
				case 39:  // Right arrow
					evt.preventDefault();
					menuRightArrowControl($currentLink);
					break;
					
				case 40:  // Down arrow
					evt.preventDefault();
					menuDownArrowControl($currentLink);
					break;
			}
			
			// If a keydown callback was defined, call it.
			if (settings.keydown) {
				settings.keydown(this, evt);
			}
		});
	};


	/**
		NEEDS DOCUMENTATION.

		@method menuDownArrowControl
		@private
		@param $currentItemLink {jQuery selector} The currently focused link.
	**/
	function menuDownArrowControl ($currentItemLink) {
		// If we're on a menubar item, open the menu and focus on the first item in the menu.
		// Else just focus down to the next item.
		if ($currentItemLink.closest("ul").attr("role") === "menubar") {
			if ($currentItemLink.siblings("ul")[0]) {
				openMenu($currentItemLink);
				gotoFirstItem($currentItemLink.siblings("ul"));
			}
			else {
				gotoNextLink($currentItemLink.closest("ul"));
				openMenu($currentItemLink.parent("li").next("li"));
				gotoFirstItem($currentItemLink.parent("li").next("li").children("ul"));
			}
		}
		else {
			gotoNextItem($currentItemLink);
		}
	}




	function openMenu ($currentItemLink) {
		$currentItemLink.addClass("ibm-active").parent("li").siblings().removeClass("ibm-active");
	}



	/**
		NEEDS DOCUMENTATION

		@method menuRightArrowControl
		@private
		@param $currentItemLink {jQuery selector} The currently focused link.
	**/
	function menuRightArrowControl ($currentItemLink) {
		// If I'm on a main menu link and there's a next one, open it and focus on first item.
		// Else wrap to first main item and open and focus.
		var $thisMenubarLi = $currentItemLink.closest("ul[role='menu']").parent("li"),
			$thisParentLi = $currentItemLink.parent("li"),
			$nextMenuItem;

		
		if ($thisMenubarLi.next("li").length === 1) {
			$nextMenuItem = $thisMenubarLi.next("li");
		}
		else if ($thisMenubarLi.next("li").length === 0 && $thisMenubarLi.siblings("li").length > 0) {
			$nextMenuItem = $thisMenubarLi.parent("ul").children("li:first");
		}
		else {
			$nextMenuItem = $thisParentLi.next("li");
		}

		if ($nextMenuItem[0]) {
			$nextMenuItem = $nextMenuItem.siblings().removeClass("ibm-active").end().addClass("ibm-active").find(":focusable").first().focus();
			gotoFirstItem($nextMenuItem.siblings("ul"));
		}
		else {
			gotoFirstItem($currentItemLink.closest("ul"));
		}
	}

	/**
		NEEDS DOCUMENTATION

		@method menuLeftArrowControl
		@private
		@param $currentItemLink {jQuery selector} The currently focused link.
	**/
	function menuLeftArrowControl ($currentItemLink) {
		// If I'm on a main menu link and there's a next one, open it and focus on first item.
		// Else wrap to first main item and open and focus.
		var $thisMenubarLi = $currentItemLink.closest("ul[role='menu']").parent("li"),
			$thisParentLi = $currentItemLink.parent("li"),
			$nextMenuItem;

		
		if ($thisMenubarLi.prev("li").length === 1) {
			$nextMenuItem = $thisMenubarLi.prev("li");
		}
		else if ($thisMenubarLi.prev("li").length === 0 && $thisMenubarLi.siblings("li").length > 0) {
			$nextMenuItem = $thisMenubarLi.parent("ul").children("li:last");
		}
		else {
			$nextMenuItem = $thisParentLi.prev("li").length === 1 ? $thisParentLi.prev("li") : $thisParentLi.siblings("li:last");
		}

		if ($nextMenuItem[0]) {
			$nextMenuItem = $nextMenuItem.siblings().removeClass("ibm-active").end().addClass("ibm-active").find(":focusable").first().focus();
			gotoFirstItem($nextMenuItem.siblings("ul"));
		}
		else {
			gotoLastItem($currentItemLink.closest("ul"));
		}
	}



	function menuUpArrowControl ($currentItemLink) {
		// If we're on a menubar item, open the menu and focus on the first item in the menu.
		// Else just focus down to the next item.
		var $prevLink = $currentItemLink.parent("li").prev("li");

		if ($currentItemLink.closest("ul").attr("role") === "menubar") {
			if ($currentItemLink.siblings("ul")[0]) {
				openMenu($currentItemLink);
				gotoFirstItem($currentItemLink.siblings("ul"));
			}
			else {
				gotoPrevLink($currentItemLink.closest("ul"));
				openMenu($currentItemLink.closest("ul").children("li:last"));
				gotoFirstItem($currentItemLink.closest("ul").children("li:last").children("ul"));
			}
		}
		else if ($prevLink[0]) {
			gotoPrevLink($currentItemLink.closest("ul"));
		}
		else {
			gotoLastItem($currentItemLink.closest("ul"));
		}
	}


		






	// END NEW: ===========================================================================================





















	
	/**
		Take a named SINGLE tab set (a UL) and setup standard tabs (WAI tablist) keyboard accessibility controls for it.
		<br />What's special: This a11y control widget applies to a single UL, not nested ULs (like a "tree"). It differs from a 
		toolbar b/c it has one "selected" item, and the tabindex does __not__ change, which are the opposite of a menubar
		<br />The HTML structure of tabs are generally the same, but not always and can't guarantee they are in UL format. DIVs are 
		starting to replace ULs for tabbing and menus structure. 
		<b />Since we can't be 100% sure what level links are coded in tabs, we can't use .next/prev() because the link might be 
		in a span, or in a LI, or in a span in a LI, etc. or even a DIV, and the next one might need to be traversed via a parent() 
		or parent.parent(). 
		<br />How it works: It works the same as the toolbar a11y widget: We collect an array of __all__ links in the UL no matter 
		how they are nested in HTML, and use their index # from the arrayto determine the prev/next link to focus on. This widget 
		uses .on() and delegated event handling, which means tree items/links can be dynamically injected at any time and they will 
		automatically work in the flow of the keyboard controls without needing to re-init or specifically bind the new items.
		<br />An example where is is used is primary-tabs and secondary-tabs on a tab nav layout page.
		
		@method makeTabsAccessible
		@param settings {Object} Settings for the tablist accessibility widget.
		@param settings.el {jQuery selector} The element/container to apply the tablist a11y controls to.
		@param [settings.focus] {Function} A custom function to call on focus of an element in the tablist. Gets passed the element and 
		the event object.
		@param [settings.keydown] {Function} A custom function to call on keydown on an element in the tablist. Gets passed the element 
		and the event object.	
	**/
	me.makeTabsAccessible = function (settings) {
		// Stop if the element we need to make accessible doesn't exist.
		if ($(settings.el).length !== 1) {
			return;
		}
		
		// Setup tabs so only the one with aria-selected="true" is the one that gets the tabstop (set index: -1 on everyone but it).
		// Uses false b/c we setup/alter tabstops in this one call and never again for this widget type.
		setLinkAsActive($(settings.el), $("a[aria-selected='true']", $(settings.el)), true);
			
		// Setup tabs for single tab stop and inter-nav keyboard control.
		// Uses delegated event binding so any dynamic links added post load will be binded.
		// On focus of a link in the tab set: ONLY CHANGE FOCUS.
		// On keydown of a link in the tab set: Goto start/end/prev/next or click depending what key was pressed.
		$(settings.el).on("focus", "a", function(evt) {
			//setLinkAsActive($(settings.el), $(this), false);
			
			// If a focus callback was defined, call it.
			if (settings.focus) {
				settings.focus(this, evt);
			}
		}).on("keydown", "a", function(evt) {
			var $rootUl = $(settings.el);
			switch (evt.keyCode) {
				case 9:  // Tab
					// Do nothing. Let browser goto next tabstop.
					break;
					
				case 32:  // Spacebar
					evt.preventDefault();
					$(this).click();
					break;
					
				case 35:  // End key
					evt.preventDefault();
					gotoLastItem($rootUl);
					break;
				
				case 36:  // Home key
					evt.preventDefault();
					gotoFirstItem($rootUl);
					break;
				
				case 37:  // Left arrow
					evt.preventDefault();
					gotoPrevLink($rootUl);
					break;
				
				case 38:  // Up arrow
					evt.preventDefault();
					gotoPrevLink($rootUl);
					break;
					
				case 39:  // Right arrow
					evt.preventDefault();
					gotoNextLink($rootUl);
					break;
					
				case 40:  // Down arrow
					evt.preventDefault();
					gotoNextLink($rootUl);
					break;
			}
			
			// If a keydown callback was defined, call it.
			if (settings.keydown) {
				settings.keydown(this, evt);
			}
		});
	};
	
	/**
		Take a named element (a toolbar container) and setup standard toolbar (WAI toolbar) keyboard accessibility controls for it.
		<br />What's special: This a11y control widget applies to a container of links, which are serial in nature/display and do not 
		contain nested, dropdown, or dynamic changing content. It differs from a tablist b/c it has never has a "selected" item, but 
		has a single tabstop which chnages based on the last focus'd item, which is the opposite of tabs.
		<br />The HTML structure of a toolbar is completely unknown. Because of this we can't use .next/prev() because there is no way 
		to know what level of HTML nesting the actual link is in. 
		<br />How it works: It works the same as the tablist a11y widget: We collect an array of __all__ links in the toolbar container 
		no matter how they are nested in HTML, and use their index # from the array to determine the prev/next link to focus on. This 
		widget uses .on() and delegated event handling, which means tree items/links can be dynamically injected at any time and they will automatically work in the flow of the keyboard controls without needing to re-init or specifically bind the new items.
		<br />An example where is is used is the masthead country/lang links, and the social sharing toolbar.

		@method makeToolbarAccessible
		@param settings {Object} Settings for the toolbar accessibility widget.
		@param settings.el {jQuery selector} The element/container to apply the toolbar a11y controls to.
		@param [settings.focus] {Function} A custom function to call on focus of an element in the toolbar. Gets passed the element 
		and the event object.
		@param [settings.keydown] {Function} A custom function to call on keydown on an element in the toolbar. Gets passed the element 
		and the event object.	
	**/
	me.makeToolbarAccessible = function (settings) {
		// Stop if the element we need to make accessible doesn't exist.
		if ($(settings.el).length !== 1) {
			return;
		}

		//console.log($(settings.el));
		
		//settings = $.extend({useActiveClass: true}, settings);
		
		// Setup toolbar for single tab stop and inter-nav keyboard control.
		// Uses delegated event binding so any dynamic links added post load will be binded.
		// On focus of a link in the toolbar: Change tabindex and set active class.
		// On keydown of a link in the toolbar: Goto start/end/prev/next or click depending what key was pressed.
		$(settings.el).on("focus", "a", function(evt) {
			setLinkAsActive($(settings.el), $(this), true);
			
			// If a focus callback was defined, call it.
			if (settings.focus) {
				settings.focus(this, evt);
			}
		}).on("keydown", "a", function(evt) {
			var $rootUl = $(settings.el);
			
			switch (evt.keyCode) {
				case 9:  // Tab
					// Do nothing. Let browser goto next tabstop.
					break;
					
				case 32:  // Spacebar
					evt.preventDefault();
					$(this).click();
					break;
					
				case 35:  // End key
					evt.preventDefault();
					gotoLastItem($rootUl);
					break;
				
				case 36:  // Home key
					evt.preventDefault();
					gotoFirstItem($rootUl);
					break;
				
				case 37:  // Left arrow
					evt.preventDefault();
					gotoPrevLink($rootUl);
					break;
				
				case 38:  // Up arrow
					evt.preventDefault();
					gotoPrevLink($rootUl);
					break;
					
				case 39:  // Right arrow
					evt.preventDefault();
					gotoNextLink($rootUl);
					break;
					
				case 40:  // Down arrow
					evt.preventDefault();
					gotoNextLink($rootUl);
					break;
			}
			
			// If a keydown callback was defined, call it.
			if (settings.keydown) {
				settings.keydown(this, evt);
			}
		});
	};
	
	/**
		Focus on the first visible link in the given container element. This just finds the first descendent link and focuses on it.

		@method gotoFirstItem
		@private
		@param $linksContainer {jQuery selector} The element that contains links that you want to focus on the first one in.
	**/
	me.gotoFirstItem = gotoFirstItem;
	function gotoFirstItem ($linksContainer) {
		$("a:visible:eq(0)", $linksContainer).focus();
	}
	
	/**
		Focus on the last visible link in the given container element. This just finds the last descendent link and focuses on it, 
		no matter what the internal HTML structure is for container.

		@method gotoLastItem
		@private
		@param $linksContainer {jQuery selector} The element that contains links that you want to focus on the last one in.
	**/
	function gotoLastItem ($linksContainer) {
		$("a:visible:eq(-1)", $linksContainer).focus();
	}
	
	/**
		Focus on the next visible link (from current focused one) in the given container element. This uses the container's @data-activeindex 
		to determine what the current focused link index # is. Used by methods that do and don't want tabindex changed. 
		<br />If there is no next link (the last one is currently in focus), this loops back and goes to the first link per 
		a11y standards.
		<br />Will probably change to try and use has:focus.next method.

		@method gotoNextLink
		@private
		@param $linksContainer {jQuery selector} The element that contains links that you want to focus on the next one in.
	**/
	function gotoNextLink ($linksContainer) {
		/**
		var currentActiveIndex = parseInt($linksContainer.attr("data-activeindex"), 10),
			$nextLink = $("a:eq(" + (currentActiveIndex+1) +")", $linksContainer);
		**/
		// Find the index of the currently focused link, then add one to get the next VISIBLE link.
		var currFocusedLinkIndex = $("a:visible", $linksContainer).index($("a:focus", $linksContainer)),
			$nextLink = $("a:visible:eq(" + (currFocusedLinkIndex + 1) + ")", $linksContainer);

		if ($nextLink[0]) {
			$nextLink.focus();
		}
		else {
			gotoFirstItem($linksContainer);
		}
	}


	

	/**
		Focus on the previous visible link (from current focused one) in the given container element. This uses the container's 
		@data-activeindex to determine what the current focused link index # is. Used by methods that do and don't want tabindex 
		changed. 
		<br />If there is no previous link (the first one is currently in focus), this loops back and goes to the last link per 
		a11y standards.
		<br />Will probably change to try and use has:focus.prev method.

		@method gotoPrevLink
		@private
		@param $linksContainer {jQuery selector} The element that contains links that you want to focus on the previous one in.
	**/
	function gotoPrevLink ($linksContainer) {
		/**
		var currentActiveIndex = parseInt($linksContainer.attr("data-activeindex"), 10) || 0,
			$prevLink = $("a:eq(" + (currentActiveIndex-1) +")", $linksContainer);
		**/

		// Find the index of the currently focused link, then subtract one to get the previous VISIBLE link.
		var currFocusedLinkIndex = $("a:visible", $linksContainer).index($("a:focus", $linksContainer)),
			$prevLink = $("a:visible:eq(" + (currFocusedLinkIndex - 1) + ")", $linksContainer);

		if ($prevLink[0]) {
			$prevLink.focus();
		}
		else {
			gotoLastItem($linksContainer);
		}
	}




	/**
		Focus on the next item (LI/A)
		<br />If there is no next item (the last one is currently in focus), this loops back and goes to the first link per 
		a11y standards.

		@method gotoNextItem
		@private
		@param $currentLink {jQuery selector} The currently focused link.
	**/
	function gotoNextItem ($currentLink) {
		var $nextLink = $currentLink.closest("li").next("li").find("a");
		
		if ($nextLink[0]) {
			$nextLink.first().focus();
		}
		else {
			gotoFirstItem($currentLink.closest("ul"));
		}
	}


	/**
		Focus on the next link in the tree widget (from current focused one). This is specific for a tree structure 
		(ULs and nexted ULs). 
		<br />If there is no next link (the last one is currently in focus), this loops back and goes to the first link per 
		a11y standards.

		@method gotoNextTreeLink
		@private
		@param $treeLink {jQuery selector} The currently focused link.
	**/
	function gotoNextTreeLink ($treeContainer) {
		//var $nextLink = $treeLink.parent("li").next("li").find("a");
		var $nextLink = $("a:focus", $treeContainer).closest("li").next("li").find("a");
		
		if ($nextLink[0]) {
			$nextLink.first().focus();
		}
		else {
			gotoFirstItem($("a:focus", $treeContainer).closest("ul"));
		}
	}

	/**
		Focus on the previous link in the tree widget (from current focused one). This is specific for a tree structure 
		(ULs and nexted ULs). 
		<br />If there is no previous link (the first one in the current level UL is currently in focus), this loops back and 
		goes to the last link per a11y standards.

		@method gotoPrevTreeLink
		@private
		@param $currentLink {jQuery selector} The currently focused link.
	**/
	function gotoPrevTreeLink ($currentLink) {
		//var $prevLink = $treeLink.parent("li").prev("li").find("a");
		var $prevLink = $currentLink.parent("li").prev("li").find("a");
		
		if ($prevLink[0]) {
			$prevLink.first().focus();
		}
		else {
			gotoLastItem($currentLink.closest("ul"));
		}
	}

	/**
		Focus on the parent link of the currently focused link in the tree widget. This is specific for a tree structure 
		(ULs and nexted ULs). 
		<br />If there is no parent tree, goto the previous link in the current link level per a11y standards.

		@method gotoParentTreeLink
		@private
		@param $currentLink {jQuery selector} The currently focused link.
	**/
	function gotoParentTreeLink ($currentLink) {
		//var $parentLi = $treeLink.closest("ul").parent("li");
		var $parentLi = $currentLink.closest("ul").parent("li");

		if ($parentLi[0]) {
			$parentLi.children("a").first().focus();
		}
		else {
			gotoPrevTreeLink($currentLink);
		}
	}

	/**
		Focus on the first link in the next level down from the currently focused link level in the tree widget. This is 
		specific for a tree structure (ULs and nexted ULs). 
		<br />If there is no child level/links tree, goto the next link in the current link level per a11y standards.

		@method gotoChildTreeLink
		@private
		@param $treeLink {jQuery selector} The currently focused link.
	**/
	function gotoChildTreeLink ($treeContainer) {
		//var $childUl = $treeLink.closest("li").children("ul");
		var $childUl = $("a:focus", $treeContainer).closest("li").children("ul");
		
		if ($childUl[0]) {
			gotoFirstItem($childUl);
		}
		else {
			gotoNextTreeLink($treeContainer);
		}
	}

	/**
		Removes the tabstop from every link in the container and places it on the link.

		@method setLinkAsActive
		@private
		@param $treeLink {jQuery selector} The link you want to put the tabstop (tabindex=0) on.
	**/
	function setLinkAsActive ($linksContainer, $linkEl, changeTabindex) {
		// Return is the element doesn't exist b/c we need an element to do stuff.
		if (!$linkEl[0]) {
			return;
		}

		// If they want to alter the tabindex, remove tab stop from all other links and make this one have it.
		if (changeTabindex) {
			$("a", $linksContainer).attr("tabindex", -1);
			$linkEl.attr("tabindex", 0);
		}
		
		// If we were passed an EL, update the active index # to it's #.
		// Set linksContainer state data with focus'd link index # so prev/next can use it as reference.
		/**
		$("a", $linksContainer).each(function (i) {
			if (this === $linkEl[0]) {
				$linksContainer.attr("data-activeindex", i);
			}
		});
		**/
		
	}

	/**
		Automatically and dynamically sets the label on the &lt;main> element using text from the selected tab, subtab, and H1 on DOM ready.
		
		@method addMainElementLabel
		@private
	**/
	function addMainElementLabel () {
		var h1 = $("#ibm-leadspace-head h1").text() || "",
			selectedTab = $("#ibm-primary-tabs li a[aria-selected='true']").text() || "",
			selectedSubtab = $("#ibm-secondary-tabs li a[aria-selected='true']").text() || "",
			selectedLeftNav = $("#ibm-primary-links > li > a[aria-selected='true']").text() || "",
			selectedLeftSubNav = $("#ibm-primary-links > li ul li a[aria-selected='true']").text() || "";
			
		$("main").removeAttr("aria-labelledby").attr("aria-label", $.trim(selectedLeftSubNav + " " + selectedSubtab + " " + selectedLeftNav + " " + selectedTab + " " + h1));
	}
	
	/*******************************************************************************/
	// For STATIC ELEMENTS ONLY, add a11y stuff we need to add.
	// If it's a dynamic element/module/widget, then that element's JS is where any and all a11y is added. Not here.
	// Use setTimeout to push these to the back of the callstack/execution queue so it doesn't block 
	//   any other more important onload UI rendering code we set elsewhere.
	$(function(){
		addMainElementLabel();
		
		// Setup TABS as navigation accessibility widget unless it's a widget, in which case the widget JS does this as needed.
		if ($("#ibm-primary-tabs")[0] && !$("#ibm-primary-tabs[data-widget]")[0]) {
			setTimeout(function(){
				IBM.common.util.a11y.makeTabsAccessible({
					el: $("#ibm-primary-tabs")
				});
			}, 10);
		}
		
		// Setup SUBTABS as navigation accessibility widget unless it's a widget, in which case the widget JS does this as needed.
		if ($("#ibm-secondary-tabs")[0] && !$("#ibm-secondary-tabs[data-widget]")[0]) {
			setTimeout(function(){
				IBM.common.util.a11y.makeTabsAccessible({
					el: $("#ibm-secondary-tabs")
				});
			}, 10);
		}
		// Setup left nav and subnav as navigation accessibility widget.
		if ($("#ibm-primary-links")[0]) {
			setTimeout(function(){
				IBM.common.util.a11y.makeTreeAccessible({
					el: $("#ibm-primary-links")
				});
			}, 10);
		}
	});

})(jQuery, IBMCore);
;

/**

	Automatic tracking event for v18 pages.
	<br />
	<br />This event is automatically fired on page load and reports on certain features being used by the page.
	
	@class Other IBM - common v18 page tracker
	
**/

(function ($, IBM) {

	$(function(){
		var isTabnav = $("#ibm-top").hasClass("ibm-landing-page"),
			usesSidebar = $("#ibm-content-sidebar").length === 1 ? true : false ;
			
		/**
			Fires on page load using detected page features for values.

			@event EvAction: 'v18 page tracker'
		**/
		IBM.common.util.statshelper.fireEvent({
			ibmEV: "page load",
			ibmEvAction: "v18 page tracker",
			ibmEvFileSize: "n/a", // unused for now but need it to preserve reporting when changed.
			ibmEvGroup: isTabnav ? "tab nav" : "left nav", 
			ibmEvLinkTitle: "n/a", // unused for now but need it to preserve reporting when changed.
			ibmEvModule: "n/a", // unused for now but need it to preserve reporting when changed.
			ibmEvName: "n/a", // unused for now but need it to preserve reporting when changed.
			ibmEvSection: usesSidebar ? "uses sidebar" : "uses grid", 
			ibmEvTarget: "n/a" // unused for now but need it to preserve reporting when changed.
		});
	});
	
})(jQuery, IBMCore);

;

/**
	
	bit.ly shortening API.
	<br />
	<br />Takes a URL and returns the bitly short version of it to the provided success (or error) callback function.
	<br />By default it will automatically grab and the current page URL unless you specify one, as shown below.
	<br />
	<br />Usage:
		
		IBMCore.common.util.bitly.shorten({
			url: "http://long-url-to-shorten.com/",
			success: function(shortUrl) {...},
			error: function(longUrL) {...}
		});
	
	@class IBMCore.common.util.bitly
	
**/

(function ($, IBM) {

	var me = IBM.namespace(IBM, 'common.util.bitly');

	/**
		Calls bitly web service to get the short URL and returns it to the provided success/error callback.
		
		@method shorten
		@param {Object} options Object with settings to use for service call:
		@param {String} [options.url] Specific URL to use, else uses window.location.href.
		@param {Function} options.success Function to call on success of bitly service request. Passes short URL to function.
		@param {Function} [options.error] Function to call/run on bitly service request error. Passes original URL to function.
	**/
	me.shorten = function(options) {
		// Current browser URL is used if one was not provided.
		if (!options.url) {
			options.url = window.location.href;
		}
		
		$.ajax({
			url: (window.location.protocol === 'http:') ? 'http://api.bit.ly/v3/shorten' : 'https://api-ssl.bit.ly/v3/shorten',
			dataType: 'script',
			data: {
				login: IBM.common.config.bitly.login,
				apiKey: IBM.common.config.bitly.key,
				longUrl: options.url,
				format: 'json',
				callback: 'IBMCore.common.util.bitly._callback'
			},
			timeout: IBM.common.config.bitly.timeout,
			error: function(jqXHR) {
				console.error('Error while getting bit.ly URL', jqXHR);
				if (options.error) {
					options.error(options.url);
				}
			}
		});
		
		/**
			Callback executed for bit.ly JSONP web service request and runs user-defined success or error callback function.
			
			@method _callback
			@private
			@param {Object} Response data from bitly web service request.
		**/
		me._callback = function(data) {
			// Check for errors and call the user's error callback if they gave us one.
			if (!data || !data.status_code || data.status_code !== 200) {
				console.error('Error while getting bit.ly URL', data);
				if (options.error) {
					options.error(options.url);
				}
			}
			
			// Call the user's success callback if they gave us one.
			if (options.success) {
				options.success(data.data.url);
			}
		};
	};
	
	
})(jQuery, IBMCore);;

/**

	Truste
	<br />
	<br />This file adds a call to include truste JS file and add the link to the footer.
	<br />
	
	@class IBMCore.www.module.truste

**/

(function ($, IBM) {

	// Create name space for this thing and make a shortcut to it for ourselves.
	var me = IBM.namespace(IBM, "www.module.truste"),
		enabledCountries = ["at", "be", "bg", "ca", "ch", "cy", "cz", "de", "dk", "ee", "es", "fi", "fr", "gb", "gr", "hu", "ie", "it", "lt", "lv", "mx", "nl", "no", "pl", "pt", "ro", "se", "si", "sk", "uk", "us"],
		myEvents = IBM.common.util.eventCoordinator(me, "truste", ["ready"]),
		languageCode = "";

	/**
		Waits for meta to be ready then includes the truste code only if the page's country is in the list of 
		enabled countries.
		
		@method init	
	**/
	me.init = function () {
		languageCode = IBM.common.meta.page.pageInfo.ibm.lc;

		// Special for Canada - French.
		if (IBM.common.meta.page.pageInfo.ibm.lc === "fr" && IBM.common.meta.page.pageInfo.ibm.cc === "ca") {
			languageCode = "fr_CA";
		}

		// COOKIE PREF LINK (EU COOKIE LAW):  If this page is tagged for a country that requires truste, add it.
		if ($.inArray(IBM.common.meta.page.pageInfo.ibm.cc, enabledCountries) > -1) {
			me.addTrusteCookiePrefLink();
		}

		// SPECIAL CANADA COOKIE NOTICE: If this page is tagged for CA a special "AdChoices" link is added.
		// Since it's CA only, that special CANADA-ONLY truste thing is in the "canada-notice.js" file. NOT HERE.
	};

	// Get the truste script, then when API is available inject the "cookie preferences" link.
	me.addTrusteCookiePrefLink = function () {
		$.ajax({
			url: "//consent.truste.com/notice?domain=ibm.com&c=ibm-metrics&language=" + languageCode,
			dataType: "script",
			cache: true
		});

		/**
			Injects the "cookie preferences" link into the footer on enabled countries.
			<br />This runs on publish of the footer "ready" event.

			@method injectLink
			@private
		**/
		function injectCookiePrefLink () {
			// Set the link text. Only a couple different translations needed so they are just done in here (for now).
			var linkText = "Cookie preferences";
			
			if (IBM.common.meta.page.pageInfo.ibm.lc === "es") {
				linkText = "Configuración de Cookies";
				
			}
			else if (IBM.common.meta.page.pageInfo.ibm.lc === "fr") {
				linkText = "Préférences relatives aux témoins";
			}

			// Remove the one that was there (for case of dynamic locale change via meta util) and inject new one.
			$('.ibm-footer-corporate-links ul').children('#ibm-truste-cn').remove().end().append('<li id="ibm-truste-cn"><a href="#" onclick="truste.eu.clickListener();return false;">' + linkText + '</a></li>');
		}

		// Wait for Truste API to be loaded before we inject the link in the footer,
		//  otherwise it's pointless b/c the link will be broken and do nothing (uses Truste API).
		var waitingForTrusteCore = IBM.common.util.queue.push(function () {
			return typeof truste !== "undefined";
		}, function () {
			window.top.postMessage('{"PrivacyManagerAPI":{"action":"getConsent","timestamp":' + new Date().getTime() + '}}', '*');
			
			// Tell everyone truste is ready so they can sucessfully get the consent decision if they are looking for it.
			myEvents.publish("ready");
			
			// When the footer has been created and ready, inject the link.
			IBM.common.module.footer.subscribe("ready", "truste", injectCookiePrefLink).runAsap(injectCookiePrefLink);
		});

		// If it doesn't load in 5 seconds, kill the listener.
		setTimeout(function(){
			IBM.common.util.queue.remove(waitingForTrusteCore);
		}, 5000);
	};

	
	/**
		Gets the cookie consent decision for the user: If they opted out of cookie tracking or not.
		<br />Returns a simple numeric code by default. Or you can use the param option to get the full data object back.

		@method getConsentDecision
		@param [domain] {String} Allows you to specify an alternate domain if not ibm.com.
		@param [dump] {Boolean} If you want the full data object dump instead of a simple yes/no code.
		@return {Integer} Returns the consent code (default) or the data object if you wanted the full dump.
	**/
	me.getConsentDecision = function (domain, dump) {
		if (!domain) {
			domain = "ibm.com";
		}

		var json = truste.cma.callApi("getConsentDecision", domain);
		
		return dump ? json : json.consentDecision;
	};


	// function setupConsentChangeNotification () {
	// 	window.top.postMessage('{"PrivacyManagerAPI":{"action":"getConsent","timestamp":' + new Date().getTime() + '}}', '*');
		
	// 	// Does nothing:
	// 	// Listen for message from truste that the user updated the preferences and fire our event if so.
	// 	// // For all browsers except IE8.
	// 	// if (window.addEventListener) {  
	// 	// 	window.addEventListener('message', function (d) {
	// 	// 		console.log(d.data);
	// 	// 		myEvents.publish("updated");
	// 	// 	}, false);
	// 	// }
	// 	// // For IE8.
	// 	// else {
	// 	// 	if (window.attachEvent) {
	// 	// 		window.attachEvent('onmessage',  function () {
	// 	// 			myEvents.publish("updated");
	// 	// 		});
	// 	// 	}
	// 	// }

	// 	// Tell everyone truste is ready so they can sucessfully get the consent decision if they are looking for it.
	// 	myEvents.publish("ready");
	// }

	// Patch for event bug when no subscription.
	IBM.www.module.truste.subscribe("ready", "self", function(){});

	// Wait for META to complete (all head stuff runs) before doing anything b/c we need locale codes from it.
	IBM.common.meta.subscribe("dataReady", "truste", me.init);

})(jQuery, IBMCore);

;

/**

	Back-to-top dynamic link.
	<br />
	<br />When the user is scrolled down down the page at least 1 screen height this dynamic back-to-top link appears in the bottom right allowing the user to click to go back to the top of the page.
	<br />
	<br />Enabled by default.
	
	@module IBMCore
	@class IBMCore.common.module.backtotop

**/

(function ($, IBM) {

	var me = IBM.namespace(IBM, 'common.module.backtotop'),
		isActive = false,
		didScroll = false,
		windowHeight = $(window).height();

	/**
		Callback from subscription to translations data 'dataReady' event publisher. 
		<br />Checks if backtotop is enabled (default) and runs init if so.

		@method autoInit
	**/
	me.autoInit = function () {
		if (IBM.common.util.config.isEnabled("backtotop")) {
			me.init();
		}
	};
	
	/**
		Called by autoInit.
		<br />Adds dynamic back to top link to bottom right of page, visible when scrolled down > 1 screen worth.
		
		@method init
	**/
	// TODO: Santelia; Remove backdoor config option to allow local setting of text and remove default EN text.
	me.init = function () {
		var buttonAppendTo = $(IBM.common.util.config.get("backtotop.container"))[0] || $("#ibm-content-body")[0],
			buttonText = IBM.common.translations.data.v18main.misc.backtotop;
		
		$(window).scroll(function() {
			didScroll = true;
		});

		setInterval(function() {
			if (didScroll) {
				didScroll = false;
				toggleBackToTop();
			}
		}, 500);
		
		$(function(){
			// Remove any existing one b/c we're injecting a new one (for cases dynamic locale change).
			$(buttonAppendTo).find(".ibm-btt-auto").remove();

			$('<p class="ibm-btt-auto ibm-hidden-small ibm-icononly"><a class="ibm-top-link" aria-label="' + buttonText + '" href="#top">' + buttonText + '</a></p>').appendTo(buttonAppendTo).children("a").attr("tabindex","-1").click(function (evt) {
				var duration = ($(window).scrollTop() / 16);

				evt.preventDefault();
				
				$("html, body").animate({
					scrollTop: 0
				}, duration);

				// IE Hack: Remove when support for 8 is dropped.
				if ($.browser.msie && $.browser.version < 9) {
					$("html").scrollTop(0);
				}
			});

			toggleBackToTop();
		});
	};

	/** 
		Toggles the active class on the BTT link (show/hides it) and sets flag for performance enhancement so we only 
			add/remove the class when needed.

		@method toggleBackToTop
		@private
	**/
	function toggleBackToTop () {
		if ($(window).scrollTop() > windowHeight && !isActive) {
			$(".ibm-btt-auto").addClass("ibm-active").children("a").attr("tabindex","0");
			isActive = true;
		}
		else if ($(window).scrollTop() < windowHeight && isActive) {
			$(".ibm-btt-auto").removeClass("ibm-active").children("a").attr("tabindex","-1");
			isActive = false;
		}
	}

	/* Wait for translations to complete (all head stuff runs) so we can get the config value.
	**********************************************************************************************/
	IBM.common.translations.subscribe("dataReady", "backtotop", me.autoInit).runAsap(me.autoInit);

})(jQuery, IBMCore);
;

/** 

	This is simply the autoloader logic that will include the separate Canada notice JS on pages that require it.

	@class Other IBM - Canada notice loader

**/

(function ($, IBM) {
	/**
		This simply fetches the canada-notice.js file and injects it. That's it.
		<br />These conditions must be met, and if so, the Canada cookie notice JS is retrived.
		<br />1. If it doesn't already exist (IBM.common.module.canadanotice is created when canada-notice.js is loaded).
		<br />2. Must be a CA-EN|FR page.
		
		@method autoInit
	**/
	function autoInit () {
		if (!IBM.common.module.canadanotice && IBM.common.meta.page.pageInfo.ibm.cc === "ca" && (IBM.common.meta.page.pageInfo.ibm.lc === "en" || IBM.common.meta.page.pageInfo.ibm.lc === "fr")) {
			$.ajax({
				url: IBM.common.util.config.get("jsFilesUrl") + "canada-notice.js",
				dataType: "script",
				cache: true
			});
		}
	}
	
	/* Wait for events to happen.
	**********************************************************************************************/
	
	// META is a requirement. Listen for meta to be ready.
	IBM.common.meta.subscribe("dataReady", "canadanotice", autoInit).runAsap(autoInit);
	
})(jQuery, IBMCore);
;


// TODO: Santelia: Clean up, refactor, and document once we finalize functionality and what this will do with videodesk.

(function($, IBM) {

	var me = IBM.namespace(IBM, 'common.module.contactmodule'),
		$contactModule,
		$cmButton,
		allowedColors = [
			"blue-50",
			"gray-70",
			"green-50",
			"magenta-50",
			"orange-50",
			"purple-50",
			"red-50",
			"teal-50"
		],
		buttonText = "Contact IBM",
		settings = {
			bgColorClass: "",
			buttonColorClass: "",
			color: "gray-70"
		};

	// Inits onload if module and modules are enabled (default).
	me.autoInit = function() {
		if (IBM.common.util.config.isEnabled("contactModuleWidget")) {
			$(me.init); // Run onload.
		}
	};

	// This does the stuff.
	me.init = function () {
		$contactModule = $("#ibm-contact-module");
		
		setColorClassesToUse();

		// If there's no contact module on the page or if it's empty placeholder right now, stop.
		if (!$contactModule[0] || !$contactModule.children()[0]) {
			return;
		}

		// Add widget class to hide it, then format and set it up deferred.
		// This hides it, so we can put everything else in the back of the queue and process later since it's offscreen.
		$contactModule.addClass("ibm-contact-widget " + settings.bgColorClass + " addtransition ibm-hide ibm-alternate-background");

		setTimeout(setupContactModule, 100);
	};

	function setColorClassesToUse () {
		var colorOverride = IBM.common.util.config.get("contactModuleWidget.color");
		
		if (colorOverride && $.inArray(colorOverride, allowedColors) > -1) {
			settings.color = colorOverride;
		}

		settings.bgColorClass = "ibm-contact--bg-" + settings.color;
		settings.buttonColorClass = "ibm-btn-" + settings.color;
	}
	
	function setupContactModule () {
		// Add close button if it doesn't exist already.
		if (!$(".ibm-icononly .ibm-close-link", $contactModule)[0]) {
			$contactModule.prepend('<p class="ibm-icononly"><a class="ibm-close-link" href="#">Close</a></p>');
		}
		
		$contactModule.find("ul:last").addClass("ibm-padding-bottom-0");

		if ($contactModule.find("h2")[0]) {
			buttonText = $contactModule.find("h2").text();
		}

		// Inject sticky button if it doesn't already exist.
		if (!$("button.ibm-contact-widget-btn")[0]) {
			$cmButton = $('<button type="button" class="ibm-btn-pri ' + settings.bgColorClass + ' ibm-contact-widget-btn ibm-active" value="">' + buttonText + '</button>').appendTo("#ibm-content-main").click(function (evt) {
					evt.preventDefault();
					me.showContactModule(true);
				});
		}
		
		// Bind the close link.
		$contactModule.find(".ibm-close-link").click(function (evt) {
			evt.preventDefault();
			me.showContactModule(false);
		});

		// This allows the module to be hidden initially without the transition effect running onload for initial hide.
		setTimeout(function(){
			$contactModule.removeClass("ibm-hide");
		}, 1000);

		// Replace "close" with translated version when translations are available.
		IBM.common.translations.subscribe("dataready", "contactmodulewidget", translateCloseText).runAsap(translateCloseText);
	}

	function translateCloseText () {
		$contactModule.find(".ibm-close-link").html(IBM.common.translations.data.v18main.misc.close);
	}

	// API to show/hide the contact module
	me.showContactModule = function (b) {
		if (b) {
			$contactModule.addClass("ibm-active");
			$cmButton.removeClass("ibm-active");
		}
		else {
			$contactModule.removeClass("ibm-active");
			$cmButton.addClass("ibm-active");
		}
	};


	/* Wait for META to complete (all head stuff runs) so we can get the config value.
	**********************************************************************************************/
	IBM.common.meta.subscribe("dataReady", "contactmodulewidget", me.autoInit);

})(jQuery, IBMCore);
;

/**

	TODO: Santelia: This needs general refactoring and clean up.

**/

/** 

	The footer menu with the corporate links and locale selector.
	<br />
	<br />Waits for translations to be retrieved then automatically creates and injects the footer menu links onload.
		
	@class IBMCore.common.module.footermenu

**/

(function ($, IBM) {
	
	/**
		Publishes this event after footer menu links have been injected.

		@event ready
	**/
	var me = IBM.namespace(IBM, "common.module.footermenu"),
		myEvents = IBM.common.util.eventCoordinator(me, "footermenu", ["ready"]),
		v18FooterData = {};

	me.isLoaded = false;
	
	/**
		Callback from subscription to translations 'dataReady' event publisher. 
		<br />Menu link section only gets created if it's:
		<br />Enabled (default) + 
		<br />The footer is not "alternate" + 
		<br />The masthead is not "popup" type (forces popup footer).
		@method autoInit
	**/
	me.autoInit = function () {
		if (IBM.common.util.config.isEnabled("footermenu") && IBM.common.util.config.get("footer.type") !== "alternate" && IBM.common.util.config.get("masthead.type") !== "popup") {
			me.init();
		}
		else {
			// Remove the footer module on re-init in case we went from enabled to disabled locale.
			$(function(){
				$("#ibm-footer-module").remove();
				myEvents.publish("ready");
			});
		}
	};
	
	function createLinklistColumns () {
		var html = "";

		// For each object in the footer data, build a column (4-1) with heading and link list for each .links.
		$.each(v18FooterData, function(){
			var thisColumnData = this,
				lis = "";
			
			// Build the LIs for each link in this column's data set.
			$.each(thisColumnData.links, function(){
				lis += '<li><a href="' + this.url + '">' + this.title + '</a></li>';
			});

			// Wrap the list in the 4-1 column with the heading and UL and then add to return HTML.
			html += '<div class="ibm-col-4-1" aria-label="' + thisColumnData.title + '"><h3 class="ibm-bold">' + thisColumnData.title + '</h3><ul>' + lis + '</ul></div>';
		});

		return html;
	}

	/**
		Called by autoInit.
		<br />Loops thru the footermenu data and creates and injects the footer menu.
		
		@method init
	**/
	me.init = function() {
		var columnsHtml = "";

		// Glob. scoped var used by other functions here.
		v18FooterData = IBM.common.translations.data.v18main.footerMenu || [];

		// Empty the footer in cases of page locale change/re-init.
		$("#ibm-footer-module").remove();
		
		// If there are links, make the columns.
		if (v18FooterData[0].links.length > 0) {
			columnsHtml = createLinklistColumns();
		}
		
		// Inject the footer menu with the 4 cols on top/before the ibm-footer IF THEY EXIST.
		$(function(){
			if (columnsHtml !== "") {
				$("#ibm-footer").before('<div id="ibm-footer-module"><section role="region" aria-label="Resources"><div class="ibm-columns">'+ columnsHtml + '</div></section></div>');
			}

			// Tell subscribers we're done.
			myEvents.publish("ready");
		});
	};


	/* Wait for events to happen.
	**********************************************************************************************/	
	me.subscribe("ready", "footermenuself", function () {
		me.isLoaded = true;
	});

	// When translations (links) are ready, call auto init to build it. Translations can be cached, so use runAsap also.
	IBM.common.translations.subscribe("dataReady", "footermenu", me.autoInit).runAsap(me.autoInit);
	
})(jQuery, IBMCore);;

/**

	Dynamic translated footer links (main ones).
	<br />
	<br />Waits for translations to be retrieved then automatically injects translated footer links onload. 
	<br />This simply __overwrites__ HTML coded footer links in the event there is a global locale link change.
	<br />
	<br />Enabled by default.
	<br />
	<br />To disable: Add this JS snippet to your page (although you should never really do this):
	
		IBMCore.common.util.config.set({
			footer: { enabled: false }
		});
		
	@class IBMCore.common.module.footer
	
**/

// Translation need: Social links in bottom right footer.

(function ($, IBM) {

	/**
		Publishes this event after footer links have been injected.

		@event ready
	**/
	var me = IBM.namespace(IBM, 'common.module.footer'),
		myEvents = IBM.common.util.eventCoordinator(me, 'Footer', ['ready']);
	
	me.isLoaded = false;

	/**
		Callback from subscription to translations 'dataReady' event publisher. Checks if footer is enabled and runs init if so.
		
		@method autoInit
	**/
	me.autoInit = function () {
		if (IBM.common.util.config.isEnabled("footer")) {
			me.init();
		}
		else {
			// Tell subscribers we're done
			myEvents.publish("ready");
		}
	};
	
	/**
		Called by autoInit after translations are ready.
		<br />Loops thru the footer link data and creates and injects the links into the footer, overwriting the HTML coded ones.
		
		@method init
	**/
	me.init = function () {
		var mainLinks = createMainLinksHtml(),
			socialLinksSection = createSocialLinksHtml(),
			footerHtml = '<div class="ibm-footer-corporate-links">' + mainLinks + '</div>' + socialLinksSection;

		// If the masthead is popup type, automatically disable the locale selector and set footer to popup,
		// b/c it doesn't make sense in a popup.
		// This is really just safety and sanity so we can see that it was set as a popup.
		if (IBM.common.util.config.get("masthead.type") === "popup") {
			IBM.common.util.config.set({
				footer: {
					type: "popup"
				},
				localeselector: {
					enabled: false
				}
			});
		}

		$(function(){
			// Inject and overwrite the existing footer HTML.
			$("#ibm-footer").html('<div class="ibm-columns"><div class="ibm-col-1-1">' + footerHtml + '</div></div>');

			// Tell subscribers we're done
			myEvents.publish("ready");
		});
	};

	/**
		Gets the main footer links from translation data and creates and returns the UL HTML.
		
		@method createMainLinksHtml
		@private
		@return {String} The main links UL HTML.
	**/
	function createMainLinksHtml () {
		var lis = "";
		
		$.each(IBM.common.translations.data.v18main.footerThin, function() {
			lis += '<li><a href="' + this.url + '?lnk=flg">' + this.title.htmlspecialchars()+ '</a></li>';
		});
		
		return '<ul>' + lis + '</ul>';
	}


	/**
		Gets the social "follow us on" footer links and returns the UL HTML.
		
		@method createSocialLinksHtml
		@private
		@return {String} The HTML for the corporate "Follow IBM" links in the footer.
	**/
	function createSocialLinksHtml () {
		var html = "",
			links = "",
			linksHeading = IBM.common.translations.data.v18main.socialFollow.title || "Follow IBM";

		// Only create social footer links for US pages (v18b).
		if (IBM.common.util.config.isEnabled("footer.socialLinks") && IBM.common.translations.data.v18main.socialFollow.links.length > 0) {
			//html = '<div class="ibm-footer-social-links"><div><p>Follow IBM</p></div><div><p class="ibm-ind-link"><a class="ibm-twitter-encircled-link" href="http://www.twitter.com/ibm" target="blank">Twitter</a><a class="ibm-linkedin-encircled-link" href="http://www.linkedin.com/company/ibm" target="blank">Linkedin</a><a class="ibm-facebook-encircled-link" href="http://www.facebook.com/ibm" target="blank">Facebook</a><a class="ibm-youtube-encircled-link" href="http://www.youtube.com/ibm" target="blank">Youtube</a></p></div></div></div>';

			$.each(IBM.common.translations.data.v18main.socialFollow.links, function(){
				links += '<a class="' + (this.linkClass || "ibm-forward-link") + '" href="' + this.url + '" target="_blank">' + this.title.htmlspecialchars() + '</a>';
			});

			html = '<div class="ibm-footer-social-links"><div><p>' + linksHeading + '</p></div><div><p class="ibm-ind-link">' + links + '</p></div></div>';
		}

		return html;
	}

	/* Wait for events to happen.
	**********************************************************************************************/
	me.subscribe("ready", "footerself", function () {
		me.isLoaded = true;
	});
		
	// When translations (links) are ready, call auto init to build it. Translations can be cached, so use runAsap also.
	IBM.common.translations.subscribe("dataReady", "Footer", me.autoInit).runAsap(me.autoInit);
	
})(jQuery, IBMCore);;

/**

	Liveperson
	<br />
	<br />This enables the liveperson functionality on the page, includes the core JS file and injects the placeholder div if needed.
	<br />
	<br />Disabled by default (omission of setting). This is an opt-in service and requires a LP routing code (contact Raymond Gardner). 
	<br />To set this on your page, create a new object in the digitalData object. Set enabled to true, and put your proper LP routing code in there (same one you used in v17 "editSkill"):
	
	digitalData = {
		page: {
			.....
			
			pageInfo: {
				.....
				
				liveperson: {
					enabled: true,
					routing: "__REPLACE-ME__"
				}
			}
		}
	}
	
	@module IBMCore
	@class IBMCore.common.module.liveperson

**/

(function ($, IBM) {

	var me = IBM.namespace(IBM, "common.module.liveperson");

	/**
		Callback from subscription to translations data 'dataReady' event publisher. 
		<br />Checks if backtotop is enabled (default) and runs init if so.

		@method autoInit
	**/
	me.autoInit = function () {
		var lpinfo = IBM.common.meta.page.pageInfo.liveperson;

		if (lpinfo && lpinfo.enabled && lpinfo.routing && lpinfo.routing !== "") {
			me.init();
		}
	};
	
	/**
		Called by autoInit.
		<br />Sets proper var expected by LP code, injects common placeholder if none exists, then includes LP js.
		
		@method init
	**/
	me.init = function () {
		window.lpEditSkill = window.editskill || IBM.common.meta.page.pageInfo.liveperson.routing;

		$(function(){
			if (!document.getElementById("lpbutton") && document.getElementById("ibm-contact-module")) {
				$('#ibm-contact-module ul:first').before('<div id="lpbutton"></div>');
			}

			$.ajax({
				url: "//1.www.s81c.com/common/v18/js/liveperson.js",
				dataType: "script",
				cache: true
			});
		});
	};

	
	/* Wait for translations to complete (all head stuff runs) so we can get the config value.
	**********************************************************************************************/
	IBM.common.meta.subscribe("dataReady", "liveperson", me.autoInit).runAsap(me.autoInit);

})(jQuery, IBMCore);
;


/**

	TODO: Santelia: This needs general refactoring and clean up, like this:

	- Remove the DOM injection placement logic from this file. 
	- It should simply be a module that does nothing except generate a DOM element in a var for you.
	- You subscribe to ready event, and when ready you inject it where you want/need it.
		Ex: 
			Footermenu subscribes and injects in there.
			Alternate footer subscribes and injects in there.


**/

/** 

	Locale selector
	<br />
	<br />This is the locale selectlist navigator in the footer. It allows the user to goto a different locale corporate portal home page.
	<br />This replaces the need for a separate standalone "Select a country" page by putting the same select list from that page in the footer of every page.
	<br />It also allows the page owner to specify that they have translated versions of the page using the Google standard alternate hreflang tagging. So you get bonus points for SEO with this.
	<br />View the standards page, or: http://nsdev.somerslab.ibm.com/v18/test/accesstest/locale-selector.php for information how to code your page to also use this as your "translated versions of this page" selector.

	@class IBMCore.common.module.localeselector

**/

(function ($, IBM) {
	
	/**
		Publishes this event after footer locale selector has been injected.

		@event ready
	**/
	/**
		Publishes this event if we can't get footer locale selector translations.

		@event error
	**/
	var me = IBM.namespace(IBM, "common.module.localeselector"),
		myEvents = IBM.common.util.eventCoordinator(me, "Localeselector", [
			"ready",
			"error"
		]),
		selectorData = {},
		selectorHtml = "";
	
	/**
		Automated callback from subscription to meta 'dataReady' event publisher. 
		
		@method autoInit
	**/
	me.autoInit = function () {
		if (!IBM.common.util.config.isEnabled("localeselector") || IBM.common.util.config.get("masthead.type") === "popup") {
			myEvents.publish("ready");
			return;
		}
		else if (IBM.common.util.config.isEnabled("footer") || IBM.common.util.config.isEnabled("footermenu")) {
			me.init();
		}
	};
	

	// Request the translations then create the selector.
	me.init = function () {
		// Example URL: http://1.www.s81c.com/common/js/dynamicnav/www/countrylist/usen-utf8.js

		// Santelia: Dec. 2 per Marc/Kevin: FORCE US/EN ALWAYS until we get 1 file output with each locale in IT'S OWN LANGUAGE.
		$.ajax({
			//url: "//1.www.s81c.com/common/js/dynamicnav/www/countrylist/" + IBM.common.meta.page.pageInfo.ibm.cpi + "-" + IBM.common.meta.page.pageInfo.ibm.encoding + ".js",
			url: "//1.www.s81c.com/common/js/dynamicnav/www/countrylist/usen-utf8.js",
			dataType: "script",
			cache: true
		}).fail(function (message) {
			console.error("Error while loading locale selector file", message);
			myEvents.publish("error");
		});
	};

	// This runs after we get the v17 country list. This will get updated after we make a new v18 one.
	// Now that we have the country list, wait for translations to be ready so we know where to put the selector.
	me.dataCallback = dataCallback;
	function dataCallback (serviceData) {
		selectorData = serviceData;

		IBM.common.translations.subscribe("dataReady", "localeselector", createSelector).runAsap(createSelector);
	}

	function createSelector () {
		selectorHtml = createLocaleSelectorHtml();
		
		// Default: Verify there are footer menu links and wait until the footermenu is injected, then inject selector.
		// Else we force set footer to be alternate version and wait for corporate thin footer and inject in there.
		if (IBM.common.util.config.get("footer.type") !== "alternate" && IBM.common.translations.data.v18main.footerMenu[0].links.length > 0) {
			IBM.common.module.footermenu.subscribe("ready", "localeselect", me.setupLocaleSelector).runAsap(me.setupLocaleSelector);
		}
		else {
			IBM.common.util.config.set({footer: {type: "alternate"}});
			IBM.common.module.footer.subscribe("ready", "localeselect", me.setupLocaleSelector).runAsap(me.setupLocaleSelector);
		}		
	}

	/** 
		Parse the country data from translations and build the select list HTML then returns it.

		@method createLocaleSelectorHtml
		@private
		@return {String} The select list HTML.
	**/
	function createLocaleSelectorHtml() {
		var opts = "",
			cc = "",
			lc = "",
			altText = selectorData.translations.select;

		// Data is broken into regions, so flatten it and build a select list.
		$.each(selectorData.regionList, function () {
			$.each(this.countryList, function () {
				var cname = this.name;

				$.each(this.locale, function () {
					lc = this[0].substr(0, 2);
					cc = this[0].substr(3);

					if (cc === "gb") {
						cc = "uk";
					}
					opts += '<option data-localecode="' + lc + "-" + cc + '" value="http://www.ibm.com/' + cc + '-' + lc + '/?lnk=fcc">' + cname + ' - ' + this[1] + '</option>';
				});
			});
		});

		return '<select aria-label="' + altText + '">' + opts + '</select>';
	}
	
	/** 
		Setup the locale selector with some magicness. Called after footer is injected into DOM, 
		 via setTimeout so we don't block important rendering.
		<br />Sorts it, selects the page's current locale, and swaps out any links for any corresponding local 
		 alternate links found in &lt;link rel="alternate" hreflang="__"> elements.
		<br />For information on this element: <a href="http://moz.com/learn/seo/hreflang-tag" target="_blank">http://moz.com/learn/seo/hreflang-tag</a>

		@method setupLocaleSelector

	**/
	me.setupLocaleSelector = setupLocaleSelector;
	function setupLocaleSelector () {
		var $localeSelectlist = $("#ibm-footer-locale-selector"),
			opts,
			localeOption;

		// TODO: SANTELIA: CHANGE THIS TO PERMANENT 4-1 AFTER NEW XLATIONS ARE LIVE.
		// If the placeholder doesn't already exist (from a locale change),
		//  inject the placeholder into the proper place on the page, then inject the select list and set it up.
		if (!$localeSelectlist[0]) {
			if (IBM.common.util.config.get("footer.type") !== "alternate") {
				if ($("#ibm-footer-module .ibm-columns .ibm-col-4-1").length > 1) {
					$localeSelectlist = $('<div class="ibm-columns"><div id="ibm-footer-locale-selector" class="ibm-col-4-1 ibm-col-medium-4-2 ibm-fright"></div></div>').insertAfter("#ibm-footer-module .ibm-columns");
				}
				else {
					$localeSelectlist = $('<div class="ibm-columns"><div class="ibm-col-6-2 ibm-padding-top-0"></div><div class="ibm-col-6-2 ibm-padding-top-0"></div><div id="ibm-footer-locale-selector" class="ibm-col-6-2"></div></div>').insertAfter("#ibm-footer-module .ibm-columns");
				}
			} 
			else {
				$("#ibm-footer").addClass("ibm-alternate");
				$localeSelectlist = $('<div id="ibm-footer-locale-selector"></div>').insertAfter(".ibm-footer-corporate-links");
			}
		}


		$localeSelectlist = $("#ibm-footer-locale-selector").html('<h3 class="ibm-bold">' + selectorData.translations.select + '</h3>' + selectorHtml).children("select");
		
		opts = $("option", $localeSelectlist);

		// Sort and bind select list.
		opts.sort(function (a, b) {
			if (a.text > b.text) {
				return 1;
			}
			
			if (a.text < b.text) {
				return -1;
			}
			
			return 0;
    	});

		$localeSelectlist.html(opts).on("change.defaultAction", function(){
			// Allows a page to define a custom onchange event by turning this change off and defining their own.
			// Then they can decide to run the goto selction or not.
			me.defaultOnchangeAction();
		});

		// Loop thru any alternate locale links set by the page dev and swap them into the locale select list so those 
		//  locale options goto the local page URL instead of corp. home page for it.
		if ($("link[rel='alternate'][hreflang][href]").length > 0) {
			opts = [];

			$("link[rel='alternate'][hreflang][href]").each(function () {
				var thisCode = $(this).attr("hreflang"),
					thisUrl = $(this).attr("href"),
					thisLabel = $(this).data("label");

				// If the custom <link> has a label: 
				//   It means it should be ADDED and may or may not already exist in the official IBM locale list.
				//   So we add it and then remove the existing one if it exists.
				// Else if the code is > 2, it's inferred it's got full lc-cc, so we replace the SINGLE matching item URL.
				// Else if the code is exactly 2, it means language first, so replace ALL items with that language code's URL.
				if (thisLabel) {
					opts.push($('<option data-localecode="' + thisCode + '" value="' + thisUrl +'">' + thisLabel +'</option>'));
					$("option[data-localecode='" + thisCode + "']", $localeSelectlist).remove();
				}
				else if (thisCode.length > 2) {
					opts.push($("option[data-localecode='" + thisCode + "']", $localeSelectlist).attr("value", thisUrl));
				}
				else if (thisCode.length === 2) {
					$("option[data-localecode^='" + thisCode + "']", $localeSelectlist).each(function(){
						opts.push($(this).attr("value", thisUrl));
					});
				}
			});

			// Now take the locales that have URL for this page's version (we pushed them into an array above), 
			//  sort them, then put them at the top of the list.
			opts.sort(function (a, b) {
				if (a[0].text > b[0].text) {
					return 1;
				}
				
				if (a[0].text < b[0].text) {
					return -1;
				}
				
				return 0;
			});

			/** Not cross browser support. Only works in FF.
			$localeSelectlist.prepend('<option value="" style="font-weight: bold;color: #555;border-top: 1px solid #555;margin-top: 4px;">Worldwide ibm.com home pages</option>')
				.prepend(opts)
				.prepend('<option value="" style="font-weight: bold;color: #555;">Translated versions of this page</option>');
			**/

			// Wrap the options in a group with a label, acts as the section heading.
			$localeSelectlist.wrapInner('<optgroup label="' + IBM.common.translations.data.v18main.localeSelector.homepages + '"></optgroup>')
				.prepend($('<optgroup label="' + IBM.common.translations.data.v18main.localeSelector.localVersions + '"></optgroup>').html(opts));

		}
		else {
			$localeSelectlist.wrapInner('<optgroup label="Worldwide ibm.com home pages"></optgroup>');
		}

		// NOTE: THIS MUST BE LAST. If you change the order of the options, the selected item gets messed up.
		// You have to do all your <option> shuffling and lastly pick one to be selected.
		// Auto-select the one that matches the page's currently set locale (from meta data).
		localeOption = $("option[data-localecode='"+ IBM.common.meta.page.pageInfo.ibm.lc + "-" + IBM.common.meta.page.pageInfo.ibm.cc + "']", $localeSelectlist).prop("selected", true);
		
		IBM.common.widget.selectlist.init($localeSelectlist, {
			width: "100%"
		});
		
		me.$el = $localeSelectlist;

		myEvents.publish("ready");
	}

	me.defaultOnchangeAction = function () {
		var localeData = me.$el.find(":selected").data("localecode");

		if (localeData) {
			// Locale codes are lc-cc.
			localeData = localeData.split("-");

			// Setting ipcInfo cookie.
			IBM.common.util.cookie.set("ipcInfo", "cc=" + localeData[1] + ";lc=" + localeData[0] + ";ac=all", {
				path: "/",
				domain: ".ibm.com",
				expires: 365 * 24 * 3600 // How many seconds from now. (1 yr)
			});
		}
		
		if (this.value !== "") {
			window.location.href = me.$el.val();
		}
	};

	// TODO: Santelia: Generate new ECM output for v18 for these files.
	// Temp fix:  Alias this shit until we get the new ECM output files setup.
	window.ibmweb = window.ibmweb || {};
	IBM.namespace(window.ibmweb, "dynnav.localeselector.dataCallback");
	window.ibmweb.dynnav.localeselector.dataCallback = me.dataCallback;


	/* Wait for events to happen.
	**********************************************************************************************/
	
	// META is a requirement. Listen for Meta to be finished, then get the translations.
	IBM.common.meta.subscribe("dataReady", "localeselector", me.autoInit).runAsap(me.autoInit);
	
})(jQuery, IBMCore);
;


// TODO: Santelia: Add full documentation for this after we nail down the final design and interaction.

/**

	How the masthead works:
		There are technically 4 mastheads, each has their own configurable setting.
		In reality, there's only 2 different HTML outputs and CSS hides shit on the other two.

		#1. Popup - This is the absolute minimal, "logo-only" masthead only used on popup windows. 
			This is the base, with all modules disabled.
		#2. Mobile - This is deprecated as a settable config.
		#3. Minimal - This is the "application masthead". This is the popup + shows the search, signin and burger icons.
		#4. Full - This is the DEFAULT. This the minimal + inline CAMS links and the megamenu. 
			Inline links are hidden when browser is not wide enough.

		Page owners can override and choose either "alternate" or "popup" masthead type per their choosing, but based on our rules/guidelines.

**/


/**

	Masthead.
	<br />
	<br />This is the main file for the masthead and everything associated with it.
	<br />This waits for translations to be available and onload will create the main masthead links and associated functionality.
	<br />
	<br />Available options/settings:
		"alternate": Same as the default, but WITHOUT the inline CAMS links.
		"popup": For use ONLY on popup pages. Only the logo shows in the masthead.

	@class IBMCore.common.module.masthead

**/

// Translation need: EVERYTHING.

(function($, IBM) {
	/**
		Publishes this event after complete masthead is built.

		@event ready
	**/
	/**
		Publishes this event after the profile menu is built.

		@event profileMenuReady
	**/
	//// 
	//  Variables
	////
	var me = IBM.namespace(IBM, "common.module.masthead"),
		myEvents = IBM.common.util.eventCoordinator(me, "Masthead", [
			"ready",
			"profileMenuReady",
			"userProfileImageReady"
		]),
		$masthead = null,
		mastheadData = {
			unav: null,
			catnav: null,
			tryandbuy: null
		},
		mastheadLinklist = {
			catnav: {
				$el: null,
				html: ""
			},
			iconsonly: {
				$el: null,
				html: ""
			},
			tryandbuy: {
				$el: null,
				html: ""
			},
			unav: {
				$el: null,
				html: ""
			}
		},
		mastheadType = "",
		mastheadTypeMapping = {
			"default": "full",
			alternate: "minimal",
			mobile: "mobile",
			popup: "popup"
		},
		mastheadWidthUsed = 0,
		megamenu = {
			$closeButtonLink: null,
			$el: null,
			$sectionShowing: null,
			isopen: false
		},
		profilePhotoData = {},
		showingMobileMasthead = false,
		$profileMenu = null,
		v18Data = {};

	me.isLoaded = false;

	/**
		Callback from subscription to meta data 'ready' event publisher. Checks if masthead is enabled. 
		<br />If so, subscribe to translations and call init when translations are ready.

		@method autoInit
	**/
	me.autoInit = function() {
		if (IBM.common.util.config.isEnabled("masthead")) {
			me.init();
		}
	};

	/**
		Callback from subscription to translation 'dataAndDomReady' event publisher inside autoInit. 
		<br />Runs several function to do three key things: 
		<br />1. Set the data sources.
		<br />2. Create the links from the data sources.
		<br />3. Configure the HTML per current page settings and echo it on the glass.

		@method init
	**/
	me.init = function() {
		//  #### NOTE: ####
		// In here, DOM is not ready yet.
		// Do only the absolute required processing and HTML generation needed for content on the glass on page load.
		// Defer everything else (hidden elements) via settimeout to put it to the back of the queue.
		// For example: megamenu (if used), drop-down menus, mobile menu, and accessibility should all be deferred 
		//  because that can happen behind the scenes in the background.
		//
		// NOTE: ALL specific masthead elements are selector cached on injection. ID/Classes should NEVER be used after we
		//  inject the HTML unless it's for a specific condition. Always use the cached selectors (in var declaration at top).

		// Pull in the applied setting for what masthead to use.
		mastheadType = IBM.common.util.config.get("masthead.type");

		mastheadType = mastheadTypeMapping[mastheadType];

		// Pull in the new v18 data to use.
		v18Data = IBM.common.translations.data.v18main;

		// Marketplace link:
		// Not in mastehad inline links (currently). It's used in the mobilemenu.js. We just set it here.
		// Per Chinh Hoang (choang@ca.ibm.com): Auto-gen marketplace link no matter what, just use page locale meta data.
		// Syntax example:  http://www.ibm.com/marketplace/cloud/cz/en-cz
		mastheadData.unav = v18Data.unav;
		mastheadData.catnav = v18Data.catnav;
		mastheadData.tryandbuy = {
			title: v18Data.marketplace.title,
			url: "http://www.ibm.com/marketplace/cloud/" + IBM.common.meta.page.pageInfo.ibm.cc + "/" + IBM.common.meta.page.pageInfo.ibm.lc + "-" +  IBM.common.meta.page.pageInfo.ibm.cc
		};

		// If the translation data file (country) has an override URL, use it instead.
		// New, Feb 18, 2015, per Greg Sherman.
		if (v18Data.marketplace.url && v18Data.marketplace.url !== "") {
			mastheadData.tryandbuy.url = v18Data.marketplace.url;
		}

		// Create and store the <li> HTML for each masthead module. Any conditions or rules exist in the functions themselves.
		mastheadLinklist.unav.html = createLinklistUnav();
		mastheadLinklist.catnav.html = createLinklistCatnav();
		mastheadLinklist.iconsonly.html = createLinklistIconsonly();
		
		// Now that we've built the HTML, we're ready to inject HTML and do setup and bindings.
		$(function() {
			/**

				First we ONLY inject the links we need on the glass and any swizzling to get them out ASAP. 
				Then we defer all "setup" functionality.
				Each of the createMasthead_____ functions adds a class that makes styling easy, based on the type of masthead.
				
				Cases from minimal to maximum. What is always there, what isn't:
				
				If popup:
					Hide #ibm-menu-links, #ibm-search-module.
					Stop.

				If mobile: (Need all links so mobilemenu can clone them. Future: set in var so MM just injects var.)
					+ catnav (hidden CSS)
					+ unav (hidden CSS)
					+ iconsonly

				If minimal: (Same as mobile as of now):
					+ catnav (hidden CSS)
					+ unav (hidden CSS)
					+ iconsonly
				
				If full: (Same as minimal + catnav & megamenu):
					+ catnav
					+ unav (hidden CSS)
					+ iconsonly
					+ megamenu

			**/

			// Do some resets for the "change page locale" utility.
			$("#ibm-megamenu-sections, .ibm-masthead-categories, .ibm-masthead-unav, .ibm-masthead-iconsonly").remove();
			$masthead = $("#ibm-masthead");

			// Set popup masthead to not have anything extra created.
			if (mastheadType === "popup") {
				createMastheadPopup();

				IBM.common.util.config.set({
					masthead: {
						megamenu: { enabled: false },
						mobilemenu: { enabled: false },
						profile: { enabled: false },
						search: { enabled: false },
						sticky: { enabled: false }
					}
				});
			}
			// TODO: Deprecate this and make mobile config set it as "alternate".
			// TODO: ^ Validate no CSS dependency on the mobile masthead class we use.
			else if (mastheadType === "mobile") {
				createMastheadMobile();
			}
			else if (mastheadType === "minimal") {
				createMastheadMinimal();
				setupSearchfieldResponsiveness();
			}
			else if (mastheadType === "full") {
				createMastheadFull();
				setMastheadWidthUsed();
				setupMastheadResponsiveness();
				setupSearchfieldResponsiveness();

				// Create megamenu and bind it.
				defer(function(){
					if (IBM.common.util.config.isEnabled("masthead.megamenu")) {
						createMegamenu();
						setupMegamenuBindings();
					}
				});
			}
			else {
				return;
			}

			// NOTE: ALL specific masthead elements are selector cached on injection. 
			// ID/Classes should NEVER be used at this point unless it's for a specific condition. 
			// Always use the cached selectors (in var declaration at top).

			////////////////////////////////////////////////////////
			// START COMMON DEFERRED ITEMS
			////////////////////////////////////////////////////////

			// Setup bindings for masthead ICONS on right side.
			defer(setupMastheadIconBindings);

			defer(setupMastheadAccessibility);
			
			defer(animateLogo);
			
			defer(function () {
				$("#ibm-home a")[0].href += "?lnk=m";
			});

			// Create profile drop-down menu ONLY if it's enabled. DUH.
			// Creates "anonymous" menu by default, and if greeting service is enabled, makes call and waits for 
			//  return data to decide if it needs to change the menu links.
			if (IBM.common.util.config.isEnabled("masthead.profile")) {
				defer(function() {
					addProfileMenuToMasthead();
					setupMastheadProfileMenu();
				});
			}

			// Followup TODOS next:

			// Scrub mobile-menu.js
			// Scrub masthead-search.js

			// Test cross browser.

			// Tell subscribers we're all done.
			me.isLoaded = true;

			myEvents.publish("ready");
			
		});
	};

	/**
		Simply inserts the masthead main category links into the masthead.
		<br />Eventually we will start making pages code these in the HTML when the changes settle down, for SEO purposes.
		
		@method addCategoriesToMasthead
		@private
	**/
	function addCategoriesToMasthead () {
		// Inject the new categories nav links.
		mastheadLinklist.catnav.$el = $(mastheadLinklist.catnav.html).insertBefore("#ibm-menu-links");
	}

	/**
		Inserts the masthead main ICON links into the masthead (inside a right-float container),
		 and moves the search div into the container also.
		<br />Also caches the signin icon selector for updating with user state.
		
		@method addIconsToMasthead
		@private
	**/
	function addIconsToMasthead () {
		// Add the new right-align container and put the icons and the search container into it.
		mastheadLinklist.iconsonly.$el = $('<div class="ibm-masthead-rightside">'+ mastheadLinklist.iconsonly.html + '</div>').prepend($("#ibm-search-module")).insertAfter("#ibm-menu-links");
		$profileMenu = mastheadLinklist.iconsonly.$el.find(".ibm-masthead-item-signin");

		convertSearchSubmitToButton();
	}

	function convertSearchSubmitToButton () {
		var attrs = "",
			$searchButton = $("#ibm-search").removeClass("ibm-btn-search").addClass("ibm-masthead-search-link");
			
		$.each($searchButton[0].attributes, function() {
			attrs += ' ' + this.name + '="' + this.value + '"';
		});
		
		$searchButton.replaceWith('<button' + attrs + ' aria-label="' + $searchButton.val() + '"></button>');
	}



	////////////////////////////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// 
	// Profile icon and menu setup
	//
	////////////////////////////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////////////////////////////

	/**
		Creates the profile item drop down menu, default is as anonymous user using "signed out" links from xlation file.
		<br />When service comes back with user-state determination, we change this *if user is signed in*.
		
		@method createProfileMenuAnony
		@private
	**/
	function createProfileMenuAnony () {
		var menuLinksLis = createMenuListItems(v18Data.profileMenu.signedout);
		
		return menuLinksLis;
	}

	/**
		This is called after we have determined that the user *is signed in*.
		<br />It ONLY creates new LIs to inject into the existing drop down menu.
		
		@method createProfileMenuSignedin
		@private
	**/
	function createProfileMenuSignedin () {
		var menuLinksLis = createMenuListItems(v18Data.profileMenu.signedin);
		
		return menuLinksLis;
	}

	/**
		Creates "anonymous" profile menu and injects it.
		<br />We have to wait for the service call to return to know if they are signed in, at which point we swap it.
		
		@method addProfileMenuToMasthead
		@private
	**/
	function addProfileMenuToMasthead () {
		var profileMenuLinks = createProfileMenuAnony();
		
		// Stop if there's no sign-in links b/c it means there's nothing to put in a menu.
		if (profileMenuLinks === "") {
			return;
		}

		// Put the links inside a UL and inject into DOM.
		$profileMenu.append('<ul id="ibm-signin-minimenu-container" role="menu" aria-label="Profile" class="ibm-padding-top-0">' + profileMenuLinks + '</ul>');

		// If the greeting config is NOT enabled, stop and leave the default "anonymous" menu there.
		// Publish menu ready event so DW and PW can modify.
		// Self subscribe for weird pub/sub bug.
		IBM.common.module.masthead.subscribe("profileMenuReady", "self", function(){});

		if (!IBM.common.util.config.isEnabled("greeting")) {
			myEvents.publish("profileMenuReady");
			return;
		}
	}

	function requestPhoto () {
		// $.ajax({
		// 	url: IBM.common.util.config.get("photoServiceUrl"),
		// 	dataType: 'jsonp',
		// 	timeout: 2000,
		// 	success: function (data) {
		// 		profilePhotoData = data;
		// 		updateProfileMenu();
		// 	},
		// 	error: function (data) {
		// 		console.error("Error calling photo service, returned: ", data);
		// 		updateProfileMenu();
		// 	}
		// });
		if (!$profileMenu || !$profileMenu.children("ul")[0]) {
			IBM.common.util.queue.push(function () {
				return $profileMenu && $profileMenu.children("ul")[0] ;
			}, updateProfileImageTEMP);
		}
		else {
			updateProfileImageTEMP();
		}
	}

	me.requestNotifications = requestNotifications;
	function requestNotifications () {
		// $.ajax({
		// 	url: IBM.common.util.config.get("notificationServiceUrl"),
		// 	dataType: 'jsonp',
		// 	timeout: 2000,
		// 	success: function (data) {
		// 		// TESTING ONLY:
		// 		//data.count = 4; // COMMENT OUT FOR PROD.
		// 		showNotificationCount(data.count);
		// 	},
		// 	error: function (data) {
		// 		console.error("Error calling notification service, returned: ", data);
		// 	}
		// });

		//// TEMP. OVERWRITE THIS WITH NEW services BRANCH WHEN PHOTO IS FIXED:
		if (!$profileMenu) {
			IBM.common.util.queue.push(function () {
				return $profileMenu;
			}, function () {
				IBM.common.util.coreservices.makeRequest("171", "IBMCore.common.module.masthead.tmpnotifcb", {}, true);
			});
		}
		else {
			IBM.common.util.coreservices.makeRequest("171", "IBMCore.common.module.masthead.tmpnotifcb", {}, true);
		}
	}

	me.tmpnotifcb = tmpnotifcb;
	function tmpnotifcb (data) {
		if (data && data.count) {
			showNotificationCount(data.count);
		}
	} 

	// If number is > 0: show the count in the masthead profile thumb and in the special tagged menu item,
	// Else, remove the div (in cases of dynamic sign in/out without reload we don't want empty or incorrect box #). 
	me.showNotificationCount = showNotificationCount;
	function showNotificationCount (num) {
		var $iconNcContainer = $(".ibm-notification-count"),
			$linkWithNc = $('.ibm-masthead-item-signin').find('li[data-linktype="notifications"] a');
		
		// For the link, that gets overritten each locale/masthead change and is a tag on a link.
		// Show notification in icon.
		// If the placeholder isn't there, add it.
		// Else remove it.
		if (num > 0) {
			if (!$iconNcContainer[0]) {
				$iconNcContainer = $('<div class="ibm-notification-count"></div>').appendTo('.ibm-masthead-item-signin');
			}

			$iconNcContainer.html(num);

			// For the link in the menu.
			// If the link exists, check if the span is there already or not and add, then inject #.
			if ($linkWithNc[0]) {
				if (!$linkWithNc.children("span")[0]) {
					$linkWithNc.append("<span></span>");
				}
				$linkWithNc.children("span").html(' (' + num + ')');
			}

		}
		else {
			$iconNcContainer.remove();
		}

		// Show notification in the link.
	}

	// TEMP Update because the friggen IBMID team changed the service to return an image instead of JSONP for some reason.
	// They are changing it back in two weeks, at which time this will be deleted and the function below will be used again.
	function updateProfileImageTEMP () {
		var signedinListitems = createProfileMenuSignedin(),
			signedinData = {
				linkContents: "",
				linkAlt: IBM.common.translations.data.v18main.misc.welcomeback,
				backgroundImage: "",
				type: "default"
			};

		// Change the menu to the "user is signed in" one ONLY if there are links from the translation data file. 
		// Otherwise we keep it as "signedout" links.
		if (signedinListitems !== "") {
			$profileMenu.children("ul").html(signedinListitems);
		}

		signedinData.type = "image";
		signedinData.backgroundImage = IBMCore.common.util.config.get("coreservicesUrl") + "cc=us&lc=en&format=image&ts=" + new Date().getTime() + "&cb=170%3AIBMCore.common.util.user.updateProfileImage";
		
		// Show the profile link as "signed in" then adjust used space, toggle links and search field if needed.
		showProfileLinkSignedin(signedinData);
		setMastheadWidthUsed();
		toggleInlineLinks();
		toggleSearchField();

		// Add the user's profile image to the user object.
		IBM.common.util.user.subscribe("ready", "Masthead profile", function(){
				IBM.common.util.user.setInfo({"imageUrl": signedinData.backgroundImage});
				myEvents.publish("userProfileImageReady");
			}).runAsap(function(){
				IBM.common.util.user.setInfo({"imageUrl": signedinData.backgroundImage});
				myEvents.publish("userProfileImageReady");
			});
		
		myEvents.publish("profileMenuReady");
	}


	/**
		This swaps the "anonymous" profile menu with links for a "signed in user", and it changes the icon 
		 to a "signed in" one. 
		<br />Default signed-in is reversed icon, if photo service returns personalized image url, we use that.
		<br />This is only called if a user is signed in AND we have both services' data available to use.
		<br />It also resets the masthead "required width" needed to fit all links across the screen so we know when to hide them.
		
		@method updateProfileMenu
		@private
	**/ 
	function updateProfileMenu () {
		var data = $.extend({result: {url: ""}}, profilePhotoData),
			imageUrl = data.result.url,
			signedinListitems = createProfileMenuSignedin(),
			signedinData = {
				linkContents: "",
				linkAlt: IBM.common.translations.data.v18main.misc.welcomeback,
				backgroundImage: "",
				type: "default"
			};

		// Change the menu to the "user is signed in" one ONLY if there are links from the translation data file. 
		// Otherwise we keep it as "signedout" links.
		if (signedinListitems !== "") {
			$profileMenu.children("ul").html(signedinListitems);
		}

		// TESTING ONLY, force a custom image to use instead of default signed-in icon:
		//imageUrl = "//lorempixel.com/120/120/people/";
		
		// If we got an image from the profile image service, add it to the API call,
		// Else, we simply call the default "signed in" API to show the blue BG, white icon style.
		if (imageUrl !== "") {
			if (imageUrl.substring(0,2) === "//") {
				imageUrl = "https://" + imageUrl;
			}
			signedinData.type = "image";
			signedinData.backgroundImage = imageUrl;
		}

		// Show the profile link as "signed in" then adjust used space, toggle links and search field if needed.
		showProfileLinkSignedin(signedinData);
		setMastheadWidthUsed();
		toggleInlineLinks();
		toggleSearchField();

		// Add the user's profile image to the user object.
		IBM.common.util.user.subscribe("ready", "Masthead profile", function(){
				IBM.common.util.user.setInfo({"imageUrl": imageUrl});
				myEvents.publish("userProfileImageReady");
			}).runAsap(function(){
				IBM.common.util.user.setInfo({"imageUrl": imageUrl});
				myEvents.publish("userProfileImageReady");
			});
		
		myEvents.publish("profileMenuReady");
	}

	/**
		TODO: Add documentation ////////////////////
	**/
	function resetProfileButton () {
		mastheadLinklist.iconsonly.$el.removeClass("signedin hasinitials");
		$profileMenu.children("button").removeAttr("style aria-label").html("");
	}

	/**
		TODO: Add documentation ////////////////////
		Removes/resets these three states:
		1. Signed in.
		2. "hasinitials" (really just means "show the text").
		3. Remove inline styles (background image).
		4. Removes notification count (set to 0 removes it).
	**/
	me.showProfileLinkAnonymous = showProfileLinkAnonymous;
	function showProfileLinkAnonymous (dataObj) {
		resetProfileButton();
		showNotificationCount(0);
		$profileMenu.children("button").html(dataObj.linkContents).attr("aria-label", dataObj.linkAlt);
	}

	/**
		TODO: Add documentation ////////////////////
	**/
	me.showProfileLinkSignedin = showProfileLinkSignedin;
	function showProfileLinkSignedin (dataObj) {
		/**
			dataObj = {
				linkContents: "", // The text we'd show on the screen.
				linkAlt: "",  // The aria-label for blind user who can't see the visual meaning "you're signed in"
				backgroundImage: ""  // The image to use for the button.
				type: "default|text|image"  // What type of "signed-in" visual to display.
			};
		**/
		resetProfileButton();

		// Need *something* for proper styling.
		// if (!dataObj.linkContents || dataObj.linkContents === "") {
		// 	dataObj.linkContents = "";
		// }

		mastheadLinklist.iconsonly.$el.addClass("signedin");
		$profileMenu.children("button").html(dataObj.linkContents).attr("aria-label", dataObj.linkAlt);

		// If there was a background image URL passed, set the button to use it.
		// This overrides the default profile icon background.
		if (dataObj.type === "image" && dataObj.backgroundImage && dataObj.backgroundImage !== "") {
			mastheadLinklist.iconsonly.$el.addClass("hasinitials");
			
			$profileMenu.children("button").html(" ").css({
				"background-image": "url(" + dataObj.backgroundImage + ")",
				"background-size": "cover"
			});
		}

		if (dataObj.type === "text" && dataObj.linkContents !== "") {
			mastheadLinklist.iconsonly.$el.addClass("hasinitials");
		}
	}

	/**
		TODO: Add documentation ////////////////////
	**/
	me.showProfileLinkContents = showProfileLinkContents;
	function showProfileLinkContents () {
		mastheadLinklist.iconsonly.$el.addClass("hasinitials");
	}

	/**
		TODO: Add documentation ////////////////////
	**/
	function createMenuListItems (linkArr) {
		var lis = "";

		$.each(linkArr, function () {
			var linkType =  this.id && this.id !== "" ? ' data-linktype="' + this.id + '"' : '';
			if (this.title) {
				lis += '<li role="presentation"' + linkType + '><a role="menuitem" href="' + this.url.replace("{{window.location}}", window.location.href) + '">' + this.title + '</a></li>';
			}
		});

		return lis;
	}

	/**
		TODO: Add documentation ////////////////////
	**/
	me.editProfileMenu = editProfileMenu;
	function editProfileMenu (data) {
		if (data.action === "replace") {
			$("#ibm-signin-minimenu-container").html(createMenuListItems(data.links));
		}
		else if (data.action === "prepend") {
			$("#ibm-signin-minimenu-container").prepend(createMenuListItems(data.links));
		}
		else if (data.action === "append") {
			$("#ibm-signin-minimenu-container").append(createMenuListItems(data.links));
		}
		else if (data.action === "replaceLinkUrl") {
			$("#ibm-signin-minimenu-container li[data-linktype='" + data.linktype + "'] a").attr("href", data.linkurl);
		}
	}

	
	////////////////////////////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// 
	// END Profile icon and menu setup
	//
	////////////////////////////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////////////////////////////
	

	/**
		Simply inserts the universal nav links into the masthead.

		@method addUnavToMasthead
		@private
	**/ 
	function addUnavToMasthead () {
		// Replace the HTML coded UL#ibm-menu-links with our new UL, no ID used in new UL.
		mastheadLinklist.unav.$el = $(mastheadLinklist.unav.html).insertBefore("#ibm-menu-links").attr("aria-label", "Site toolbar");
		$("#ibm-menu-links").addClass("ibm-hide");
	}

	/**
		Adds the "animate" class to the logo container so that it animates.
		<br />Setup to animate once per session. Can force animation if special "?animatelogo" URL parm is used on page's URL.

		@method animateLogo
		@private
	**/ 
	function animateLogo () {
		var repeatVisitFlag = IBM.common.util.storage.getItem("v18larv");
		
		// Allow animation to be forced to show via URL param (for debugging, presentations, show-and-tell, etc).
		if (IBM.common.util.url.getParam("animatelogo")) {
			$("#ibm-home").addClass("ibm-animate");
		}

		if (!IBM.common.util.config.isEnabled("masthead.logoanimation")) {
			return;
		}

		// If they didn't have the flag AND they support localstorage, animate it.
		if (!repeatVisitFlag && IBM.common.util.storage.setItem("v18larv", true)) {
			$("#ibm-home").addClass("ibm-animate");
		}
	}

	/**
		Loops thru translation file link array and creates the masthead main category link list.

		@method createLinklistCatnav
		@private
		@return {String} The link list UL HTML to inject in the masthead if links exist.
	**/ 
	function createLinklistCatnav () {
		var html = "";

		// If there's catnav data, make links (LIs) and populate module's HTML var.
		if (mastheadData.catnav.links.length > 0) {
			$.each(mastheadData.catnav.links, function() {
				var mmContent = this.megamenuContent,
					addClass = mmContent && mmContent.col1 && mmContent.col1.heading !== "" ? '' : ' class="ibm-no-megamenu"' ;

				html += '<li role="presentation" ' + addClass + '><a role="button" href="' + this.url + '" data-sectionid="' + this.id + '">' + this.title.htmlspecialchars() + '</a></li>';
			});

			html = '<ul aria-label="' + IBMCore.common.translations.data.v18main.catnav.title + '" role="toolbar" class="ibm-masthead-categories">' + html + '</ul>';
		}

		return html;
	}

	/**
		Creates each of the individual icon links to use in the masthead.
		<br />Each icon can be disabled with a standard "config.set" utility option.

		@method createLinklistIconsonly
		@private
		@return {String} The link list UL HTML to inject in the masthead if links exist.
	**/ 
	function createLinklistIconsonly () {
		var html = "";

		// The search icon.
		// if (IBM.common.util.config.isEnabled("masthead.search")) {
		// 	html += '<li role="presentation" class="ibm-masthead-item-search"><a role="menuitem" class="ibm-masthead-search-link" href="http://www.ibm.com/Search/?lang=' + IBM.common.meta.page.pageInfo.ibm.lc + '&cc=' + IBM.common.meta.page.pageInfo.ibm.cc + '">' + ($("#q").attr("aria-label") || "Search") + '</a></li>';
		// }

		// The profile icon item/button/trigger
		if (IBM.common.util.config.isEnabled("masthead.profile") && v18Data.profileMenu.signedout.length > 0) {
			html += '<li role="presentation" class="ibm-masthead-item-signin"><button role="menuitem" class="ibm-masthead-signin-link">' + v18Data.profileMenu.signedout[0].title + '</button></li>';
		}

		// The hamburger menu icon, unless it was disabled for some dumb reason.
		if (IBM.common.util.config.isEnabled("masthead.mobilemenu")) {
			html += '<li role="presentation" class="ibm-masthead-item-menu"><button role="menuitem" class="ibm-masthead-menu-link" aria-label="' + IBM.common.translations.data.v18main.misc.sitenav + '"></button></li>';
		}

		if (html !== "") {
			html = '<ul aria-label="Tools" role="menubar" class="ibm-masthead-iconsonly">' + html + '</ul>';
		}

		return html;
	}

	/**
		Creates the universal nav link list.
		
		@method createLinklistUnav
		@private
		@return {String} The link list UL HTML to inject in the masthead if links exist.
	**/ 
	function createLinklistUnav () {
		var html = "";

		// If there's unav data, make links (LIs).
		if (mastheadData.unav.links.length > 0) {
			$.each(mastheadData.unav.links, function() {
				// Exclude items that don't have a URL.
				if (this.url) {
					html += '<li class="ibm-masthead-unav-link" role="presentation"><a role="button" href="' + this.url + '">' + this.title.htmlspecialchars() + '</a></li>';
				}
			});

			// The label gets cloned from the existing site map link label coded in the HTML, then we replace the entire UL for ease.
			html = '<ul aria-label="' + IBMCore.common.translations.data.v18main.unav.title + '" role="toolbar" class="ibm-masthead-unav">' + html + '</ul>';
		}
		
		return html;
	}

	/**
		Adds a class to the mashtead and concats all the pieces that create the "full" (default) masthead.
		
		@method createMastheadFull
		@private
	**/ 
	function createMastheadFull () {
		$masthead.addClass("ibm-mhtype-full");
		
		// NOTE: Unav MUST always be last b/c it is used as reference point and our new Unav removes that ID.
		addCategoriesToMasthead();
		addIconsToMasthead();
		addUnavToMasthead();
		$(".ibm-masthead-unav").css("width", 0);
	}

	/**
		Adds a class to the mashtead and concats all the pieces that create the "minimal" (alternate) masthead.
		<br />The nice name/config name is "alternate". Technically it's a "minimal" masthead.
		
		@method createMastheadMinimal
		@private
	**/ 
	function createMastheadMinimal () {
		$masthead.addClass("ibm-mhtype-minimal");
		
		// Unav MUST always be last b/c it is used as reference point and our new Unav removes that ID.
		addCategoriesToMasthead();
		addIconsToMasthead();
		addUnavToMasthead();
		$(".ibm-masthead-unav").css("width", 0);
	}

	/**
		This is deprecated. It's the same as "minimal/alternate" masthead. Will be removed soon.
		
		@method createMastheadMobile
		@private
		@deprecated
	**/ 
	function createMastheadMobile () {
		createMastheadMinimal();
		$masthead.removeClass("ibm-mhtype-minimal").addClass("ibm-mhtype-mobile");
	}

	/**
		Creates the popup mashthead.
		<br />This is really NO JS execution and the CSS class hides everything except the logo.
		
		@method createMastheadPopup
		@private
	**/ 
	function createMastheadPopup () {
		$masthead.addClass("ibm-mhtype-popup");
	}

	/**
		Creates the entire megamenu. Loops thru translation file and builds the 3 columns HTML.
		 Sets glob vars to be used later by megamenu injection function.
		
		@method createMegamenu
		@private
	**/ 
	function createMegamenu () {
		var megamenuSectionsHtml = "";

		function createMegamenuColumn1 (data) {
			var html = "",
				buttons = "";

			buttons = '<a class="ibm-btn-pri ibm-blue-50" href="' + data.link1.url + '">' + data.link1.title + '</a>';

			if (data.link2) {
				buttons += '<a class="ibm-btn-sec ibm-blue-50" href="' + data.link2.url + '">' + data.link2.title + '</a>';
			}

			html = '<h2 class="ibm-section-header">' + data.heading + '</h2><p>' + data.description + '</p><p class="ibm-button-link ibm-btn-row">' + buttons + '</p>';

			return html;
		}

		function createMegamenuColumn2 (data) {
			var html = "";

			html += '<h4>' + data.heading + '</h4><p class="ibm-mm-col-title">' + data.title + '</p><p>' + data.description + '</p>';

			html += '<p class="ibm-ind-link"><a class="ibm-forward-link" href="' + data.link1.url + '">' + data.link1.title + '</a></p>';

			if (data.link2) {
				html += '<p class="ibm-ind-link"><a class="ibm-forward-link" href="' + data.link2.url + '">' + data.link2.title + '</a></p>';
			}

			return html;
		}

		function createMegamenuColumn3 (data) {
			var html = "";

			html += '<h4>' + data.heading + '</h4><p><a href="' + data.linkUrl + '"><img class="ibm-resize" src="' + data.imageUrl + '" width="380" height="170" alt="" /><br />' + data.linkTitle + '</a></p>';

			return html;
		}


		// Loop thru each catnav object, if there's catnav data try and build megamenu section for each one.
		if (mastheadData.catnav.links) {
			$.each(mastheadData.catnav.links, function(i) {
				var catnavItem = this,
					catnavContent = catnavItem.megamenuContent,
					col1Html = "",
					col2Html = "",
					col3Html = "",
					categoryIdValue = "menu-section-" + i;

				if (catnavContent && catnavContent.col1 && catnavContent.col1.heading !== "") {
					// Standard formatting for medium and large screens: 6-2/2/2.
					// For XL screens: 4-2/1/1.
					col1Html = '<div class="ibm-megamenu-section-col1 ibm-col-xlarge-4-2 ibm-col-6-2">' + createMegamenuColumn1(catnavContent.col1) + '</div>';
					col2Html = '<div class="ibm-megamenu-section-col2 ibm-col-xlarge-4-1 ibm-col-6-2">' + createMegamenuColumn2(catnavContent.col2) + '</div>';
					col3Html = '<div class="ibm-megamenu-section-col3 ibm-col-xlarge-4-1 ibm-col-6-2">' + createMegamenuColumn3(catnavContent.col3) + '</div>';

					megamenuSectionsHtml += '<div role="dialog" aria-labelledby="' + categoryIdValue + '" class="ibm-megamenu-section" data-sectionid="' + catnavItem.id + '"><div id="' + categoryIdValue + '" class="ibm-columns">' + col1Html + col2Html + col3Html + '</div></div>';
				}
			});
		}

		// Echo the MM on the page (including the "close" button), then setup bindings/accessibility.
		megamenu.$el = $('<div id="ibm-megamenu-sections">' + megamenuSectionsHtml + '<div class="ibm-megamenu-close-container"><p class="ibm-icononly"><a class="ibm-chevron-up-link" href="#close">' + IBM.common.translations.data.v18main.misc.close +'</a></p></div></div>').insertAfter("#ibm-universal-nav");
		megamenu.$closeButtonLink = megamenu.$el.find(".ibm-megamenu-close-container a");
	}

	/**
		Defers running the function by calling it in a setTimeout so it gets pushed to the back of the current renderig queue.

		@method defer
		@private
	**/
	function defer(funct) {
		setTimeout(funct, 20);
	}

	/**
		Returns object with all of the built masthead link list HTML objects.
		
		@method getMastheadLinklists
		@return {Object} The object containing all of the masthead link lists HTML. Used by mobile menu widget.
	**/ 
	me.getMastheadLinklists = getMastheadLinklists;
	function getMastheadLinklists () {
		return mastheadLinklist;
	}

	/**
		Gets widths of logo and unav divs and sets glob "mastheadWidthUsed" var.
		"mastheadWidthUsed" is used to determine at what screen width to hide the inline categories links.
		
		@method setMastheadWidthUsed
	**/ 
	me.setMastheadWidthUsed = setMastheadWidthUsed;
	function setMastheadWidthUsed () {
		//var w = $("#ibm-unav-links-container").addClass("getWidth").children("#ibm-menu-links").width() + $("#ibm-home").width() + ($("#ibm-home").offset().left * 2); // "* 2" to be safe.;
		var w = 0;
		
		// Get the width of the three elements that they take up, including margins.
		// Items that are set as absolute position have to be specifically named to get the proper visual width.
		$("#ibm-universal-nav").addClass("getWidth").find("#ibm-home, .ibm-masthead-categories, #q, .ibm-masthead-iconsonly").each(function(){
			w += $(this).outerWidth(true);
		}).end().removeClass("getWidth");

		//w += $("#ibm-home").outerWidth(true);
		//w += $(".ibm-parent-site-name").outerWidth();

		// Store the width that is taken up by the links.
		// Add extra to account for spacings between elements that doesn't get counted in "width()".
		mastheadWidthUsed = w + 30;
	}

	/**
		Duh.
		
		@method hideMegamenu
	**/ 
	me.hideMegamenu = hideMegamenu;
	function hideMegamenu () {
		$("body").removeClass("ibm-masthead-megamenu-showing");
		megamenu.isopen = false;
		if (megamenu.$sectionShowing) {
			megamenu.$sectionShowing.removeClass("ibm-showing");
		}
		megamenu.$sectionShowing = null;
	}


	/**
		Sets up focus, tabstops, &amp; arrow controls for the main masthead links, toolbar (select a country/language section), and search field.
		<br />Called after main links have been injected, before megamenu has been created and injected.
		
		@method setupMastheadAccessibility
		@private
	**/
	function setupMastheadAccessibility () {
		IBM.common.util.a11y.makeMenuAccessible({
			el: $("#ibm-masthead .ibm-masthead-iconsonly")
		});
		IBM.common.util.a11y.makeToolbarAccessible({
			el: $("#ibm-masthead .ibm-masthead-categories")[0]
		});
	}

	/**
		TODO: Add documentation ////////////////////
	**/
	function setupMastheadIconBindings () {
		if (IBM.common.util.config.isEnabled("masthead.search")) {
			$(".ibm-masthead-iconsonly .ibm-masthead-item-search a").click(function (evt) {
				evt.preventDefault();
				
				// Close the mobilemenu if it's open.
				// TODO: How to say "Leave noscroll class on it."
				if (IBM.common.module.mobilemenu.isOpen()) {
					IBM.common.module.mobilemenu.hide();
				}

				IBM.common.module.mastheadsearch.show();
			});
		}
		
		if (IBM.common.util.config.isEnabled("masthead.mobilemenu")) {
			$(".ibm-masthead-iconsonly .ibm-masthead-item-menu button").click(function (evt) {
				evt.preventDefault();
				
				IBM.common.module.mobilemenu.toggle();
			});
		}
	}

	/**
		TODO: Add documentation ////////////////////
	**/
	function setupMastheadResponsiveness () {
		var didResize = false;

		// Run toggle functions on load and then check/run on resize.
		toggleInlineLinks();
		toggleSearchField();


		$(window).resize(function() {
			didResize = true;
		});

		setInterval(function() {
			if (didResize) {
				didResize = false;
				toggleInlineLinks();
				toggleSearchField();
			}
		}, 100);
	}

	/**
		TODO: Add documentation ////////////////////
	**/
	function setupSearchfieldResponsiveness () {
		var didResize = false;

		// Run toggle functions on load and then check/run on resize.
		toggleSearchField();

		$(window).resize(function() {
			didResize = true;
		});

		setInterval(function() {
			if (didResize) {
				didResize = false;
				toggleSearchField();
			}
		}, 100);
	}

	/**
		TODO: Add documentation ////////////////////
	**/
	function setupMegamenuBindings () {
		var mouseOutTimeout,
			mouseoverTimeout,
			menulinkTimeout;

		// OPENING THE MEGAMENU ONLY:
		// Onclick of a catnav link: 
		//   If the MM is already open, goto the link.
		//   If it's not open, open that section.
		// On hover:
		//   If it's not already open, slight pause to make sure they aren't doing a mouse flyby.
		//   If it's already open slight pause then show the new section b/c they are already interacting, so make it less delay.
		mastheadLinklist.catnav.$el.find("a").click(function(evt) {
			if (megamenu.isopen && $("html").hasClass("no-touch")) {
				return;
			}

			evt.preventDefault();

			showMegamenuSection($(this).data("sectionid"));
			showMegamenu();
		}).mouseenter(function() {
			var thisSectionId = $(this).data("sectionid");

			if (!megamenu.isopen) {
				mouseoverTimeout = setTimeout(function() {
					showMegamenuSection(thisSectionId);
					showMegamenu();
				}, 250);
			}
			else {
				clearTimeout(menulinkTimeout);
				
				menulinkTimeout = setTimeout(function() {
					menulinkTimeout = showMegamenuSection(thisSectionId);
				}, 175);
			}
		}).keydown(function(evt) {
			// If they used the keyboard and hit enter, fire click then focus on section's first link.
			if (evt.keyCode === 13) {
				
				evt.preventDefault();

				$(this).click();

				megamenu.$sectionShowing.find("a:first").focus();
			}
		});

		// CLOSING THE MEGAMENU ONLY:
		// Setup mouseout to close the menu after a small waiting period, to make sure they just move the mouse out and back in.
		// If they mouse back in within the timeframe, cancel the megamenu closing.
		// Hover is jq multi-event (mousein, mouseout)
		mastheadLinklist.catnav.$el.add(megamenu.$el).hover(function() {
			clearTimeout(mouseOutTimeout);

		}, function() {
			clearTimeout(mouseoverTimeout);
			
			mouseOutTimeout = setTimeout(function() {
				hideMegamenu();
			}, 400);

		});

		// The close icon at the bottom.
		megamenu.$closeButtonLink.click(function (evt) {
			evt.preventDefault();
			
			hideMegamenu();
			
			mastheadLinklist.catnav.$el.find("a[tabindex='0']").focus();
		});

		// KEYBOARD TABBING RULES.
		// If they hit escape, close the MM.
		// If they tab from either end link, loop back around.
		// Use .on for delegation so we only bind 1 main parent DOM element instead of wasting binding every link. Hello speed.
		megamenu.$el.on("keydown", function(evt) {
			// If they try and tab FORWARD and they were on the last link in the visible MM section, goto close link. 
			// If they tab forward from close link, goto first link.
			// Do all opposites.
			// If they hit ESCAPE, close MM and return to orig Cat.nav link they clicked.
			
			// If they try and tab FORWARD and they were on the last link in the visible MM section, goto close link. 
			// If they tab forward from close link, goto first link.

			var $gotoLink = "";

			if (evt.keyCode === 9 && !evt.shiftKey) {
				if ($(evt.target).is(megamenu.$sectionShowing.find("a:last"))) {
					$gotoLink = megamenu.$closeButtonLink;
				}
				else if ($(evt.target).is(megamenu.$closeButtonLink)) {
					$gotoLink = megamenu.$sectionShowing.find("a:first");
				}
			}
			else if (evt.keyCode === 9 && evt.shiftKey) {
				if ($(evt.target).is(megamenu.$sectionShowing.find("a:first"))) {
					$gotoLink = megamenu.$closeButtonLink;
				}
				else if ($(evt.target).is(megamenu.$closeButtonLink)) {
					$gotoLink = megamenu.$sectionShowing.find("a:last");
				}
			}
			else if (evt.keyCode === 27) {
				hideMegamenu();
				mastheadLinklist.catnav.$el.find("a[tabindex='0']").focus();
			}

			// If we set a link to goto, stop the default tab action and goto our custom link EL.
			if ($gotoLink !== "") {
				evt.preventDefault();
				$gotoLink.focus();
			}
		});
	}

	/**
		Add documentation ////////////////////
	**/
	function setupMastheadProfileMenu () {
		var mouseOutTimeout,
			mouseoverTimeout,
			closeAnywhereSetup = false;

		// Opening/Closing the minimenu on click:
		$profileMenu.children("button").click(function(evt) {
			evt.preventDefault();

			if ($profileMenu.hasClass("ibm-active")) {
				me.hideProfileMenu();
			}
			else {
				me.showProfileMenu();

				// Since they clicked to open it, setup the "click anywhere" to close it.
				if (!closeAnywhereSetup) {
					setupClickAnywhereClose();
					closeAnywhereSetup = true;
				}
			}
		});

		$profileMenu.mouseenter(function() {
				mouseoverTimeout = setTimeout(function() {
					me.showProfileMenu();
				}, 250);
			}).hover(function() {
					clearTimeout(mouseOutTimeout);
				}, function() {
					clearTimeout(mouseoverTimeout);
					
					mouseOutTimeout = setTimeout(function() {
						me.hideProfileMenu();
					}, 400);
			}).on("click", function (evt) {
				evt.stopPropagation();  // Stop propogation so our body "closer" binding doesn't fire if they click on the menu.
			});

		// TODO: Santelia: TEMP sign in instead of going to the link, for now until IBMID makes new service.
		// US ONLY TEMP solution.
		// if (IBM.common.meta.page.pageInfo.ibm.cc === "us") {
		// 	$(".ibm-signin-ibmid-item").on("click", function (evt) {
		// 		evt.preventDefault();

		// 		IBMCore.common.util.cookie.set("PD-REFPAGE", window.location.href, {domain:".ibm.com",path:"/"});
		// 		IBMCore.common.util.cookie.set("PD-SGNPAGE", window.location.href, {domain:".ibm.com",path:"/"});

		// 		window.location.href = "https://www-947.ibm.com/usrsrvc/account/userservices/jsp/login.jsp?persistPage=true&page=" + encodeURI(window.location.href);
		// 	});
		// }

		// Accessibility for the mini menu,
		// $container.on("keydown", function(evt) {
		// 	// If they tab out or escape of the popup menu, hide the menu (they tabbed to the next element).
		// 	if (evt.keyCode === 9 || evt.keyCode === 27) {
		// 		$container.removeClass("ibm-showing");
		// 		$signinLink.parent().removeClass("ibm-showing");
				
		// 		// If it was escape, go back to trigger link focus.
		// 		if (evt.keyCode === 27) {
		// 			$signinLink.focus();
		// 		}
		// 	}
		// });

		// Setup standard keyboard arrow control accessibility.
		// Uses tabs style b/c there's a selected item and the selected item (active) should never change tabindex.
		// IBM.common.util.a11y.makeTabsAccessible({
		// 	el: $("ul", $container)
		// });
	}

	// Only setup if user clicks on the menu to open it becuase otherwise we don't need this setup.
	function setupClickAnywhereClose () {
		$("body").on("click", function () {
			me.hideProfileMenu();
		});
	}

	me.showProfileMenu = function () {
		$profileMenu.addClass("ibm-active");
	};


	me.hideProfileMenu = function () {
		$profileMenu.removeClass("ibm-active");
	};




	/**
		Add documentation ////////////////////
	**/
	me.showMegamenu = showMegamenu;
	function showMegamenu() {
		$("body").addClass("ibm-masthead-megamenu-showing");
		megamenu.isopen = true;
	}

	/**
		Add documentation ////////////////////
	**/
	me.showMegamenuSection = showMegamenuSection;
	function showMegamenuSection(sectionId) {
		if (megamenu.$sectionShowing) {
			megamenu.$sectionShowing.removeClass("ibm-showing");
		}

		megamenu.$sectionShowing = $(".ibm-megamenu-section[data-sectionid='" + sectionId + "']").addClass("ibm-showing");

		//$("body").addClass("ibm-masthead-megamenu-showing");
		//megamenu.$el.slideDown(150, function () {
			//megamenu.isopen = true;
		//});
	}

	
	/**
		TODO: Add documentation ////////////////////
	**/
	me.showMobileMasthead = showMobileMasthead;
	function showMobileMasthead (b) {
		if (b) {
			showingMobileMasthead = true;
			$("body").addClass("ibm-masthead-mobile-show");
		}
		else {
			showingMobileMasthead = false;
			$("body").removeClass("ibm-masthead-mobile-show");
		}
	}

	/**
		TODO: Add documentation ////////////////////
	**/
	function toggleInlineLinks () {
		if (mastheadType === "mobile") {
			return;
		}

		// If the viewport is wide enough to show the logo + masthead menu links show them,
		// Else, show the mobile menu trigger links.
		// Include var check so we don't unnecessarily add/remove a class when we don't have to.
		// Add small space buffer to help avoid collision + timing.
		if (showingMobileMasthead && mastheadWidthUsed + 30 < $(window).width()) {
			me.showMobileMasthead(false);
		}
		else if (!showingMobileMasthead && mastheadWidthUsed + 30 > $(window).width()) {
			me.showMobileMasthead(true);
		}
	}

	/**
		TODO: Add documentation ////////////////////
	**/
	function toggleSearchField () {
		if (IBM.common.module.mastheadsearch.getDisplayState() === "maximized") {
			return;
		}

		if ($(window).width() < 580) {
			IBM.common.module.mastheadsearch.showAs("minimized");
		}
		else {
			IBM.common.module.mastheadsearch.showAs("default");
		}
	}
	

	/**
		TODO: Add documentation ////////////////////
	**/
	me.getMastheadData = function () {
		return mastheadData;
	};



	/* Wait for events to happen.
	 **********************************************************************************************/

	// When translations are ready, call autoInit to build it. Translations can be cached, so use runAsap also.
	IBM.common.translations.subscribe('dataReady', 'Masthead', me.autoInit).runAsap(me.autoInit);


	// Subscribe to meta,
	// if the masthead profiling is setup, means our userState request will be made,
	// subscribe to user state request,
	// if the user is signed in, request photo
	// and then if notifications are enabled, request the notifications,
	// Then remove subscription because this gets evaluated every time meta.init runs.
	IBM.common.meta.subscribe("dataReady", "userstaterequest", function () {
		if (IBM.common.util.config.isEnabled("masthead.profile")) {
			IBM.common.util.user.subscribe("userstateReady", "masthead", function () {
				if (IBM.common.util.user.isSignedin()) {
					requestPhoto();
					
					if (IBM.common.util.config.isEnabled("masthead.notifications")) {
						requestNotifications();
					}
				}
				IBM.common.util.user.unsubscribe("userstateReady", "masthead");
			});
		}
	});


	// Dynamically add a CSS block to shift the right icons over # of PX that scrollbars took up when we hide them.
	me.subscribe("ready", "dyncss", function () {
		IBM.common.util.addCssRule("#ibm-com.ibm-no-scroll #ibm-universal-nav .ibm-masthead-iconsonly", {
			"margin-right": parseInt($("#ibm-universal-nav .ibm-masthead-iconsonly").css("margin-right"), 10) + IBM.common.util.getScrollbarWidth() + "px"
		});
	});

})(jQuery, IBMCore);
;

// TODO: Santelia: Add full documentation for this after we nail down the final design and interaction.

// This is the JS that specifically does the functionality that makes the masthead sticky on scroll up.
(function($, IBM) {
	var me = IBM.namespace(IBM, "common.module.masthead.sticky"),
		classes = {
			sticky: "ibm-masthead-sticky",
			stickyShowing: "ibm-masthead-sticky-showing",
			enableTransition: "hastransition"
		},
		currentScrollTop = 0,
		delta = 120,
		didScroll = false,
		lastScrollTop = 0,
		lastDirection = "",
		$masthead = {},
		$body = {},
		$mhPlaceholder = $('<div class="ibm-hide" style="width: 1px;"></div>');
	

	/**
		Callback from subscription to meta data 'ready' event publisher. Checks if masthead is enabled (default). 
		<br />If so, subscribe to masthead and then init sticky feature if enabled.
		<br />Two separate checks so that a masthead type can override and disable/enable it (masthead.js).

		@method autoInit
	**/
	me.autoInit = function() {
		if (IBM.common.util.config.isEnabled("masthead")) {
			IBM.common.module.masthead.subscribe("ready", "mastheadsticky", function () {
				if (IBM.common.util.config.isEnabled("masthead.sticky")) {
					setTimeout(me.init, 20);
				}
			});
		}
	};

	me.init = function () {
		$body = $("body");
		$masthead = $("#ibm-masthead");
		
		setupStickyFunction();
		
		$mhPlaceholder.insertAfter("#ibm-masthead").css({
			"height": $("#ibm-masthead").height() + "px"
		});
	};

	function makeStickyHidden () {
		//$masthead.addClass("sticky").removeClass("snapback showing");
		$body.addClass(classes.sticky).removeClass(classes.stickyShowing);

		showPlaceholder(true);
		
		// Wait to add transition. This is so we can make it stick hidden w/o the transition, but then once
		// it's sticky it has transition.
		setTimeout(function(){
			$masthead.addClass(classes.enableTransition);
		}, 200);
	}

	function makeStickyShowing () {
		//$masthead.removeClass("snapback").addClass("hastransition sticky showing");
		$masthead.addClass(classes.enableTransition);
		$body.addClass(classes.sticky + " " + classes.stickyShowing);

		showPlaceholder(true);
	}

	function setupStickyFunction () {
		// STOP if there's a sitenav b/c the sitenav is sticky, so this isn't.
		// if ($(".ibm-sitenav-menu-container").length === 1) {
		// 	return;
		// }

		$(window).scroll(function() {
			didScroll = true;
		});

		setInterval(function() {
			if (didScroll) {
				didScroll = false;
				toggleMasthead();
			}
			else if (lastDirection === "down") {
				lastScrollTop = $(this).scrollTop();
			}
		}, 100);
	}

	function toggleMasthead () {
		currentScrollTop = $(this).scrollTop();

		// When we get to the top, snap the masthead back in place. No transition.
		if (currentScrollTop === 0) {
			//$masthead.addClass("snapback").removeClass("hastransition sticky showing");
			$masthead.removeClass(classes.enableTransition);
			$body.removeClass(classes.sticky + " " + classes.stickyShowing);
			showPlaceholder(false);
		} 
		else if (Math.abs(lastScrollTop - currentScrollTop) >= delta) {
			// When scrolling down.
			// Slide the masthead up, put position back, hide placeholder.
			if (currentScrollTop > lastScrollTop) {
				if (lastDirection !== "down") {
					lastDirection = "down";
					
					makeStickyHidden();
				}
			} 
			// When scrolling up, reveal a fixed masthead.
			else {
				if (lastDirection !== "up") {
					lastDirection = "up";
					
					makeStickyShowing();
				}
			}

			lastScrollTop = currentScrollTop;
		}
	}

	function showPlaceholder (b) {
		$mhPlaceholder[b ? "removeClass" : "addClass"]("ibm-hide");
	}


	/* Wait for events to happen.
	**********************************************************************************************/

	// When meta data is ready (config), call auto init.
	IBM.common.meta.subscribe("dataReady", "mastheadsticky", me.autoInit).runAsap(me.autoInit);

})(jQuery, IBMCore);
;

/**

	Masthead search module
	<br />
	<br />This is the search field in the masthead, the mobile masthead overtake search, and the extra typeahead feature.
	<br />This waits for masthead to be ready and then binds the masthead search item and creates everything beyond it.

	@class IBMCore.common.module.mastheadsearch

**/


// TODO: Santelia: Marinade on splitting off typeahead to it's own JS/module. Or would that be too complicated?
//  Right now, the search technically really only does the mobile masthead takeover stuff and tab rings. 
//  We'd probably need to add some events to the show/hiding of the mobile search field b/c the typeahead show/hide is tied to it.

(function($, IBM) {
	/**
		Publishes this event after search function is built.

		@event ready
	**/
	var me = IBM.namespace(IBM, "common.module.mastheadsearch"),
		myEvents = IBM.common.util.eventCoordinator(me, "Mastheadsearch", [
			"ready",
			"typeaheadReady"
		]),
		$inputField = {},
		$searchButton = {},
		$searchCloseButton = {},
		$typeaheadUl = {},
		$typeaheadContainer = {},
		latestText = "",
		//didScroll = false,
		displayState = "default",
		requestCount = 0,
		defaultTypeaheadRequestPause = 50,  // # of MS to wait between typing before making a WSR.
		typeaheadResultsShowing = false;


	/**
		Callback from subscription to meta data 'ready' event publisher. 
		<br />If masthead and search are enabled (default), subscribe to masthead then init masthead 
		search (currently just does the mobile takeover parts).
		<br />If masthead search typeahead is enabled (default), subscribe to search then init typeahead feature.
		
		@method autoInit
	**/
	me.autoInit = function() {
		// masthead needs to be enabled for masthead.search to be enabled.
		// masthead.search needs to be enabled for masthead.search.typeahead to be enabled.
		// We only allow search to be hidden when masthead is ENABLED. We don't hide it if masthead is disabled.
		// If they want a minimal masthead (logo only): enable "alternate" masthead and disable search, profile, mobilemenu via config.set.
		if (IBM.common.util.config.isEnabled("masthead")) {
			if (IBM.common.util.config.isEnabled("masthead.search")) {
				IBM.common.module.masthead.subscribe("ready", "mastheadsearch", function () {
					setTimeout(me.init, 20);
				});

				// Masthead AND search are enabled, so check if typeahead is enabled and set it up after search is setup
				if (IBM.common.util.config.isEnabled("masthead.search.typeahead")) {
					me.subscribe("ready", "mastheadsearchtypeahead", function () {
						me.initTypeahead();
					});
				}
			}
			else {
				$("#ibm-search-module").addClass("ibm-hide");
			}
		}
	};

	/**
		Callback from subscription to masthead 'ready' event publisher, inside autoInit. 
		<br />Moves the search field into an overlay and binds the icon to open it and do all associated functions.

		@method init
	**/
	// This was auto-init'd inside a timeout, no need to do it again.
	me.init = function() {
		// Cache some selectors.
		$inputField = $("#q");
		$searchButton = $("#ibm-search");
		
		// Close button for the search overtake in MOBILE masthead.
		// Onclick, hide the typeahead container and set search back to minimized/trigger version.
		$searchCloseButton = $('<div class="ibm-masthead-search-close"><p class="ibm-ind-link ibm-icononly ibm-padding-bottom-0"><a href="#" class="ibm-close-link ibm-nospacing">' + IBMCore.common.translations.data.v18main.misc.close + '</a></p></div>').insertBefore("#ibm-search-form").on("click", function (evt) {
			evt.preventDefault();
			showAs("minimized");
			showTypeaheadResults(false);
			$(".ibm-masthead-iconsonly :focusable:first").focus();
		}).find("a");

		// Setup the search field. Really just the mobile version that takes over the masthead.
		setupSearchField();

		myEvents.publish("ready");
	};

	// This was auto-init'd form subscription to mastheadsearch (us).
	me.initTypeahead = function () {
		$inputField = $("#q");
		$searchButton = $("#ibm-search");
		
		//var closeTimer;

		// Remove for dynamic meta locale change.
		$(".ibm-search-typeahead-container").remove();

		// Needs ID for a11y tagging, but DO NOT USE IT for styling. Use class name only.
		$("#ibm-search-module").after('<div id="ibm-search-typeahead-container" class="ibm-search-typeahead-container"></div>');

		$typeaheadContainer = $(".ibm-search-typeahead-container");
		$typeaheadUl = $('<ul class="ibm-plain-list ibm-padding-bottom-0" role="listbox" aria-live="polite" aria-label="' + (IBMCore.common.translations.data.v18main.misc.resultsNav || "Suggestions") + '"></ul>');

		// Change input field to add proper a11y tagging since it's now an autocomplete setup.
		$inputField.attr({
			"role": "combobox",
			"aria-autocomplete": "list",
			"aria-expanded": "true",
			"aria-owns": "ibm-search-typeahead-container"
		});

		// @aria-activedescendant="id-of-selected-option" is added to input field dynamically on arrow 
		//  key press which is the key to being able to keep the focus on the input field and why we don't 
		//  need to change focus to the result list. 
		// It tells ATs that $thisID is the one currently highlighted and it will read that ID's 
		//  text as if it had focus. 

		// Bind the results so when you click on one, it replaces the input text with it.
		$typeaheadUl.on("focusin", function () {
				//clearTimeout(closeTimer);
			}).on("click", function (evt) {
				//clearTimeout(closeTimer);
				//console.log($(evt.target));
				if ($(evt.target).closest(".typeahead-nooption")[0]) {
					return;
				}

				evt.preventDefault();
				evt.stopPropagation();
				setTypeaheadItemActive($(evt.target));
				setInputFieldValue();
				$("#ibm-search-form").submit();
			}).on("mouseover", function (evt) {
				var $hoverItem = $(evt.target);

				if ($hoverItem[0].nodeName.toLowerCase() !== "li") {
					$hoverItem = $hoverItem.parent();
				}

				// If element is not a valid option, don't set it to active.
				if ($hoverItem.hasClass("typeahead-nooption")) {
					return;
				}

				$("li", $typeaheadUl).removeClass("ibm-active");
				$hoverItem.addClass("ibm-active");
			});

		// NO inline code in here. This should only be logic and call functions.
		// "input" event covers pasting and fires on keyup
		$inputField.on("input", function () {
				requestTypeaheadText();
				showInlinelinks(false);
			}).on("focus", function () {
				// If there is a value in the field, show the results on FIELD focus only.
				if ($inputField.val() !== "") {
					showInlinelinks(false);
					showTypeaheadResults(true);
				}
			}).on("keydown", function (evt) {
				// HAVE to use keycode for xbrowser support.
				var keyCode = evt.keyCode;

				// LEFT/RIGHT/TAB
				// Let natural behavior happen if: left/right arrow or tab.
				if (keyCode === 37 || keyCode === 39) {
					return;
				}

				if (evt.keyCode === 9 && evt.shiftKey) {
					if (getDisplayState() !== "maximized") {
						showTypeaheadResults(false);
						showInlinelinks(true);
					}
				}

				// UP/DOWN: 
				// If not showing, request current value typeahead
				// else goto next if it's already showing.
				// UP
				if (keyCode === 38) {
					evt.preventDefault();

					if (!typeaheadResultsShowing) {
						requestTypeaheadText();
					}				
					else {
						gotoPrevTypeaheadResult();
						setInputFieldValue();
					}
					return;
				}
				// DOWN
				else if (keyCode === 40) {
					evt.preventDefault();
					
					if (!typeaheadResultsShowing) {
						requestTypeaheadText();
					}
					else {
						gotoNextTypeaheadResult();
						setInputFieldValue();
					}
					return;
				}
			});

		// $("#ibm-search-module").on("focusout", function () {
		// 		closeTimer = setTimeout(function () {
		// 			showTypeaheadResults(false);
					
		// 			showInlinelinks(true);

		// 		}, 300);

		// 	}).on("focusin", function () {
		// 		clearTimeout(closeTimer);
		// 		if (getDisplayState() === "minimized") {
		// 			showAs("maximized");
		// 		}

		// 		showInlinelinks(false);
		// 	});

		// On normal window scroll, hide the TA results.
		// $(window).on("scroll", function () {
		// 	showTypeaheadResults(false);
		// 	showInlinelinks(true);
		// });
		setupCloseOnscroll();

		$("body").on("click", function (evt) {
			if (getDisplayState() === "maximized") {
				return;
			}

			if (!$(evt.target).closest(".ibm-masthead-rightside")[0]) {
				showTypeaheadResults(false);
				showInlinelinks(true);
			}
		});

		// Create a tab ring when the masthead takeover/mini-overlay exists. Forces everyone to use close button.
		// If not on special small screen tab ring, then close the typeahead on forward tab out of search submit.
		$searchButton.on("keydown", function (evt) {
			if (evt.keyCode === 9 && !evt.shiftKey) {
				if (getDisplayState() === "maximized") {
					//evt.preventDefault();
					//$searchCloseButton.focus();
				}
				else {
					showTypeaheadResults(false);
					//showInlinelinks(true);
				}
			}
		});

		// Create a tab ring when the masthead takeover/mini-overlay exists. Forces everyone to use close button.
		// $searchCloseButton.on("keydown", function (evt) {
		// 	if (evt.keyCode === 9 && evt.shiftKey) {
		// 		evt.preventDefault();
		// 		$searchButton.focus();
		// 	}
		// });

		myEvents.publish("typeaheadReady");
	};

	me.clearTypeahead = clearTypeahead;
	function clearTypeahead () {
		if ($typeaheadUl.length > 0) {
			$typeaheadUl.empty();
		}
	}

	me.createTypeahead = createTypeahead;
	function createTypeahead (searchString, results) {
		var items = results,
			lis = "",
			maxNum = 6,
			searchedFor = searchString;

		items.sort();

		// Update this to better include min/max #s with 'for'.
		$.each(items, function (i, v) {
			var term = v,
				reg = new RegExp(searchedFor, 'i');
			
			term = term.replace(reg, '<strong>' + searchedFor + '</strong>');
			
			if (i < maxNum) {
				lis += '<li id="ibm-search-overlay-typeahead-res-' + i + '" role="option" tabindex="-1">' + term + '</li>';
			}
		});

		// if (lis === "") {
		// 	lis = '<li class="typeahead-nooption">No results found</li>';
		// }

		// ONLY show recommended searches for US for now until we decide their fate.
		// If we keep these, they need to be added to sitenav template and pulled from data file.
		// If there's no results, then there's no need for a rule to separate these.

		// Santelia: Mar 16, 2016: Killig these b/c this was just a demo and there is no service for this.
		// if (IBM.common.meta.page.pageInfo.ibm.cc === "us") {
		// 	lis += '<li class="typeahead-nooption typeahead-section-title">' +
		// 			(items.length > 0 ? '<div class="ibm-rule"><hr /></div>' : '') + 
		// 			'<strong>Recommended searches</strong></li><li id="ibm-search-overlay-typeahead-recs-1" role="option">Commerce</li><li id="ibm-search-overlay-typeahead-recs-2" role="option">SPSS</li><li id="ibm-search-overlay-typeahead-recs-3" role="option">Careers</li>';
		// }

		// If they emptied the field after this WSR ran, clear the typeaheads.
		if ($inputField.val() === "") {
			//console.log("It's empty");
			clearTypeahead();
			showTypeaheadResults(false);
		}
		else {
			// Inject typeahead list on first time we have results.
			if (!$typeaheadContainer.find("ul")[0]) {
				$typeaheadContainer.html($typeaheadUl);
			}

			$typeaheadUl.html(lis);

			showTypeaheadResults(true);
		}
	}

	me.getDisplayState = getDisplayState;
	function getDisplayState () {
		return displayState;
	}

	me.makeTypeaheadRequest = (function () {
		var timer = 0;
		return function (callback, ms) {
			var waitTime = ms || defaultTypeaheadRequestPause;
			clearTimeout(timer);
			timer = setTimeout(callback, waitTime);
		};
	})();

	function gotoNextTypeaheadResult () {
		var $nextItem = $("li.ibm-active", $typeaheadUl).next("li");
		
		$("li.ibm-active", $typeaheadUl).removeClass("ibm-active");
			
		if ($nextItem[0]) {
			$nextItem.addClass("ibm-active");
		}
		else {
			$("li:first", $typeaheadUl).addClass("ibm-active");
		}

		// If this item if the section heading, skip it and goto the next one.
		if ($("li.ibm-active", $typeaheadUl).hasClass("typeahead-nooption")) {
			gotoNextTypeaheadResult();
		}
	}

	function gotoPrevTypeaheadResult () {
		var $prevItem = $("li.ibm-active", $typeaheadUl).prev("li");
		
		$("li.ibm-active", $typeaheadUl).removeClass("ibm-active");
			
		if ($prevItem[0]) {
			$prevItem.addClass("ibm-active");
		}
		else {
			$("li:last", $typeaheadUl).addClass("ibm-active");
		}

		// If this item if the section heading, skip it and goto the next one.
		if ($("li.ibm-active", $typeaheadUl).hasClass("typeahead-nooption")) {
			gotoPrevTypeaheadResult();
		}
	}

	function requestTypeaheadText (forceRequest) {
		var currentSearchTerm = $inputField[0].value;
		
		// If the current text is the same as the latest one we set (meaning the text hasn't changed on the keyup),
		//  then stop and don't do another WSR (b/c the text hasn't changed).
		if (currentSearchTerm === latestText && !forceRequest) {
			return;
		}
		
		latestText = currentSearchTerm;
		
		// If they cleared the search field (there's no value in the text field), remove the typeahead box and stop.
		if (currentSearchTerm === "") {
			me.makeTypeaheadRequest(function () {
				clearTypeahead();
				showTypeaheadResults(false);
			}, defaultTypeaheadRequestPause+10);

			return;
		}

		// Call the make request function (handles cancelling previous calls before timeout runs),
		// On callback (when timeout runs), we process the response accordingly:
		// Make the request, tagging it with a # (incremented). 
		// When the callback fires, we store the data no matter what for faster repeat search terms,
		// BUT only update the typeahead box if *this* request is the most recent one.

		// If:
		//   1. The scoped search box is checked (indicating the user wants to scope the search)
		//   + 
		//   2. The page has indicated that they have a custom function to call for typeahead.
		//  === We call their custom function instead of our default masthead typeahead one.
		if ($("#ibm-search-form .ibm-search-scope :checkbox").prop("checked") && me.customTypeaheadFunction) {
			me.customTypeaheadFunction(currentSearchTerm);
			return;
		}
		
		me.makeTypeaheadRequest(function () {
			$.ajax({
				url: "https://www.ibm.com/search/autocomplete?q=" + currentSearchTerm + "&limit=5",
				dataType: "jsonp",
				searchString: currentSearchTerm,
				requestCount: ++requestCount,
				success: function(response) {
					// If this request isn't the latest one (fast typers), don't update the TA box with it's results.
					if (requestCount !== this.requestCount) {
						return;
					}
					
					// Format the response terms into a clean plain array of string terms.
					var termsArr = [];
					
					$.each(response[1], function () {
						termsArr.push(this[0]);
					});

					me.createTypeahead(this.searchString, termsArr);
				},
				error: function(response) {
					console.error("Error calling typeahead service: ", response);
				}
			});
		});
	}

	function setInputFieldValue () {
		// Set active dedcendent attr. on field to tell ATs this one is active so they read it since we don't
		//  focus on it, then change the text in the text field.
		$inputField.attr("aria-activedescendant", $("li.ibm-active", $typeaheadUl).attr("id"));

		$inputField.val($("li.ibm-active", $typeaheadUl).text());
	}

	function setTypeaheadItemActive ($el) {
		if ($el[0].nodeName.toLowerCase() !== "li") {
			$el = $el.parent();
		}

		// Stop and don't highlight it if it's the heading.
		if ($el.hasClass("typeahead-nooption")) {
			return;
		}

		$("li.ibm-active", $typeaheadUl).removeClass("ibm-active");
		
		$el.addClass("ibm-active");
		
		$inputField.focus();
	}

	/**
		Add documentation ////////////////////
	**/
	function setupSearchField () {
		var $localSearchForm = $("#ibm-search-module form:not('#ibm-search-form')");

		$inputField.attr("autocomplete", "off");

		// Tag the form if it has a scope checkbox so we can style it differently.
		if ($("#ibm-search-module .ibm-search-scope")[0]) {
			$("#ibm-search-module").addClass("ibm-has-scope");
		}

		// Bind the search submit.
		$("#ibm-search-form").submit(function (evt) {
			var $thisForm = $(this);

			// Prevent the search from submitting if it's empty.
			if ($inputField.val() === "") {
				evt.preventDefault();
				return;
			}

			// If we haven't fired and event yet, fire a metric event for this search term, then re-submit.
			// Else we've already fired an event for this term, so submit the search.
			if (!$thisForm.data("smfired")) {
				IBM.common.util.statshelper.fireEvent({
					ibmEV : "masthead search",
					ibmEvAction : $inputField.val()
				});

				$thisForm.data("smfired", true);
				
				evt.preventDefault();

				setTimeout(function(){
					$thisForm.submit();
				}, 150);

			}
			else {
				// Reset the metric flag and submit custom form if it exsts, else let default submit go thru.
				$thisForm.data("smfired", false);
				
				// If they have a custom form and the box is checked: submit their custom form.
				if ($("#ibm-search-form .ibm-search-scope :checkbox").prop("checked") && $localSearchForm[0]) {
					evt.preventDefault();
					$localSearchForm.find("input:text").val($inputField.val());
					$localSearchForm.submit();
				}
			}
		});

		//// Mobile search masthead takeover.

		// On focus of the search field (when minimized), take over the masthead and show the search container.
		$inputField.on("focus", function () {
			// If the search field is minimized, show it on focus.
			if (getDisplayState() === "minimized") {
				showAs("maximized");
			}
		});

		// Create a tab ring on mobile masthead takeover. Forces everyone to use close button.
		// If not on special small screen tab ring, then close the typeahead on forward tab out of search submit.
		$searchButton.on("keydown", function (evt) {
			// If they are on the search submit and hit tab (forward), loop back to close button if showing
			// Else, 
			if (evt.keyCode === 9 && !evt.shiftKey) {
				if (getDisplayState() === "maximized") {
					evt.preventDefault();
					$searchCloseButton.focus();
				}
				else {
					//showTypeaheadResults(false);
					showInlinelinks(true);
				}
			}
		});

		// Create a tab ring when the masthead takeover/mini-overlay exists. Forces everyone to use close button.
		$searchCloseButton.on("keydown", function (evt) {
			if (evt.keyCode === 9 && evt.shiftKey) {
				evt.preventDefault();
				$searchButton.focus();
			}
		});

		$("#ibm-search-form .ibm-search-scope :checkbox").on("change ifChanged", function() {
			requestTypeaheadText(true);
		});

	}

	/**
		TODO: Add documentation ////////////////////
	**/
	function setupCloseOnscroll () {
		var didScroll = false;

		$(window).on("scroll", function () {
			didScroll = true;
		});

		setInterval(function() {
			if (didScroll) {
				didScroll = false;
				
				if (!$(".ibm-masthead-search-maximized")[0]) {
					showTypeaheadResults(false);
					showInlinelinks(true);
				}
			}
		}, 100);
	}

	function showInlinelinks (b) {
		if (b) {
			if (getDisplayState() === "default" && !$("#ibm-masthead.ibm-mhtype-minimal")[0] && !$(".ibm-masthead-mobile-show")[0]) {
				$(".ibm-masthead-categories").addClass("ibm-fadein").removeClass("ibm-fadeout");
			}
			else if ($(".ibm-masthead-mobile-show")[0]) {
				//$(".ibm-masthead-categories").removeAttr("style");
			}
		}
		else {
			$(".ibm-masthead-categories").addClass("ibm-fadeout").removeClass("ibm-fadein");
		}
	}

	me.showAs = showAs;
	function showAs (type) {
		if (!type) {
			return;
		}

		if (type === "default") {
			showInline();
			displayState = "default";
		}

		if (type === "minimized") {
			showMinimized();
			displayState = "minimized";
		}

		if (type === "maximized") {
			showMaximized();
			displayState = "maximized";
		}
	}

	function showInline () {
		$("body").removeClass("ibm-masthead-search-minimized ibm-masthead-search-maximized");
	}

	// If it's maximized, and narrow, prevent body scrolling so only typeahead scrolls and doesn't close.
	function showMaximized () {
		$("body").removeClass("ibm-masthead-search-minimized").addClass("ibm-masthead-search-maximized");
		IBM.common.util.freezeScrollbars(true);
	}

	function showMinimized () {
		$("body").addClass("ibm-masthead-search-minimized").removeClass("ibm-masthead-search-maximized");
		IBM.common.util.freezeScrollbars(false);
	}

	me.showTypeaheadResults = showTypeaheadResults;
	function showTypeaheadResults (b) {
		if (b) {
			$typeaheadContainer.add($(".ibm-search-scope")).addClass("ibm-fadein").removeClass("ibm-fadeout");
			typeaheadResultsShowing = true;
		}
		else {
			$typeaheadContainer.add($(".ibm-search-scope")).addClass("ibm-fadeout").removeClass("ibm-fadein");
			typeaheadResultsShowing = false;
		}
	}

	/* Wait for events to happen.
	**********************************************************************************************/

	// When meta data is ready (config), call auto init.
	IBM.common.meta.subscribe('dataReady', 'mastheadsearch', me.autoInit).runAsap(me.autoInit);
	
})(jQuery, IBMCore);
;

/**
	
	SUNSET. IBM no longer uses Maxymiser. This has been removed from v18.

	@class IBMCore.common.module.maxymiser

**/
(function ($, IBM) {
	var me = IBM.namespace(IBM, "common.module.maxymiser");
	
	/**
		Placeholder for 2 releases, then this will be removed.
		
		@method init
		@deprecated
	**/
	me.init = function() {
		console.error("Maxymizer has been sunset. Please remove your call to maxymiser.init()");
	};
})(jQuery, IBMCore);
;

/**

	Merchanding module. Same as v17.
	<br />Add a special DIV to the page if you have this enabled.
	<br />If there are any offers or content targeted for your page, it will dynamically inject them in the div.
	<br />Service ID: 104 
	<br />
	
	@class IBMCore.common.module.merchandising
	
**/

/** 
	Page using it in v17:  
		https://www-03.ibm.com/financing/us/contact_rep.html

	Example WSR URL: 
		https://www.ibm.com/gateway/secstate/?&cc=us&lc=en&format=json&ts=1455038215811&industry=ZZ&dc_subject=OE600&currenturl=%2F%2Fwww.ibm.com%2Fsystems%2Fpower%2Fsoftware%2Faix%2Fsolutions.html&ctype=CT528&ww=&cb=102%3A__tcb99391%40106%3A__tcb11910 

	Sample WSR returned data:
		__tcb99391({"results":[{"imgsrc":"//www.ibm.com/i/v16/promo/Systems_power_20140428_168x64.jpg","fileExtension":"","externalUrl":0,"imgh":"64","imgalt":"","linktext":"Learn more","tid":"1","trackOnLoad":1,"imgw":"168","linkurl":"http://www-03.ibm.com/financing/us/hardware/powersystems.html?cm_sp=MTE29908","title":"Financing for Power Systems","weight":"0.0","type":"DEF","description":"0% 24 month financing for select Power Systems servers, Maximize your investment with IBM Global Financing.","fileSize":"","spotid":29908}]})

**/

(function ($, IBM) {

	// Create name space for this thing and make shortcuts.
	var me = IBM.namespace(IBM, "common.module.merchandising"),
		myEvents = IBM.common.util.eventCoordinator(me, "User", ["ready", "error"]),
		maxNumModules = 6;
		
	/**
		Callback from subscription to meta data 'ready' event publisher. 
		<br />Checks if merchandising is enabled and if the placeholder is on the page. If so, inits it.
		<br />No point in requesting offers if they forgot the DIV.

		@method autoInit
	**/
	me.autoInit = function () {
		$(function(){
			if (IBM.common.util.config.isEnabled("merchandising") && $("#ibm-merchandising-module")[0]) {
				me.init();
			}
		});
	};

	/**
		Called by autoInit.
		<br />Gathers some page meta data and requests offers from MTE service.

		@method init
	**/
	me.init = function () {
		var data = {
				industry: IBM.common.meta.page.pageInfo.ibm.industry || "",
				specialpurpose: IBM.common.meta.page.pageInfo.ibm.specialPurpose || "",
				dc_subject: IBM.common.meta.page.pageInfo.ibm.subject || "",
				// the normalized URL of the page without protocol
				currenturl: IBM.common.util.url.getUrl().replace(/^https?:/, ''),
				ctype: IBM.common.meta.page.pageInfo.ibm.type || "",
				ww: IBM.common.meta.page.pageInfo.ibm.wwCase || ""
			};

		IBM.common.util.coreservices.makeRequest("102", "IBMCore.common.module.merchandising.createModules", data);
	};

	/**
		Callback from MTE WSR. This loops thru each offer returned, creates the appropriate HTML, then injects it into
		the placeholder div on the page (if it exists).

		@method createModules
	**/
	me.createModules = function (serviceData) {
		// var fakeDisplayType = IBM.common.util.url.getParam("dt") || "1",
		// fakeData = { "results": [
		// 	{ "imgsrc": "//www.ibm.com/i/v16/promo/cloud_igf_ne168x64.jpg",
		// 		"fileExtension": "",
		// 		"externalUrl": 0,
		// 		"imgh": "64",
		// 		"imgalt": "",
		// 		"linktext": "Learn more",
		// 		"tid": fakeDisplayType,
		// 		"trackOnLoad": 1,
		// 		"imgw": "168",
		// 		"linkurl": "http://www.ibm.com/financing/us/cloud/index.html?cm_sp=MTE8962",
		// 		"title": "Cloud Financing",
		// 		"weight": "30.0",
		// 		"type": "DEF",
		// 		"description": "Wondering how to finance your cloud?",
		// 		"fileSize": "",
		// 		"spotid": 8962
		// 	},
		// 	{ "imgsrc": "//www.ibm.com/i/v16/promo/systems-storage-168x64.jpg",
		// 		"fileExtension": "",
		// 		"externalUrl": 0,
		// 		"imgh": "64",
		// 		"imgalt": "",
		// 		"linktext": "Learn more",
		// 		"tid": fakeDisplayType,
		// 		"trackOnLoad": 1,
		// 		"imgw": "168",
		// 		"linkurl": "http://www-03.ibm.com/financing/us/hardware/storage.html?cm_sp=MTE16710",
		// 		"title": "Financing for IBM Storage Systems",
		// 		"weight": "30.0",
		// 		"type": "DEF",
		// 		"description": "Transform your business storage infrastructure with the right financing",
		// 		"fileSize": "",
		// 		"spotid": 16710
		// 	},
		// 	{ "imgsrc": "//www.ibm.com/i/v16/promo/cloud_igf_ne168x64.jpg",
		// 		"fileExtension": "",
		// 		"externalUrl": 0,
		// 		"imgh": "64",
		// 		"imgalt": "",
		// 		"linktext": "Learn more",
		// 		"tid": fakeDisplayType,
		// 		"trackOnLoad": 1,
		// 		"imgw": "168",
		// 		"linkurl": "http://www.ibm.com/financing/us/cloud/index.html?cm_sp=MTE8962",
		// 		"title": "This is the third",
		// 		"weight": "30.0",
		// 		"type": "DEF",
		// 		"description": "Wondering how to finance your cloud?",
		// 		"fileSize": "",
		// 		"spotid": 8962
		// 	},
		// 	{ "imgsrc": "//www.ibm.com/i/v16/promo/systems-storage-168x64.jpg",
		// 		"fileExtension": "",
		// 		"externalUrl": 0,
		// 		"imgh": "64",
		// 		"imgalt": "",
		// 		"linktext": "Learn more",
		// 		"tid": fakeDisplayType,
		// 		"trackOnLoad": 1,
		// 		"imgw": "168",
		// 		"linkurl": "http://www-03.ibm.com/financing/us/hardware/storage.html?cm_sp=MTE16710",
		// 		"title": "This is the fourth",
		// 		"weight": "30.0",
		// 		"type": "DEF",
		// 		"description": "Transform your business storage infrastructure with the right financing",
		// 		"fileSize": "",
		// 		"spotid": 16710
		// 	}
		// ]};

		var merchObj = serviceData,
			mteLocation = 1,
			modulesHtml = "";

		// Stop if there are no results.
		if (merchObj.results.length === 0 || (merchObj.results.length !== 0 && merchObj.results[0].result === "novalue")) {
			return;
		}

		// #1: (default) 5-column grid using 5-1 (legacy left nav type setup).
		// #2: If we are using 6-column grid with 6-1.
		// #3: If we are using 6 column grid with double sized sidebar.
		// #4: If we are using footer section.
		if ($(".ibm-col-6-1 #ibm-merchandising-module").length === 1) {
			mteLocation = 2;
		}
		else if ($(".ibm-col-6-2 #ibm-merchandising-module").length === 1) {
			mteLocation = 3;
		}
		else if ($("#ibm-merchandising-module").closest("#ibm-related-content").length === 1) {
			mteLocation = 4;
		}

		// Loop through all modules returned by service and create HTML for them.
		$.each(merchObj.results, function (i, item) {
			if (i > (maxNumModules-1)) {
				return;
			}

			var moduleType = parseInt(item.tid, 10),
				image = "",
				heading = "",
				descr = "",
				iconLink = "",
				moduleHtml = "",
				hiddenFields = '<input type="hidden" class="ibm-mm-spot-id" value="' + item.spotid + '" /><input type="hidden" class="ibm-mm-weight" value="' + item.weight + '" />';

			item = addLinkData(item);

			// Build components based on ID and where the MTE div is.
			// What type ID is the primary determiner, but then there are exceptions to a few based on where the
			//  page owner put the DIV. Ex: don't put a image in a wide column, etc.

			// Type 4: Doesn't use an image. So it can't go in related-content (location 4) because image is required there.
			if (moduleType === 4 && mteLocation !== 4) {
				heading = createHeading(item);
				descr = createDescription(item);
				iconLink = createIconlink(item, true);
			}
			// Type 3: Doesn't use an icon link. Only use the image if it's not in a 6-2 (that's too wide).
			else if (moduleType === 3) {
				heading = createHeading(item);
				descr = createDescription(item, true);
				
				if (mteLocation !== 3) {
					image = createImage(item);
				}
			}
			// Type 2 & 1: Uses everything with exception for the 6-2 location.
			else if (moduleType === 1 || moduleType === 2) {
				heading = createHeading(item);
				descr = createDescription(item);
				iconLink = createIconlink(item, true);
				
				if (mteLocation !== 3) {
					image = createImage(item);
				}
			}

			// Concat the pieces to create the module's HTML.
			moduleHtml = image + heading + descr + iconLink;

			// SPECIAL: Type 2 + 6-2 = Portrait module. Only place it can be.
			if (moduleType === 2 && mteLocation === 3) {
				moduleHtml = createPortraitModule(item);
			}

			// Wrap in self contained div and add hidden fields for tagging.
			moduleHtml = '<div class="ibm-mte-module" style="cursor: pointer;" onclick="jQuery(this).find(\'a\')[0].click();">' + moduleHtml + hiddenFields + '</div>';

			// If it's in the related-content section, wrap in a column.
			if (mteLocation === 4) {
				moduleHtml = '<div class="ibm-col-6-1 ibm-col-medium-6-2 ibm-padding-bottom-2">' + moduleHtml + '</div>';
			}

			// Add this module to the HTML to echo on the glass.
			modulesHtml += moduleHtml;
		});	

		// If it's in the related-content section, wrap in columns.
		if (mteLocation === 4) {
			modulesHtml = '<div class="ibm-columns" data-widget="setsameheight" data-items=".ibm-mte-module">' + modulesHtml + '</div>';
		}

		// Output the modules into the div if it exists.
		// REMEMBER: This wasn't init'd until DOM was ready so we could check the placeholder exists before bothering
		//  to request offers, so fire away.
		$("#ibm-merchandising-module").html(modulesHtml).find("[data-widget='setsameheight']").setsameheight();
	};


	/**
		Creates the description HTML for the offer, and hotlinks if flag is set, which indicates no standalone link will be created.

		@method createDescription
		@private
		@param item {Object} The object with all the offer content.
		@param includeFileInfo {Boolean} A flag that tell it to hotlink the description because no standalone link will be created.
		@return {String} The HTML for the description paragraph.
	**/
	function createDescription (item, includeFileInfo) {
		var leavingWidget = item.externalUrl === 2 ? ' data-widget="leavingibm"' : '' ,
			descText = item.description;

		if (includeFileInfo) {
			descText = '<a href="' + createLinkUrl(item) + '"' + leavingWidget + '>' + item.description + item.linkData.fileSizeHtml + '</a>';
		}
		
		return '<p>' + descText + '</p>';
	}

	/**
		Creates the heading HTML for the offer.

		@method createHeading
		@private
		@param item {Object} The object with all the offer content.
		@return {String} The HTML for the heading.
	**/
	function createHeading (item) {
		return '<h2 class="ibm-bold ibm-padding-bottom-0">' + item.title + '</h2>';
	}

	/**
		Creates the heading HTML specifically for the portrait module display type.

		@method createHeadingPortrait
		@private
		@param item {Object} The object with all the offer content.
		@return {String} The HTML for the heading.
	**/
	function createHeadingPortrait (item) {
		var leavingWidget = item.externalUrl === 2 ? ' data-widget="leavingibm"' : '' ;

		return '<h2 class="ibm-bold ibm-padding-bottom-0"><a href="' + createLinkUrl(item) + '"' + leavingWidget + '>' + item.title + '</a></h2>';
	}

	/**
		Creates the standalone icon link HTML.

		@method createIconlink
		@private
		@param item {Object} The object with all the offer content.
		@param includeFileInfo {Boolean} A flag that tells it to append the filesize info to the link, if existy.
		@return {String} The HTML for the standalone icon link.
	**/
	function createIconlink (item, includeFileInfo) {
		var leavingWidget = item.externalUrl === 2 ? ' data-widget="leavingibm"' : '' ;
		
		if (includeFileInfo) {
			item.linktext += item.linkData.fileSizeHtml;
		}

		return '<p class="ibm-ind-link">' + '<a class="' + item.linkData.linkClass + '" href="' + createLinkUrl(item) + '"' + leavingWidget + '>' + item.linktext + '</a></p>';
	}

	/**
		Creates the image HTML.

		@method createImage
		@private
		@param item {Object} The object with all the offer content.
		@return {String} The HTML for the image.
	**/
	function createImage (item) {
		return '<div class="ibm-mte-stackedimage"><img class="ibm-resize" src="' + item.imgsrc + '" alt="' + item.imgalt + '" width="' + item.imgw + '" height="' + item.imgh + '" /></div>';
	}

	/**
		Creates the portrait module HTML.

		@method createPortraitModule
		@private
		@param item {Object} The object with all the offer content.
		@return {String} The HTML for the portrait module.
	**/
	function createPortraitModule (item) {
		return '<div class="ibm-mo ibm-mo--top"><div class="ibm-mo__image"><img src="' + item.imgsrc + '" alt="' + item.imgalt + '" width="60" height="60" /></div><div class="ibm-mo__body">' + createHeadingPortrait(item) + createDescription(item) + '</div></div>';
	}

	/**
		Takes a couple of the original item params and figures out what icon to use and creates file size info if needed.
		<br />Adds the extra props to the item and returns to sender.

		@method addLinkData
		@private
		@param item {Object} The object with all the offer content.
		@return {Object} The original item but with the extra data.
	**/
	function addLinkData (item) {
		item.linkData = {
			linkClass: "ibm-forward-link",
			fileSizeHtml: ""
		};
		

		// If it's tagged as an external link, use that class.
		if (item.externalUrl === 1 || item.externalUrl === 2){
			item.linkData.linkClass = "ibm-external-link";
		}
		
		// If a spefic file extension was set, try and match it to an appropriate icon.
		if (item.fileExtension !== "") {
			switch (item.fileExtension) {
				case 'PDF':		
					item.linkData.linkClass = 'ibm-pdf-link';
					break;
				
				case 'RAM':
				case 'MOV':
				case 'WMV':
				case "SWF":
					item.linkData.linkClass = 'ibm-play-link';
					break;

				case "DOC":
				case "ODF":
				case "PPT":
				case "XLS":
					item.linkData.linkClass = 'ibm-document-link';
					break;
			}

			// If there's a file size tagged, append it to the link.
			if (item.fileSize !== "") {
				item.linkData.fileSizeHtml = '<span class="ibm-item-note"> (' + item.fileExtension + ', ' + item.fileSize + ')</span>';
			}
		}

		return item;
	}

	/**
		If the module URL is tagged as offsite/external link, adds the proper "leaving IBM" info to the URL and returns to sender.

		@method createLinkUrl
		@private
		@param item {Object} The object with all the offer content.
		@return {Object} The original item but with the changed/updated link URL.
	**/
	function createLinkUrl (item) {
		// If the flag is set, use the leaving IBM prompt for this link
		if (item.externalUrl === 2) {
			item.linkurl = '//www.ibm.com/links/?prompt=1&cc=' + IBMCore.common.meta.page.pageInfo.ibm.cc + '&lc=' + IBMCore.common.meta.page.pageInfo.ibm.lc + '&url=' + item.linkurl;
		}

		return item.linkurl;
	}
				
/**
	Notes on layouts, from v17:

	(mteLocation)-(item.tid):

	---------------------------------------------------------------
	5-1:

		1-1:  (image + h2 + descr + standalone link)
		<div class="ibm-container">
			<div class="ibm-container-body">
				<div class="ibm-module-image"><img border="0" src="' + item.imgsrc + '" alt="' + item.imgalt + '" /></div>
				<h2>' + item.title + '</h2>
				<p><a href="' + leavingIBMLink + item.linkurl + '">' + item.description + '</a></p>
			</div>
			<ul class="ibm-link-list">
				<li><a class="' + urlLinkClass + '" href="' + leavingIBMLink + item.linkurl + '">' + item.linktext + fileSizeText + '</a></li>
			</ul>
			hiddenFields
		</div>

		1-2:  (1-1 w/ "alternate" class)
		<div class="ibm-container alternate">
			<div class="ibm-container-body">
				<div class="ibm-module-image"><img border="0" src="' + item.imgsrc + '" alt="' + item.imgalt + '" /></div>
				<h2>' + item.title + '</h2>
				<p><a href="' + leavingIBMLink + item.linkurl + '">' + item.description + '</a></p>
			</div>
			<ul class="ibm-link-list">
				<li><a class="' + urlLinkClass + '" href="' + leavingIBMLink + item.linkurl + '">' + item.linktext + fileSizeText + '</a></li>
			</ul>
			hiddenFields
		</div>

		1-3:  (image + h2 + descr)
		<div class="ibm-container">
			<div class="ibm-container-body">
				<div class="ibm-module-image"><img border="0" src="' + item.imgsrc + '" alt="' + item.imgalt + '" /></div>
				<h2>' + item.title + '</h2>
				<p><a href="' + leavingIBMLink + item.linkurl + '">' + item.description + fileSizeText + '</a></p>
			</div>
			hiddenFields
		</div>

		1-4:  (1-2 without an image: h2 + descr + standalone link)
		<div class="ibm-container alternate">
			<div class="ibm-container-body">
				<h2>' + item.title + '</h2>
				<p><a href="' + leavingIBMLink + item.linkurl + '">' + item.description + '</a></p>
			</div>
			<ul class="ibm-link-list">
				<li><a class="' + urlLinkClass + '" href="' + leavingIBMLink + item.linkurl + '">' + item.linktext + fileSizeText + '</a></li>
			</ul>
			hiddenFields
		</div>

	---------------------------------------------------------------
	6-1:

		2-1: (1-1 with "crop" class;  image + h2 + descr + standalone)
		<div class="ibm-container">
			<div class="ibm-container-body">
				<div class="ibm-module-image' + crop + '"><img border="0" src="' + item.imgsrc + '" alt="' + item.imgalt + '" /></div>
				<h2>' + item.title + '</h2>
				<p><a href="' + leavingIBMLink + item.linkurl + '">' + item.description + '</a></p>
			</div>
			<ul class="ibm-link-list">
				<li><a class="' + urlLinkClass + '" href="' + leavingIBMLink + item.linkurl + '">' + item.linktext + fileSizeText + '</a></li>
			</ul>
			hiddenFields
		</div>

		2-2 & 4:  (Same as 1-4) 
		<div class="ibm-container alternate">
			<div class="ibm-container-body">
				<h2>' + item.title + '</h2>
				<p><a href="' + leavingIBMLink + item.linkurl + '">' + item.description + '</a></p>
			</div>
			<ul class="ibm-link-list">
				<li><a class="' + urlLinkClass + '" href="' + leavingIBMLink + item.linkurl + '">' + item.linktext + fileSizeText + '</a></li>
			</ul>
			hiddenFields
		</div>

		2-3:  (1-3 with "crop" class;  image + h2 + standalone)
		<div class="ibm-container">
			<div class="ibm-container-body">
				<div class="ibm-module-image' + crop + '"><img border="0" src="' + item.imgsrc + '" alt="' + item.imgalt + '" /></div>
				<h2>' + item.title + '</h2>
				<p><a href="' + leavingIBMLink + item.linkurl + '">' + item.description + fileSizeText + '</a></p>
			</div>
			hiddenFields
		</div>
	
	---------------------------------------------------------------

	6-2:

		3-1 & 4:  (Same as 1-4)
		<div class="ibm-container alternate">
			<div class="ibm-container-body">
				<h2>' + item.title + '</h2>
				<p><a href="' + leavingIBMLink + item.linkurl + '">' + item.description + '</a></p>
			</div>
			<ul class="ibm-link-list">
				<li><a class="' + urlLinkClass + '" href="' + leavingIBMLink + item.linkurl + '">' + item.linktext + fileSizeText + '</a></li>
			</ul>
			hiddenFields
		</div>

		3-2:  (Portrait module (use media object instead))
		<div class="ibm-container alternate ibm-portrait-module">
			<div class="ibm-container-body">
				<div class="ibm-module-image"><img border="0" src="' + item.imgsrc + '" alt="' + item.imgalt + '" /></div>
				<div class="ibm-module-text">
					<h2>' + item.title + '</h2>
					<p><a href="' + leavingIBMLink + item.linkurl + '">' + item.description + '</a></p>
					<ul class="ibm-link-list">
						<li><a class="' + urlLinkClass + '" href="' + leavingIBMLink + item.linkurl + '">' + item.linktext + fileSizeText + '</a></li>
					</ul>
				</div>
			</div>
			hiddenFields
		</div> 

		3-3:  (h2 + descr)
		<div class="ibm-container alternate">
			<div class="ibm-container-body">
				<h2>' + item.title + '</h2>
				<p><a href="' + leavingIBMLink + item.linkurl + '">' + item.description + fileSizeText + '</a></p>
			</div>
			hiddenFields
		</div>

	---------------------------------------------------------------

	#ibm-related-content:

		4-1:  (Same as 2-1; 1-1 with crop class)
		<div class="ibm-container">
			<div class="ibm-container-body">
				<div class="ibm-module-image' + crop + '"><img border="0" src="' + item.imgsrc + '" alt="' + item.imgalt + '" /></div>
				<h2 class="ibm-third">' + item.title + '</h2>
				<p><a href="' + leavingIBMLink + item.linkurl + '">' + item.description + '</a></p>
				<p class="ibm-ind-link">' + '<a class="' + urlLinkClass + '" href="' + leavingIBMLink + item.linkurl + '" >' + item.linktext + fileSizeText + '</a></p>
			</div>
			hiddenFields
		</div>

		4-3:  (Same as 1-3, with crop)
		<div class="ibm-container">
			<div class="ibm-container-body">
				<div class="ibm-module-image' + crop + '"><img border="0" src="' + item.imgsrc + '" alt="' + item.imgalt + '" /></div>
				<h2 class="ibm-third">' + item.title + '</h2>
				<p><a href="' + leavingIBMLink + item.linkurl + '">' + item.description + fileSizeText + '</a></p>
			</div>
			hiddenFields
		</div>

		4-2 & 4 ignored in footer.

	---------------------------------------------------------------

**/

	
	/* Wait for events to happen to fire off all the above.
	**********************************************************************************************/

	// When meta is ready, it means all configs have been set (full <head> loaded), so we can check if service is enabled.
	IBM.common.meta.subscribe("dataReady", "mte", me.autoInit);

})(jQuery, IBMCore);
;

/**

	This builds the hamburger menu (formerly "mobile menu").
	<br />It simply replicates the masthead links + page nav links and put them into a overlay that slides in from the right.

	@class IBMCore.common.module.mobilemenu

**/

(function ($, IBM) {
	/**
		Publishes this event after complete mobilemenu is built.

		@event ready
	**/
	var me = IBM.namespace(IBM, "common.module.mobilemenu"),
		myEvents = IBM.common.util.eventCoordinator(me, "mobilemenu", [
			"ready"
		]),
		currentlyShowing = false,
		mastheadData = null,
		$mobilemenu,
		$mobileSitenavLinks,
		$mobileSitenavMenuLinks,
		$mobileUniversalLinks,
		$mobileCategoryLinks;
		
	me.isLoaded = false;

	/**
		Callback from subscription to meta data 'ready' event publisher. Checks if masthead is enabled (default). 
		<br />If so, subscribe to masthead and then init mobilemenu if enabled.
		<br />Two separate checks so that a masthead type can override and disable/enable it (Ex: popup masthead disables it).

		@method autoInit
	**/
	me.autoInit = function() {
		if (IBM.common.util.config.isEnabled("masthead")) {
			IBM.common.module.masthead.subscribe("ready", "mobilemenu", function () {
				if (IBM.common.util.config.isEnabled("masthead.mobilemenu")) {
					setTimeout(me.init, 50);
				}
			});
		}
	};

	/**
		Callback from subscription to masthead 'ready' event publisher inside autoInit. 
		<br />Creates the burger menu (clones masthead into this).
		<br />Since we had to wait for masthead to be in the DOM, it means DOM & masthead is ready.

		@method init
	**/
	me.init = function () {
		mastheadData = IBM.common.module.masthead.getMastheadData();

		// Removes any existing one from a page locale change/re-init. Gets reset below when we create the new one.
		$(".ibm-mobilemenu").remove();

		// Add the background screen if it doesn't exist already (from a locale change).
		if (!$("#ibm-mobilemenu-screen")[0]) {
			$("body").append('<div id="ibm-mobilemenu-screen"></div>');			
		}

		// Setup all the HTML elements into vars.
		$mobileSitenavLinks = createMenunavMainLinks();
		$mobileSitenavMenuLinks = createMenunavSubmenuLinks();
		$mobileUniversalLinks = "";
		$mobileCategoryLinks = "";

		var mobilemenuCloseHtml = '<div class="ibm-mobilemenu-close"><p class="ibm-icononly ibm-fright"><a class="ibm-close-link" href="#">' + IBM.common.translations.data.v18main.misc.close + '</a></p></div>',
			unavHeading = '<h2 class="ibm-mobile-section-heading">' + IBM.common.translations.data.v18main.unav.title + '</h2>',
			categoryHeading = IBM.common.module.masthead.getMastheadLinklists().catnav.html !== '' ? '<h2 class="ibm-mobile-section-heading">' + IBM.common.translations.data.v18main.catnav.title + '</h2>' : '';

		// NEW. Must be objects
		//$mobileUniversalLinks = $('<div class="ibm-mobilemenu-section"></div>').prepend(unavHeading).append(IBM.common.module.masthead.getMastheadLinklists().unav.html).find(".ibm-masthead-unav").attr("class", "ibm-masthead-unav-mobilemenu").end();
		$mobileUniversalLinks = createUnavSection(unavHeading);
		$mobileCategoryLinks = createCatnavSection(categoryHeading);

		if (!$mobileSitenavLinks && !$mobileSitenavMenuLinks) {
			$mobileUniversalLinks.find(".ibm-show-hide > h2").attr("data-open", "true");
			$mobileCategoryLinks.find(".ibm-show-hide > h2").attr("data-open", "true");
		}
		
		//$mobileCategoryLinks = $('<div class="ibm-mobilemenu-section ibm-show-hide" data-type="panel" data-widget="showhide"></div>').prepend(categoryHeading).append(IBM.common.module.masthead.getMastheadLinklists().catnav.html).find(".ibm-masthead-categories").attr("class", "ibm-masthead-categories-mobilemenu").end();

		// Add the HTML items into the mobile menu container, then prepend it to top div (above masthead).
		// TODO: Santelia: Change headings to use new translations vars when we make the switch.
		$mobilemenu = $('<div class="ibm-mobilemenu ibm-hide" aria-labelledby="ibm-burgermenu-a11y" role="dialog"></div>')
			.append('<p class="ibm-hide" id="ibm-burgermenu-a11y">' + (IBM.common.translations.data.v18main.misc.sitenav || "Site navigation") + '</p>')
			.append(mobilemenuCloseHtml) // Close button swapped with burger icon in MH.
			.append($mobileSitenavLinks)
			.append($mobileSitenavMenuLinks)
			//.append(unavHeading)
			.append($mobileUniversalLinks)
			//.append(categoryHeading)
			.append($mobileCategoryLinks)
			.insertAfter("#ibm-masthead");

		// Setup the menu bindings and do misc stuff behind the scenes.
		// SetTimeout pushes these to the back of the onload queue so we don't delay onscreen rendering.)
		setTimeout(function(){
			setupMobilemenuBindings();

			// Add Marketplace link to place where they want it *currently*. Subject to change.
			//$(".ibm-masthead-unav-mobilemenu").prepend(marketplaceLink);

			// Blanketly tag every link with special param (lnk prepended with "hm" so page owners can tell if 
			//  the link was clicked from the masthead/page content, or from the burger menu.
			$mobilemenu.find("a").each(function(){
				var newUrl = IBM.common.util.url.addParam({
						url: this.getAttribute("href"),
						paramName: "lnk",
						paramValue: "hm" + (IBM.common.util.url.getParam("lnk",this.href) || "")
					});
				this.href = newUrl;
			});

			// Setup any show/hides we placed.
			setupShowhides();

			// Setup page nav. Handles nested LI classes and a11y tree control setup.
			setupPageNavs();

			// We need to  know when two show-hides are open, so add a state to the parent LI.
			$mobilemenu.find(".ibm-show-hide h2 a").on("click", function () {
				var $thisLink = $(this);
				if ($thisLink.parent("h2.ibm-showing")[0]) {
					$thisLink.closest(".ibm-haschildlist").addClass("ibm-showing");
				}
				else {
					$thisLink.closest(".ibm-haschildlist").removeClass("ibm-showing");
				}
			});

			// TODO: Santelia: Update this.?
			$mobilemenu.find(".ibm-masthead-categories-mobilemenu, .ibm-masthead-unav-mobilemenu").each(function(){
				IBM.common.util.a11y.makeToolbarAccessible({
					el: this
				});
			});

			// If they tab off any links in the last section, loop back around to the close link (the first one in the loop).
			// This includes the show/hide trigger, in case it's closed.
			$mobilemenu.find(".ibm-mobilemenu-section:last a").keydown(function (evt) {
				if (evt.keyCode === 9 && !evt.shiftKey) {
					// If the keyboard tab is on the show/hide trigger and it's open, let tab goto the next A naturally.
					// Else it's closed or we're not on it, which means nothing is left to tab to so loop back to close button.
					if ($(this).hasClass("ibm-show-active")) {
						return;
					}
					evt.preventDefault();
					$mobilemenu.find("a:first").focus();
				}
			});

			// If they backtab from the "close" link, loop back to the bottom links (the last one in the loop).
			$mobilemenu.find(".ibm-mobilemenu-close a").keydown(function (evt) {
				if (evt.keyCode === 9 && evt.shiftKey) {
					evt.preventDefault();
					$mobilemenu.find("a:visible:last").focus();
				}
			});

			$("#ibm-mobilemenu-screen").on("click", function () {
				if (IBM.common.module.mobilemenu.isOpen()) {
					IBM.common.module.mobilemenu.hide();
				}
			});

		}, 30);


		// Tell subscribers we're all done.
		me.isLoaded = true;

		myEvents.publish("ready");
	};

	/** 
		Create the Marketplace link based on the translations from the data file, and the computed URL that the masthead setup.

		@method createMarketplaceLink
		@private
		@return {String} The LI HTML to insert into the existing masthead nav link section.
	**/
	function createMarketplaceLink () {
		var html = "";
		if (mastheadData.tryandbuy && mastheadData.tryandbuy.url) {
			html = '<li><a href="' + mastheadData.tryandbuy.url + '?lnk=mp">' + mastheadData.tryandbuy.title + '</a></li>';
		}

		return html;
	}

	/** 
		Takes the category nav links HTML the masthead setup and stored and wraps them in a show hide section.

		@method createCatnavSection
		@private
		@param heading {String} The text for the section heading. Created as show/hide if not empty.
		@return {DOM element} The new element to inject as the category nav links section.
	**/
	function createCatnavSection (heading) {
		// var $container = $('<div class="ibm-mobilemenu-section"></div>').prepend(heading + IBM.common.module.masthead.getMastheadLinklists().catnav.html).find(".ibm-masthead-categories").attr("class", "ibm-masthead-categories-mobilemenu").end();

		// return $container;
		
		var container = '<div class="ibm-mobilemenu-section"><div class="ibm-show-hide" data-type="panel" data-widget="showhide">' + heading + '<div class="ibm-container-body">' + IBM.common.module.masthead.getMastheadLinklists().catnav.html + '</div></div>',
			$container = $(container).find(".ibm-masthead-categories").attr("class", "ibm-masthead-categories-mobilemenu").end();
		
		return $container;

	}

	/** 
		Takes the universal nav links HTML the masthead setup and stored and wraps them in a show hide section.

		@method createUnavSection
		@private
		@param heading {String} The text for the section heading. Created as show/hide if not empty.
		@return {DOM element} The new element to inject as the universal nav links section.
	**/
	function createUnavSection (heading) {
		var container = '<div class="ibm-mobilemenu-section"><div class="ibm-show-hide" data-type="panel" data-widget="showhide">' + heading + '<div class="ibm-container-body">' + IBM.common.module.masthead.getMastheadLinklists().unav.html + '</div></div>',
			$container = $(container).find(".ibm-masthead-unav").prepend(createMarketplaceLink()).attr("class", "ibm-masthead-unav-mobilemenu").end();
		
		return $container;
	}

	/** 
		Clones page nav (left or tabs), cleans up IDs & classes, then returns clone ready for DOM injection.

		@method createMenunavMainLinks
		@private
		@return {DOM element} The new element to inject as the page left or tab nav links section.
	**/
	function createMenunavMainLinks () {
		var $pageNav;

		if ($("#ibm-primary-tabs li").length > 0) {
			$pageNav = $("#ibm-primary-tabs ul").clone(true);

			if ($("#ibm-primary-tabs[data-widget='dyntabs']")[0]) {
				$pageNav.attr("data-type","dyntabs");
			}
			
			// If there's subtabs, nest them in the LI that's active where they belong, just like the left nav.
			if ($("#ibm-secondary-tabs li").length > 0) {
				$("a[aria-selected='true']", $pageNav).after($("#ibm-secondary-tabs ul").clone());
			}
		}
		else if ($("#ibm-primary-links li").length > 0) {
			$pageNav = $("#ibm-primary-links").clone().removeAttr("id");
		}
		else {
			return $pageNav;  // Just return if there's no left nav or tabs.
		}

		// Cleanup to remove tab class so they don't get formatted horizontally like tabs, 
		//  and add new class for styling in the mobile menu.
		$pageNav.removeClass("ibm-tabs").find(".ibm-tabs").removeClass("ibm-tabs");
		
		// Remove any IDs.
		$("[id]", $pageNav).removeAttr("id");

		// Left nav and tabs use aria-selected, and boths sets of tabs can have one, so find the "last"
		//  one that we're on and tag it specially. 
		$("a[aria-selected='true']:last", $pageNav).wrapInner("<span>").parent().addClass("ibm-mobilemenu-nav-selected");

		return $('<div class="ibm-mobilemenu-section ibm-mobilemenu-pagenav"></div>').html($pageNav);
	}

	/** 
		Clones the new site nav menu then returns clone ready for DOM injection.

		@method createMenunavSubmenuLinks
		@private
		@return {DOM element} The new element to inject as the page menunav links section.
	**/
	function createMenunavSubmenuLinks () {
		var $pageNav;

		// Stop if there's no site nav menu on the page.
		if (!$(".ibm-sitenav-menu-container")[0] || $(".ibm-sitenav-menu-list > ul > li").length === 0) {
			return;
		}

		$pageNav = $(".ibm-sitenav-menu-list > ul").clone();
		
		// Add/clone site name if it exists.
		if ($(".ibm-sitenav-menu-name")[0]) {
			$pageNav.prepend('<li class="ibm-mobile-section-heading ibm-mobile-sitename">' + $(".ibm-sitenav-menu-name").html() + '</li>');
		}

		// Add/clone site name if it exists.
		if ($(".ibm-parent-site-name")[0]) {
			$pageNav.prepend('<li class="ibm-mobile-section-heading ibm-mobile-sitename">' + $(".ibm-parent-site-name").html() + '</li>');
		}

		// Add class to the parent LI b/c it sets the "you are here" left border on the item. 
		// (Instead of the <a> b/c the A does the indented top border).
		//$("a.ibm-highlight", $pageNav).parent().addClass("ibm-mobilemenu-nav-selected").closest("li.ibm-haschildlist").attr("aria-expanded", "true");
		// Normalize for old way to highlight (class on the <a>).
		$("a.ibm-highlight", $pageNav).removeClass("ibm-highlight").parent().addClass("ibm-highlight");
		$(".ibm-highlight", $pageNav).addClass("ibm-mobilemenu-nav-selected").children("a").closest("li.ibm-haschildlist").attr("aria-expanded", "true");

		// For each menu item that has a child list, set it up to be a basic show/hide.
		$("li.ibm-haschildlist", $pageNav).wrapInner('<div class="ibm-show-hide" data-type="panel" data-widget="showhide"></div>').each(function(){
			var $mainItem = $(this),
				itemTrigger = $mainItem.find("> div > button")[0] || $mainItem.find("> div > span")[0],
				useText = itemTrigger.innerHTML;

			$('<h2>' + useText + '</h2>').replaceAll($(itemTrigger)).siblings("ul").addClass("ibm-padding-top-0").wrap('<div class="ibm-container-body"><div>');
		});

		// Find the menu item that we're on, and set it's show/hide to be open by default.
		//$("a.ibm-highlight", $pageNav).closest(".ibm-show-hide").children("h2").attr("data-open", "true");
		$(".ibm-highlight", $pageNav).closest(".ibm-show-hide").children("h2").attr("data-open", "true");

		//data-widget="showhide" data-type="panel" 
		return $('<div class="ibm-mobilemenu-section ibm-mobilemenu-sitenavmenu"></div>').html($pageNav);
	}

	/** 
		Sets up bindings for the close button.

		@method setupMobilemenuBindings
		@private
	**/
	function setupMobilemenuBindings () {
		$(".ibm-mobilemenu-close").click(function (evt) {
			evt.preventDefault();
			me.hide();
			$(".ibm-masthead-item-menu button").focus();
		});
	}


	/** 
		Sets up styling/extra HTML for page nav in menu and its a11y controls.

		@method setupPageNavs
		@private
	**/
	function setupPageNavs () {
		// For any nested list items, wrap the link text in a span so that we can put a border under the text on hover.
		$mobilemenu.find(".ibm-mobilemenu-section li li a").wrapInner("<span>");

		IBM.common.util.a11y.makeTreeAccessible({
			el: $mobilemenu.find(".ibm-mobilemenu-pagenav > ul")
		});
	}

	/** 
		Inits show/hides not inited yet and tags selected nav item's show/hide container for highlighting.

		@method setupShowhides
		@private
	**/
	function setupShowhides () {
		// Init any un-init'd show/hides and then tag the one currently opened with the common class.
		$mobilemenu.find(".ibm-show-hide:not(.ibm-widget-processed)").showhide();

		// Add the class to the currently opened one.
		$mobilemenu.find(".ibm-mobilemenu-nav-selected .ibm-show-hide").parent().addClass("ibm-showing");
	}

	/**
		Helper function to rename every element's ID in the given scope to append "-mobile".

		@method convertToMobileIds
		@param $scope {Element} The element to scope the selector find within.
		@private
	**/
	function convertToMobileIds ($scope) {
		$("[id]", $scope).each(function(){
			$(this).attr("id", $(this)[0].id + "-mobile");
		});
	}

	/**
		API for pages that use AJAX or inject tabs or menu nav after page load. 
		<br />After you inject your site's menu or tab nav, call this to clone it into the burger menu.
		<br />In case you make it and inject your HTML before burger menu creates, if the page nav already exists in the burger menu
		 this stops and does nothing.

		@method addSiteNavigation
	**/
	me.addSiteNavigation = function () {
		// Safety for timing issue in case the site menu made it in there on page load.
		// This prevents a page from calling this and injecting the site nav if it's already in the burger menu.
		if ($mobileSitenavLinks || $mobileSitenavMenuLinks) {
			return;
		}

		$mobileSitenavLinks = createMenunavMainLinks();
		$mobileSitenavMenuLinks = createMenunavSubmenuLinks();

		// If any site nav elements were cloned and created for us to use;
		// Close the show/hides if they were expanded because there was no sitenav in the burger menu.
		// Then prepend the site nav and setup the selected items and the show/hides.
		if ($mobileSitenavLinks || $mobileSitenavMenuLinks) {
			$mobileUniversalLinks.find(".ibm-show-hide.ibm-widget-processed > h2 a.ibm-show-active").trigger("click");
			$mobileCategoryLinks.find(".ibm-show-hide.ibm-widget-processed > h2 a.ibm-show-active").trigger("click");

			// Prepend the nav items found on the page.
			$mobilemenu.find(".ibm-mobilemenu-section:first").prepend($mobileSitenavMenuLinks).prepend($mobileSitenavLinks);

			// Setup any show/hides we placed.
			setupShowhides();
			
			// Setup page nav we injected by adding nested LI inner span and setup a11y controls on it.
			setupPageNavs();
		}
	};

	/**
		Shows the burger menu.

		@method show
	**/
	me.show = function () {
		$(".ibm-mobilemenu").removeClass("ibm-hide");
		
		setTimeout(function(){
			$("#ibm-com").addClass("ibm-show-mobilemenu-screen ibm-mobilemenu-show");
			$(".ibm-mobilemenu-section a:first").focus();
			IBM.common.util.freezeScrollbars(true);
			currentlyShowing = true;
		}, 30);
	};

	/**
		Hides the burger menu.

		@method hide
	**/
	me.hide = function () {
		$("#ibm-com").removeClass("ibm-mobilemenu-show");
		
		setTimeout(function(){
			$("#ibm-com").removeClass("ibm-show-mobilemenu-screen");
			IBM.common.util.freezeScrollbars(false);
		}, 150);
		
		// Make sure this is set to be after whatever the CSS transition is (currently 0.3s)
		setTimeout(function(){
			//$("#ibm-com").removeClass("ibm-masthead-zindex-top");
			$(".ibm-mobilemenu").addClass("ibm-hide");

			//IBM.common.util.freezeScrollbars(false);
			currentlyShowing = false;
		}, 400);
	};

	
	/** 
		Simple helper to toggle the burger menu showing/hiding.

		@method toggle
	**/
	me.toggle = function () {
		if (me.isOpen()) {
			me.hide();
		}
		else {
			me.show();
		}
	};

	/** 
		Simple helper that tells you if the burger menu is showing or not.

		@method isShowing
		@return {Boolean} True if it's open, false if it's closed.
	**/
	me.isShowing = function () {
		return currentlyShowing;
	};

	/** 
		Deprecated. Use "isShowing" instead. Makes more sense.

		@method isOpen
		@deprecated
	**/
	me.isOpen = me.isShowing;


	/* Wait for events to happen.
	**********************************************************************************************/

	// When meta data is ready (config), call auto init.
	IBM.common.meta.subscribe("dataReady", "mobilemenu", me.autoInit).runAsap(me.autoInit);
	
})(jQuery, IBMCore);
;

/**

	Share this page widget. Replaces old SBS bar from v17.
	<br />
	<br />Waits for translations to be retrieved then automatically creates and injects the widget if's on the page.
	<br />
	<br />Enabled by default, BUT only shows up if and where you put the placeholder div on the page. No DIV, no show.
	<br />
	<br />To disable add this JS snippet to your page:
		
		IBMCore.common.util.config.set({
			sharethispage: { enabled: false }
		});
		
	@class IBMCore.common.module.sharethispage

**/

(function ($, IBM) {

	/**
		Publishes this event after the module has been injected.

		@event ready
	**/
	// Create name space for this thing and make a shortcut to it for ourselves.
	var me = IBM.namespace(IBM, 'common.module.sharethispage'), 
		myEvents = IBM.common.util.eventCoordinator(me, 'sharethispage', ['ready']),
		pageUrl,
		pageTitle,
		defaultHeading = "Share this page";

	/**
		Default standard auto init function.
		<br />Callback from subscription to translations 'dataReady' event publisher.
		<br />Simply runs init if conditions are met.

		@method autoInit
	**/
	me.autoInit = function () {
		if (IBM.common.util.config.isEnabled("sharethispage") && IBM.common.translations.data.v18main.socialSharing && IBM.common.translations.data.v18main.socialSharing.length !== 0) { 
			$(me.init);
		}
	};

	/**
		Creates the widget links and heading if enabled and injects on page wherever the div is.
		<br />Called by autoinit if module is enabled.
		<br />Just like MTE - It doesn't inject anything if proper div placeholder doesn't exist (duh).
		
		@method init
	**/
	me.init = function () {
		pageUrl = IBM.common.util.url.getUrl(); // Get the correct URL of this page.
		pageTitle = $("title").html() || ""; // Get the title/text to use for the link.

		var links = createSbslinks();

		// HTML injection replaces whatever contents were in it, for cases of dynamic locale change.
		// Sets a heading, then appends the P, then insets the links in there (P).
		$(function(){
			if ($(".ibm-sharethispage")[0]) {
				$('<p class="ibm-icononly"></p>').appendTo($(".ibm-sharethispage").html('<h4 class="ibm-bold">' + (IBM.common.translations.data.v18main.misc.sharePage || defaultHeading)  + '</h4>')).html(links);
			}

			// Tell subscribers we're done.
			myEvents.publish("ready");
		});
	};

	/**
		Creates the URL used on the link (not with bitly one). Does the title and URL replacement.
		
		@method createShareLinkUrl
		@private
		@param url {String} The social share URL to add page info to.
		@return {String} The social share URL to use in the link.
	**/
	function createLinkUrl (url) {
		return url
				.replace(/%\{URL\}/g, encodeURIComponent(pageUrl))
				.replace(/%\{TITLE\}/g, encodeURIComponent(pageTitle));
	}

	/**
		Creates the actual link element object, used by each link object from the data file.
		
		@method createLinkEl
		@private
		@param icon {Object} The object from the data file containing the link data to use to build the icon link.
		@return {Object} The created icon link element.
	**/
	function createLinkEl (icon) {
		return $('<a></a>').attr({
				"class" : "ibm-" + icon.id + "-encircled-link",
				"href" : icon.linkUrl
			}).html(icon.title).click(function (evt) {
				return clickHandler(evt, icon);
			});
	}

	/**
		Goes thru data file and creates widget icon links.
		
		@method createSbslinks
		@private
		@return {Array} Array of icon link elements to be injected.
	**/
	function createSbslinks () {
		var $links = [],
			emailIcon = {
				id: "email",
				title: IBMCore.common.translations.data.v18main.misc.emailThisPage,
				url: ""
			};

		// Loop thru socialsharing data and create individual list items to $ul.
		$.each(IBM.common.translations.data.v18main.socialSharing, function () {
			var icon = this;

			if (!icon.url || icon.id === "ibm-dogear") { // Skip these.
				return;
			}

			// Map the class name from v17 to the v18 icon one.
			if (icon.id === "stumble") {
				icon.id = "stumbleupon";
			}

			icon.linkUrl = createLinkUrl(icon.url);

			$links.push( createLinkEl(icon) );
		});

		// PLACEHOLDER to add email icon.
		// Waiting on new matching icon & position (first or last in the set).
		if (emailIcon.title && emailIcon.title !== "") {
			emailIcon.linkUrl = createLinkUrl("mailto:?subject=%{TITLE}&body=%{URL}");

			$links.push( createLinkEl(emailIcon) );
		}

		return $links;
	}

	/**
		Icon links onclick callback. Fires metric event, does bitly shortening, etc.
		
		@method clickHandler
		@private
		@param e {Event} The click event.
		@param icon {Object} The icon object with data to use.
	**/
	function clickHandler (e, icon) {
		// Metrics click tracking.
		IBM.common.util.statshelper.fireEvent({
			ibmEV : 'external link',
			ibmEvAction : icon.linkUrl,
			ibmEvGroup : 'Share this page icons',
			ibmEvName : 'stp-' + icon.id
		});

		// Let email link do default action.
		if (icon.id === 'email' || icon.id === 'w3-email') {
			return;
		}

		// We can't shorten url for StumbleUpon service, they no longer accept 301/302/etc.. URLs
		// if we shorten it now, Stumble will say something like "This webpage is not available. Please try another page."
		if (icon.id === 'stumbleupon') {
			window.open(icon.linkUrl);
			return false;
		}

		e.preventDefault();

		// Shorten the page's URL and then goto the social sharing property link using it.
		IBM.common.util.bitly.shorten({
			url : pageUrl,
			success : function (shortUrl) {
				var url = icon.url.replace(/%\{URL\}/g, encodeURIComponent(shortUrl)).replace(/%\{TITLE\}/g, encodeURIComponent(pageTitle));
				window.open(url);
			}
		});
	}

	/* Wait for events to happen.
	**********************************************************************************************/

	// When translations are ready, call autoInit to build it. Translations can be cached, so use runAsap also.
	IBM.common.translations.subscribe("dataReady", "sharethispage", me.autoInit).runAsap(me.autoInit);

})(jQuery, IBMCore);
;

/**

	Site navigation menu
	<br />
	<br />This is the site navigation menu bar that's above the leadspace. It's got the site name on the left and links and drop-down
	menus on the right.
	<br />By default the menunav is sticky. Stickyness can be disabled by adding the attribute to the div:  data-sticky="false"
	<br />

	@class IBMCore.common.module.sitenavmenu

**/

(function($, IBM) {
	/**
		Publishes this event after the nav menu has been setup.

		@event ready
	**/
	var me = IBM.namespace(IBM, "common.module.sitenavmenu"),
		myEvents = IBM.common.util.eventCoordinator(me, "Sitenavmenu", [
			"ready"
		]),
		didScroll = false,
		didResize = false,
		menuTop,
		mouseEventWait = 250,
		sitenavMinWidth,
		$sitenavMenu,
		$sitenavMenuList,
		$itemWithSubmenu;

	/**
		Called from DOM ready via setTimeout since it's non-essential and just sets up minimal interaction and adjustments.
		<br />This sets up the menunav for stickyness, adjusts drop-down menus for right-alignment, and dynamically show/hides the links based on the browser width and if they can all fit or not.

		@method init
	**/
	me.init = function() {
		var showSubmenuTimeout,
			hideSubmenuTimeout;

		$("body").addClass("ibm-sitenav-menu");
		
		// Cache selectors.
		$sitenavMenu = $(".ibm-sitenav-menu-container");
		$sitenavMenuList = $(".ibm-sitenav-menu-list", $sitenavMenu);
		$itemWithSubmenu = $(" > ul > li.ibm-haschildlist", $sitenavMenuList);
		
		menuTop = $sitenavMenu.offset().top;

		// This is a little pointless becuase our masthead doesn't change heights, but in case it does 
		//  this ensures this will always be correct and doesn't have to match a CSS value.
		IBM.common.module.masthead.subscribe("ready", "menunav", function () {
			menuTop = $sitenavMenu.offset().top;
		});
		
		// This is for legacy/original HTML that had spans. Some people have span instead of new proper button element.
		convertSpansToButtons();
		
		// Check if the drop-down menu will be offscreen and right align it if so.
		$itemWithSubmenu.each(function(){
			var $thisLi = $(this);

			if (isOffscreen($thisLi)) {
				$thisLi.find("ul").addClass("ibm-align-right");
			}
		});

		//// BINDINGS:

		// Click on a main item (that has a submenu) button. 
		// Essentially toggles the submenu (primary use case = touch screens, secondary = mouse click).
		$("> :focusable", $itemWithSubmenu).click(function() {
			var $parentLi = $(this).parent();

			if (!$parentLi.hasClass("ibm-active")) {
				showSubmenu($parentLi);
			}
			else {
				hideSubmenu($parentLi);
			}
		});

		// If they have a mouse, open/close menus on hover actions.
		$itemWithSubmenu.hover(function () {
				var $li = $(this);
				
				clearTimeout(hideSubmenuTimeout);

				// Wait and make sure they are not just doing a fly-by.
				showSubmenuTimeout = setTimeout(function () {
					showSubmenu($li);
				}, mouseEventWait);

			}, function () {
				var $li = $(this);
				
				clearTimeout(showSubmenuTimeout);
				
				// Wait and make sure they actually want to leave.
				hideSubmenuTimeout = setTimeout(function () {
					hideSubmenu($li);
				}, mouseEventWait);
			});

		// If they mouse out of the entire menu section, wait and make sure they are leaving and close anything that's open.
		$sitenavMenuList.mouseleave(function () {
			hideSubmenuTimeout = setTimeout(function () {
				hideSubmenu($itemWithSubmenu);
			}, mouseEventWait);
		});


		//// Stickyness.

		// If they didn't disable the stickyness (default), set it up.
		if ($sitenavMenu.data("sticky") !== false) {
			$(window).scroll(function() {
				didScroll = true;
			});

			setInterval(function() {
				if (didScroll) {
					didScroll = false;
					toggleStickyMenu();
				}
			}, 10);

			// Run onload.
			toggleStickyMenu();
		}

		//// Hiding when it doesn't fit across the screen.

		// Set the minimum viewport width we need in order to show all the links.
		setSitenavMinWidth();
		
		// Bind resize to check if links still fit across and show/hide them accordingly.
		$(window).resize(function() {
			didResize = true;
		});

		setInterval(function() {
			if (didResize) {
				didResize = false;
				toggleMenuLinks();
			}
		}, 70);

		// Do initial fit check on load.
		toggleMenuLinks();

		// Add our flag that it's processed and ready. Used by CSS.
		$sitenavMenu.attr("data-widgetprocessed", true);

		// Setup a11y.
		IBM.common.util.a11y.makeMenuAccessible({
			el: $sitenavMenuList
		});

		myEvents.publish("ready");
	};

	/**
		Converts legacy HTML &lt;span> main items with submenus into the proper &lt;button> element it's supposed to be.

		@method convertSpansToButtons
		@private
	**/
	function convertSpansToButtons () {
		$.each($itemWithSubmenu.children("span"), function () {
			var attrs = "",
				$spanItem = $(this);
			
			$.each(this.attributes, function() {
				attrs += ' ' + this.name + '="' + this.value + '"';
			});
			
			$spanItem.replaceWith('<button' + attrs + '>' + $spanItem.html() + '</button>');
		});
	}

	/**
		Decides whether to show/hide the site menu nav links. Based on comparison of width needed vs. viewport width.
		<br />Called onload for initial display type, and then on resize.

		@method toggleMenuLinks
		@private
	**/
	function toggleMenuLinks () {
		if (sitenavMinWidth < $(window).width()) {
			$("body").removeClass("ibm-sitenav-menu-hide");
		}
		else {
			$("body").addClass("ibm-sitenav-menu-hide");
		}
	}

	/**
		Decides whether to make the menu nav bar sticky or not. Based on scroll position.
		<br />Called onload for initial display type, and then on scroll.

		@method toggleStickyMenu
		@private
	**/
	function toggleStickyMenu () {
		var scrollTop = $(window).scrollTop();

		if (scrollTop > menuTop) {
			$("body").addClass("ibm-sitenav-menu-sticky");
		}
		else {
			$("body").removeClass("ibm-sitenav-menu-sticky");
		}
	}

	/**
		Hides all submenus that are open and shows submenu for main item passed to it.
		<br />Called on click and hover of main item that has a submenu.

		@method showSubmenu
		@private
		@param $li {Element selector} The main item &lt;li> that we want to open submenu for.
	**/
	function showSubmenu ($li) {
		hideSubmenu($("> ul > li.ibm-active", $sitenavMenuList));
		
		if ($("ul", $li)[0]) {
			$li.addClass("ibm-active");
		}
	}

	/**
		Hides the submenu for the main item passed to it.
		
		@method hideSubmenu
		@private
		@param $li {Element selector} The main item &lt;li> that we want to hide the submenu for.
	**/
	function hideSubmenu ($li) {
		$li.removeClass("ibm-active");
	}

	/**
		Submenus are left-aligned by default. This checks if the submenu will extend offscreen (right) and return true if so.
		
		@method isOffscreen
		@private
		@param $li {Element selector} The main item &lt;li> that we want to check the submenu for positioning.
		@return {Boolean} True if it will be offscreen, else false.
	**/
	function isOffscreen ($li) {
		var $submenu = $li.addClass("ibm-active").children("ul").addClass("getwidth"),
			submenuXpos = $submenu.offset().left,
    		submenuWidth = $submenu.width();

    	//console.log($(window).width(), submenuXpos, submenuWidth);
		
		$li.removeClass("ibm-active").children("ul").removeClass("getwidth");

		// Add 3px buffer in case it's a close call.
		return submenuXpos + submenuWidth + 3 > $(window).width();
	}

	/**
		Sets the width needed to fit the menu nav bar site name + the main links across.
		<br />If you are dynamically adding/removing items, you call this afterwards to (re)set the proper width needed 
		on your new set of links so they can be shown/hidden correctly.
		
		@method setSitenavMinWidth
	**/
	me.setSitenavMinWidth = setSitenavMinWidth;
	function setSitenavMinWidth () {
		$sitenavMenu.addClass("getWidth");
		sitenavMinWidth = $(".ibm-sitenav-menu-name").outerWidth() + $(".ibm-sitenav-menu-list").outerWidth() + 65; // Add margins
		$sitenavMenu.removeClass("getWidth");
	}

	// Runs onready but put to back of the queue b/c it's not needed asap.
	$(function(){
		if ($(".ibm-sitenav-menu-container").length === 1) {
			setTimeout(me.init, 50);
		}
	});

})(jQuery, IBMCore);
;

/**

	Dynamic contact module.
	<br />Service ID: 206
	<br />
	<br />This file adds a call to the bundled core services call. 
	It requests a special dynamic contact module based on the WTMcategory value. 
	If the service returns one, it injects it in the contact module container overwriting the HTML coded one.
	<br />
	<br />Disabled by default.
	<br />
	<br />To enable: You must have a WTMcategory value and add either one of these two JS snippets to your page:
		
		IBMCore.common.util.config.set({
			dynamicContactModule: { enabled: true }
		});
		
		// or set this object property in the digitalData object in the "ibm" section:
		
		ibmDynamicCm: true
	
	@class IBMCore.www.module.dynamiccontactmodule

**/

(function ($, IBM) {

	// Create name space for this thing and make a shortcut to it for ourselves.
	var me = IBM.namespace(IBM, "www.module.dynamiccontactmodule");

	/**
		Waits for meta to be ready then adds a request to the bundled service request 
		for a contact module based on the WTMcategory value.
		
		@method init	
	**/
	me.init = function () {
		var category = (IBM.common.meta.page.category && IBM.common.meta.page.category.primaryCategory) || "";
		
		// Use new setting, but allow for old meta tag way.
		if (IBM.common.util.config.isEnabled("dynamicContactModule") || IBM.common.meta.page.pageInfo.ibm.ibmDynamicCm === true) {
			IBM.common.util.coreservices.bundledRequest.add("206", "IBMCore.www.module.dynamiccontactmodule.contactboxcallback", {
				v: 17, // v18 not setup yet.
				wtmcategory: category
			});
		}
	};

	/**
		Callback for service request.
		<br />If a contact module was returned and if the contact module container exists on the page, inject the new one into the container.
		
		@method contactboxcallback
	**/
	me.contactboxcallback = function (data) {
		// Reading json object template string to generate the HTML of contact module if the template string is not null
		// Onready, inject returned HTML into ibm-contact-module.
		if (typeof data !== "undefined" && typeof data.results !== "undefined" && data.results.templateString.length !== 0) {
			$(function() {
				var cmDiv = document.getElementById("ibm-contact-module");

				// If the contact module container exists, inject the new one.
				if (cmDiv) {
					cmDiv.innerHTML = data.results.templateString;

					// Adjust the HTML to convert it to proper v18 until they give us a v18 API option/HTML.
					
					// Change the ID name of the injected one so there's no duplicate.
					$(cmDiv).find("#ibm-contact-module").attr("id", "ibm-contact-module-dynamic");
					
					// Fix the phone item to add the proper class to it.
					$(cmDiv).find("p.ibm-phone-link").addClass("ibm-icon-nolink");
					
					// Add the "no padding" class to the link list.
					$(cmDiv).find(".ibm-live-assistance-list").addClass("ibm-padding-bottom-0");
					
					// Add the "close" button if it doesn't exist (means it got overwritten).
					if (!$(cmDiv).find("p.ibm-icononly .ibm-close-link")[0]) {
						$(cmDiv).prepend('<p class="ibm-icononly"><a href="#" class="ibm-close-link" onclick="IBMCore.common.module.contactmodule.showContactModule(false);return false;">Close</a></p>');
					}
				}
			});
		}
	};

	// Wait for META to complete (all head stuff runs) before doing anything b/c we need a couple values from it.
	IBM.common.meta.subscribe("dataReady", "contactmoduledynamic", me.init);

})(jQuery, IBMCore);
;

/**

	Carousel plug-in (slick carousel) pre-processor. 
	<br />
	<br />Sets defaults for the slick carousel plug-ing, and other random processing.
	<br />Then it simply inits the jQuery slick carousel plug-in. 
	<br />
	<br />Each immediate child element in a carousel widget is a carousel "panel".
	<br />Usage:
	
	<div data-widget="carousel"> 
		...
	</div>

	__Special case:__ In scenarios where you dynamically inject carousel HTML post page load, you can initialize the widget on your injected container like this:
	
	$("yourCarouselContainer").carousel();
	

	<br />Allowed options and values. __All values are strings__ (html standards):
	<br />__data-widget__: carousel
	<br />__data-arrows__: true | false (default)  &nbsp; // Enables arrows navigation
	<br />__data-autoplay__: true | false (default)  &nbsp; // Enables autoplay/scrolling of carousel
	<br />__data-dots__: true (default) | false  &nbsp; // Enables dots navigation
	<br />__data-infinite__: true | false (default)  &nbsp; // Enables infinite loop controls
	<br />__data-vertical__: true (default) | false  &nbsp; // Sets carousel to vertical carousel instead of horizontal
	<br />
	<br />Apis are available to control the carousel with JS. 
	<br /><br />Full official documentation is at <a href="http://kenwheeler.github.io/slick" target="_blank">http://kenwheeler.github.io/slick</a>.
	<br />
	<br />Some popular API uses:
		
	// Add a slide to the carousel, in position 0, before it:
	$('.your-element').slick('slickAdd', '<p>This is some text<p>', 0, true);
		
	// Remove the second slide from the carousel
	$('.your-element').slick('slickRemove', 1);
		
	// Goto the third slide in the carousel
	$('.your-element').slick('slickGoTo', 2);
	


	@class IBMCore.common.widget.carousel

**/

(function ($, IBM) {

    var me = IBM.namespace(IBM, "common.widget.carousel"),
    	carousels = [],
		object_name = "Carousel";

	/**
		Public jQuery plug-in definition.
		<br />Used by core v18 JS file to auto-init carousels HTML that exist on the page on DOM ready.
		<br />If you are dynamically injecting and initing a carousel post-load, call this plug-in on your injected carousel container.

		@method $.fn.carousel
		@param [settings] {Object} Settings to override defaults and element's @data-xxxx attributes.
	**/
	$.fn.carousel = function (settings) {
		return this.each(function(){
			var newCarousel = createCarousel(settings);
			
			newCarousel.init($(this));
		});
	};

	/**
		Called by our jQuery plug-in.
		<br />This creates a new carousel object and registers the instance into array of all this widget instances.
		<br />The jQuery plugin abstracts this and makes behind-the-scenes changes easy.
		
		@method createCarousel
		@private
		@param [settings] {Object} Settings to override defaults and element's @data-xxxx attributes.
		@return {Object} The carousel object instance created.
	**/
	function createCarousel (settings) {
		var widget = new Carousel(settings);
		
		carousels.push(widget);
		
		return widget;
	}
	
	/**
		Publishes this event if the widget was disabled and didn't init.
		
		@event disabled
	**/
	/**
		Publishes this event if there was an error creating the widget.
		
		@event error
	**/
	/**
		Publishes this event after the widget has been created successfully.
		
		@event ready
	**/
	/**
		Carousel object/constructor for our public jQuery plugin.
		<br />Called by "createCarousel".
		<br />You can't use this directly. Use the standard $(xxxx).carousel() plug-in method to dynamically init and create a carousel.

		@method Carousel
		@constructor
		@private
		@param [settings] {Object} Settings to override defaults and element's @data-xxxx attributes.
	**/
	function Carousel (settings) {
		var me = this,
			$container,
			config,
			defaults = {
				adaptiveheight: false,
				arrows: false,
				autoplay: false,
				autoplayspeed: 6000,
				dots: true,
				infinite: false,
                prevArrow: '<button type="button" data-role="none" class="ibm-chevron-left-regular-link ibm-textcolor-blue-50 ibm-carousel-prev" aria-label="previous">Previous</button>',
                nextArrow: '<button type="button" data-role="none" class="ibm-chevron-right-regular-link ibm-textcolor-blue-50 ibm-carousel-next" aria-label="next">Next</button>',
                variablewidth: false
			},
			defaultSlickCallbacks,
			myEvents = IBM.common.util.eventCoordinator(me, object_name, [
				"ready",
				"disabled",
				"error"
			]);

	    /**
			This is a method of the "Carousel" constructor.
			<br />Called by our public jQuery plug-in after a new Carousel object has been created and returned by "createCarousel".
			<br />Automatically inits the carousel plug-in (slick carousel) on the passed element, 
			merging in any manually passed settings, @data-xxxxx settings, and our default settings. 
			
			@method init
			@param {jQuery selector} $elem The element you want to turn into a carousel.
		**/
		me.init = init;
		function init ($elem) {
			try {
				if (!IBM.common.util.checkClearance("carousel")) {
					myEvents.publish("disabled");
					return false;
				}

				// If we're here, it means it's enabled, so build it/do your thing. 
				// Binds widget object to the DOM element it was init on by jQuery plugin method.
				// Keep "instance" as-is; ALL element-bound widgets will use this data attribute.
				$elem.data("widget", me);

				$container = $elem;

				initData();
				initHtml();

				// Fire an event to tell subscribers we're done.
				myEvents.publish("ready", $elem);

			} 
			catch (er) {
				myEvents.publish("error", er);
				throw er;
			}
		}

		/**
			This sets up the config and HTML for init'ing.

			@method initData
			@private
		**/
		function initData () {
			defaultSlickCallbacks = {
				onInit: function(slick) {
					//slick.$slides.each(function (i, el) {
					//});

					slick.$slider.addClass("ibm-carousel");
				}
			};

			// Merge configs then dupe for camelcase settings since data-attr can't do camelcase.
			config = $.extend({}, defaults, defaultSlickCallbacks, $container.data() || {}, settings);
			config.adaptiveHeight = config.adaptiveheight;
			config.autoplaySpeed = config.autoplayspeed;
			config.variableWidth = config.variablewidth;
		}

		/**
			This does the actual slick carousel init'ing.

			@method initHtml
			@private
		**/
		function initHtml () {
			$container.slick(config);
		}
	}

})(jQuery, IBMCore);
;

/**
	
	Datatable plug-in pre-processor. 
	<br />
	<br />Sets defaults for the datatable plug-in, adjusts for some data-* attributes (can't use mixed case in @data-), and other random processing to make the tables look correct. 
	<br />Then it simply inits the jQuery datatable plug-in. 
	<br />Usage:
		
	<table data-widget="datatable" data-xxxxxxx="">
	
	Allowed options and values. __All values are strings__ (html standards):
	<br />__data-widget__: datatable
	<br />__data-scrollaxis__: x  &nbsp; // Allows horizontal scroll
	<br />__data-info__: true | false (default)  &nbsp; // Shows "Showing 1-10" texts
	<br />__data-ordering__: true | false (default)  &nbsp; // Enables sorting
	<br />__data-paging__: true | false (default)  &nbsp; // Enables pagination
	<br />__data-searching__: true | false (default)  &nbsp; // Enables text filtering

	@class IBMCore.common.widget.datatable

**/

(function($, IBM) {

    var me = IBM.namespace(IBM, 'common.widget.datatable');

    /**
		Automatically called onload on any &lt;table> that has @data-widget="datatable".
		<br />Automatically inits the datatable plug-in (datatables.net) on the passed element, merging in any manually passed settings, the &lt;table> @data-xxxx settings, and our default settings. You should never call this function unless you are dynamically injecting a table "post-DOMready" and you need to initialize the table widget manually.
		<br />In the case when you are doing AJAX or dynamically injecting or changing a table, this allows for dynamic injection of a table w/o the need to add all the @data-xxxx settings just to set it up on your .init() call. You can simply pass the setting object with the element when you call .init(). You're welcome.
		<br />This also does some adjustments to make the table look right with caption element and mapping lowercase data-* attributes to their mixed-case options for the plug-in. @data-xxxx attributes are always lowercase. Mixed-case doesn't work, just like any other HTML attribute.

		@method init
		@param {jQuery selector} tableEl The &lt;table> element you want to init the datatable widget on.
		@param {Object} [passedSettings] Settings to use for the datatable widget. Optional use instead of @data-xxxx attributes on the &lt;table> when dynamically injecting a &lt;table>
    **/
    me.init = function (tableEl, passedSettings) {
        var $table = $(tableEl),
            $caption,
            // By default, have everything disabled. Page devs opt-in to any/all options they want.
            defaultSettings = {
                info: false,
                ordering: false,
                paging: false,
                responsive: true,
                searching: false,
                scrollCollapse: true
            },
            settings = defaultSettings,
            tableWidget;

        // Safety in case this is called and param object isn't passed to us.
        passedSettings = passedSettings || {};

        // Merge the settings in the proper hierarchy/priority order:            
        // Defaults get overwritten by <table> @data-xxxx, which get overwritten by manually passed settings.
        // This allows page devs to dynamically inject a datatable and not have to manually set @data-xxxx attributes just to set options.
        // They can inject the table, then call this init function and pass the settings into .init() with the table element. 
        // You're welcome.
        settings = $.extend(true, {}, defaultSettings, $table.data(), passedSettings);

        if (settings.scrollaxis) {
            if (settings.scrollaxis.indexOf("x") > -1) {
                settings.scrollX = true;
                settings.responsive = false;
            }
            if (settings.scrollaxis.indexOf("y") > -1) {
                settings.scrollY = settings.height || 200;
                settings.responsive = false;
            }
        }
        
        // Add the magic class, then init the plugin.
        // The "display" class is the magic class the datatables plugin needs to init properly.
        // We are dynamically injecting it instead of making users add it in the HTML in case it changes or new plugin is used, etc. 
        // It's part of the plug-in and not needed for styling/JS unless the plug-in is init, therefore we inject as part of plug-in init.
        tableWidget = $table.addClass("display").DataTable(settings);
        
        // If a scrolling option is set, we need to adjust the caption element.
        // After the plug-in inits move the caption to the proper place (our display table).
        // TODO: Santelia: Need to validate with Matt how this should properly be setup and work.
        if ((settings.scrollaxis) && (settings.scrollaxis.indexOf("x") > -1 || settings.scrollaxis.indexOf("y") > -1)) {
            $caption = $table.parent(".dataTables_scrollBody").siblings(".dataTables_scrollHead").children("caption");
            if ($caption[0]) {
            	$caption.addClass("ibm-access").prependTo($table);
            }
        }

        return tableWidget;
    };

})(jQuery, IBMCore);
;

/**
	
	Form validator widget.
	<br />
	<br />This is a HTML5 shim. We don't need this once we move to IE10+ support.
	<br />If enabled on a &lt;form>, it will check the validity of input, textarea, and select elements, and add an error class next to an invalid form element and focus on it... basically the same thing native HTML5 form validation does, but not as good.
	<br />
	<br />Usage
		
	<form action="______" method="______" data-formvalidator="enable">
	
	__Special case:__ In scenarios where you dynamically inject form HTML post-load, you can initialize the widget on your injected form HTML like this:
		
	IBM.common.widget.formvalidator.init($("myForm"));
		
	@class IBMCore.common.widget.formvalidator

**/

(function($, IBM) {

    var me = IBM.namespace(IBM, 'common.widget.formvalidator');

    /**
		Automatically called onload on any &lt;form> that has @data-formvalidator="enable".
		<br />Inits the form validator and binds on form submit click, keydown, paste, change of fields.
		<br />In the case that you need to inject the form dynamically and init the widget, call this function, passing it the
		 form element to enable the validator widget on.

		@method init
		@param formEl {DOM element} The &lt;form> element you want to add the validator to.

    **/
    me.init = function (formEl) {
        var firstSubmitDone = false, // semaphore for checking the input field validity automatically on user's input
            $form = $(formEl);

        $('input[type="submit"]', $form).click(function (evt) {
            var formIsValid = true;

            $('input, textarea, select', $form).each(function(){
                if (!checkInputValidity($(this))) {
                    formIsValid = false;
                }
            });

            if (typeof $form[0].checkValidity === 'undefined' && formIsValid === false) {
                evt.preventDefault();
                $form.find('p.ibm-error').eq(0).find('input, textarea, select').eq(0).focus();
            }

            firstSubmitDone = true;
        });

        // if the form submit button was already hit at least once, we are just checking input validity on the fly (not only after another submit button press)
        // because this is how the native HTML5 validation works
        $('input, textarea, select', $form).each(function(){
            $(this).on('keydown paste change', function(){
                var $that = $(this);

                if (firstSubmitDone) {
                    setTimeout(function() {
                        checkInputValidity($that);
                    }, 0);
                }
            });
        });

        /**
        	Calls markInput and checks if input is valid and marks parent &lt;p> with 'ibm-error' class in case that input is invalid.

        	@method checkInputValidity
        	@private
        	@param $input {jQuery selector} The input to check if valid.
        	@return {Boolean} If the input is valid or not.
        **/
        function checkInputValidity ($input) {
            // Native HTML5 validation
            if (typeof $input[0].checkValidity !== 'undefined') {
                return markInput($input, $input[0].checkValidity());
            }

            if ($input.is('input[type="email"]')) {
                if ($input.is('[required]') === true) {
                    return markInput($input, $input.val().search(/[A-Za-z0-9!#$%&'*+-\/=?^_`{|}~]+@[A-Za-z0-9-]+(.[A-Za-z0-9-]+)*/) !== -1);
                }
            }
            else if ($input.is('input[type="radio"], input[type="checkbox"]')) {
                var $group = $input.parents('form > p').find('input[name="{name}"]'.replace('{name}', $input.attr('name')));

                if ($group.is('[required]') === true) {
                    return markInput($input, $group.find(':checked').val());
                }
            }
            else {
                if ($input.is('[required]') === true) {
                    return markInput($input, $input.val());
                }
            }

        }

        /**
			Method to add or remove the "ibm-error" class to the input's parent &lt;p> based on if the field is valid or not.

			@method markInput
			@private
			@param $input {jQuery selector} The $input to mark as valid or not.
			@param valid {Boolean} True if field is valid, false if not.
			@return {Boolean} Returns the same "valid param that was passed".
        **/
        function markInput ($input, valid) {
            $input.parents('form > p')[valid ? "addClass" : "removeClass"]("ibm-error");

            return valid;
        }
    };

})(jQuery, IBMCore);;

/**
	
	Hi-res image swap widget
	<br />
	<br />This will swap the source of your &lt;img> element with the hi-res alternate version if the user's screen supports hi-res/retina images.
	<br />This is just a shim until the &lt;picture> HTML standard element is finalized and supported in the three major browsers.
	<br />
	<br />Usage:
	<br />Add the data-widget and data-hiresfile attributes to your image and be sure you have the hi-res image in place or else no image will show.
	<br />__IMPORTANT:__ The path/value in @data-hiresfile will completely replace the @src value. Therefore it __must__ be in the same format as your src. 
	<br />If your @src has a full path, so must the @data-hiresfile value.
		
	<img src="/some/path/to/myimage.jpg" data-widget="hiresimageswap" data-hiresfile="/some/path/to/myimage_hires.jpg" ..... />

	or

	<img src="myimage.jpg" data-widget="hiresimageswap" data-hiresfile="myimage_hires.jpg" ..... />
	
	__Special case:__ In scenarios where you dynamically inject the &lt;img> HTML post-load, you can initialize the widget on your injected &lt;img> HTML like this:
		
	$("myImgElement").hiresimageswap();
	
	@class IBMCore.common.widget.hiresimageswap

**/

(function($, IBM) {

    var me = IBM.namespace(IBM, "common.widget.hiresimageswap");

	/**
		Public jQuery plug-in definition.
		<br />Used by core v18 JS file to auto-init tagged hi-res img elements that exist on the page on DOM ready.
		<br />If you are dynamically injecting the image HTML post-load and want to enable this, call this plug-in on your injected &lt;img>.
		<br />__NOTE:__ If the user's screen does not support hi-res/retina, this does nothing and just returns the jQuery selector.

		@method $.fn.hiresimageswap
	**/
	$.fn.hiresimageswap = function () {
		if (!Modernizr.hires) {
			return this;
		}
		return this.each(function(){
			swapImage(this);
		});
	};

 	/**
		Called by our jQuery plug-in.
		<br />This simply swaps the image @src for the @data-hiresimageswap value.
		<br />The jQuery plugin abstracts this and makes behind-the-scenes changes easy.
		
		@method swapImage
		@private
		@param el {DOM element} The IMG element to swap the src value.
	**/
   function swapImage (el) {
		$(el).attr("src", $(el).data("hiresfile"));
    }

})(jQuery, IBMCore);

;

/**

	Leaving IBM widget.
	<br />
	<br />This is simply an overlay nofication that tells the user that the service they are about to engage with
	is being performed on behalf of IBM, but on a non-IBM web site.
	<br />
	<br />__Requirements__
	<br />The link's @href __must__ be prefixed with "http://www.ibm.com/links/?url=".
	<br />The link's URL (url param) __must__ be URL encoded if it contains any parameters.
	<br /> 
	<br />Usage:
		
	<a data-widget="leaving" class="ibm-external-link" href="http://www.ibm.com/links/?url=http://www.lanyrd.com">Register on Lanyrd</a>

	<br />Usage with URL with params:
		
	<a data-widget="leaving" class="ibm-external-link" href="http://www.ibm.com/links/?url=http://www.lanyrd.com%3Fsomeparam%3Dvalue%26xyz%3Dasdf">Register on Lanyrd</a>

	__Special case:__ In scenarios where you dynamically inject links that require the "leaving IBM notification" post-load, you can initialize the widget on your injected links like this:
	
	$("a#someID").leavingibm();

	@class IBMCore.common.widget.leavingibm

**/

(function($, IBM) {

	var me = IBM.namespace(IBM, "common.widget.leavingibm"),
		leavingWidgets = [],
		object_name = "LeavingIBMOverlay",
		defaults = {
			title: "Leaving the IBM Web site",
			text: "You are now leaving the IBM Web site. IBM makes no representations or warranties about any other Web site which you may access through this one. When you access non-IBM Web sites, even though they might contain the IBM logo and content regarding IBM's products and services, such Web sites are independent of IBM and IBM has no control over the operation of non-IBM Web sites. In addition, a link to a non-IBM Web site does not mean that IBM endorses that Web site or has any responsibility for the use of such Web site.",
			continueText: "Continue",
			cancelText: "Cancel",
			overlayId: "overlay-leaving-ibm"
		};

	/**
		Public jQuery plug-in definition.
		<br />Used by core v18 JS file to auto-init leaving IBM links that exist on the page on DOM ready.
		<br />If you are dynamically injecting leaving IBM links post-load, call this plug-in on your injected links that require it.

		@method $.fn.leavingibm
		@param [settings] {Object} Settings to override defaults and element's @data-xxxx attributes.
	**/
	$.fn.leavingibm = function(settings) {
		// Create the overlay on demand (on first click), for performance reasons.
		return this.click(function (evt) {
			// If we haven't init this link already (created the overlay for it) do it.
			if (!$(this).data("widget").overlay) {
				var d = createLeavingOverlay(settings);
				d.init($(this));
			}

			// Otherwise, it's already been setup (clicked once and abandoned), so just show it.
			$(this).data("widget").overlay.show();
			evt.preventDefault();
		});
	};

	/**
		Called by our jQuery plug-in.
		<br />This creates a new leaving IBM overlay widget and registers the instance into array of all this widget instances.
		<br />The jQuery plugin abstracts this and makes behind-the-scenes changes easy.
		
		@method createLeavingOverlay
		@private
		@param [settings] {Object} Settings to override defaults and element's @data-xxxx attributes.
		@return {Object} The widget object instance created.
	**/
	function createLeavingOverlay(settings) {
		var newWidget = new LeavingIBMOverlay(settings);
		leavingWidgets.push(newWidget);
		return newWidget;
	}
	
	/**
		Publishes this event if the widget was disabled and didn't init.
		
		@event disabled
	**/
	/**
		Publishes this event if there was an error creating the widget.
		
		@event error
	**/
	/**
		Publishes this event after the widget has been created successfully.
		
		@event ready
	**/
	/**
		Leaving IBM overlay object/constructor for our public jQuery plugin.
		<br />Called by "createLeavingOverlay".
		<br />You can't use this directly. Use the standard $(xxxx).leavingibm() plug-in method to dynamically turn your
		 select list jump form into the widget.

		@method JumpForm
		@constructor
		@private
		@param [settings] {Object} Settings to override defaults and element's @data-xxxx attributes.
	**/
	function LeavingIBMOverlay(settings) {
		var me = this,
			$overlay, // The generated dialog element
			$trigger, // The link(s) which will trigger this dialog
			overlay, // IBMCore.common.widget.overlay object
			config,
			rawUrl, // External URL this link goes to
			leavingIbmUrl, // Url to ibm.com/links page which passes the external url as a param. 
			myEvents = IBM.common.util.eventCoordinator(me, object_name, [
				"ready",
				"disabled",
				"error"
			]);

	    /**
			This is a method of the "LeavingIBMOverlay" constructor.
			<br />Called by our public jQuery plug-in after a new leaving IBM object has been created and returned by "createLeavingOverlay".
			<br />Automatically inits the leavigibm plug-in on the passed link(s), 
			 merging in any manually passed settings, @data-xxxxx settings, and our default settings. 
			
			@method init
			@param $elem {jQuery selector} The link you want to enable the leaving IBM notification widget on.
		**/
		me.init = init;
		function init($elem) {
			try {
				if (!IBM.common.util.checkClearance("leaving_ibm_overlay")) {
					myEvents.publish("disabled");
					return false;
				}

				$elem.data("widget", me);

				$trigger = $elem;

				// Change defaults to the current page locale's translations.
				// NOTE: "continue" and "cancel" are different b/c they will throw script errors so they are set differntly.
				$.extend(true, defaults, {
					title: IBM.common.translations.data.v18main.leaving.LEAVING001,
					text: IBM.common.translations.data.v18main.leaving.LEAVING002,
					continueText: IBM.common.translations.data.v18main.misc.continueText,
					cancelText: IBM.common.translations.data.v18main.misc.cancelText
				});


				// Merge in the options in proper hierarchy order.
				config = $.extend({}, defaults, $trigger.data("options") || {}, settings);

				overlay = IBM.common.widget.overlay.createOverlay({
					contentHtml: overlayHtml(config),
					classes: "ibm-leaving-overlay ibm-overlay-alt"
				});

				overlay.init();

				$overlay = $("#" + overlay.getId());

				// Public variable
				me.overlay = overlay;

				initData();
				initEvents();

				// Fire an event to tell subscribers we're done.
				myEvents.publish("ready");

			}
			catch (er) {
				myEvents.publish("error", er);
				throw er;
			}
		}

	    /**
			This is a method of the "LeavingIBMOverlay" constructor.
			<br />Takes the passed settings variables and returns the overlay HTML using them. 
			
			@method overlayHtml
			@private
			@param setting {Object} Object with title, text, cancel and continue values to put into overlay HTML template.
		**/
		function overlayHtml(settings) {
			var html = '<h4 class="ibm-bold">' + settings.title + '</h4><p>' + settings.text + '</p><div class="ibm-rule"><hr /></div><div class="ibm-buttons-row ibm-center"><form><p class="ibm-btn-row"><input class="ibm-btn-cancel-sec" name="ibm-cancel" value="' + settings.cancelText + '" type="submit" /><span class="ibm-sep">&nbsp;</span><input class="ibm-btn-arrow-pri" name="ibm-continue" value="' + settings.continueText + '" type="submit" /></p></form>';

			return html;
		}

	    /**
			This is a method of the "LeavingIBMOverlay" constructor.
			<br />Parses link URL and sets raw URL variable; the URL to goto on "continue".
			
			@method initData
			@private
		**/
		function initData() {
			var url = $trigger.attr("href");

			leavingIbmUrl = url;

			rawUrl = extractUrl(url);
		}

		/**
			This is a method of the "LeavingIBMOverlay" constructor.
			<br />Sets up events bindings for overlay and fires metrics.
			
			@method initEvents
			@private
		**/
		function initEvents() {
			// Fire the show event
			overlay.subscribe("show", "ibm-leaving", function() {
				IBM.common.util.statshelper.fireEvent({
					'ibmEV': 'overlay',
					'ibmEvAction': 'show',
					'ibmEvTarget': rawUrl, // URL
					'ibmEvGroup': 'Leaving IBM', // group
					'ibmEvLinkTitle': $trigger.text() // title of the page
				});
			});

			// Fire the close event
			overlay.subscribe("hide", "ibm-leaving", function() {
				IBM.common.util.statshelper.fireEvent({
					'ibmEV': 'overlay',
					'ibmEvAction': 'close',
					'ibmEvTarget': rawUrl, // URL
					'ibmEvGroup': 'Leaving IBM', // group
					'ibmEvLinkTitle': $trigger.text() // title of the page
				});
			});

			// Fire the external link event & open the url
			$overlay.on("click", ".ibm-btn-arrow-pri", function(e) {
				e.preventDefault();

				IBM.common.util.statshelper.fireEvent({
					'ibmEV': 'external link',
					'ibmEvAction': rawUrl,
					'ibmEvTarget': rawUrl, // URL
					'ibmEvGroup': 'Leaving IBM' // group
				});

				// Open the url in either this window or a new one. 
				// Hide the overlay if it's another window so it's not still open when they come back to this window.
				if (typeof $trigger.attr("target") !== "undefined") {
					window.open(rawUrl, $trigger.attr("target"));
					overlay.hide();
				}
				else {
					location.href = rawUrl;
				}
			});

			// Cancel button closes the overlay
			$overlay.on("click", ".ibm-btn-cancel-sec", function(e) {
				e.preventDefault();

				overlay.hide();
			});
		}


	    /**
			This is a method of the "LeavingIBMOverlay" constructor.
			<br />Parses link URL from @href and returns the decoded URL to goto.
			
			@method extractUrl
			@private
		**/
		function extractUrl(url) {
			var pos = url.indexOf('url='),
				pos2 = url.indexOf('ibm.com/links');

			if (pos !== -1 && pos2 !== -1 && pos2 < pos) {
				url = url.substr(pos + 4);
			}

			return decodeURIComponent(url);
		}

	}

})(jQuery, IBMCore);;

/**
	
	Overlay widget.
	<br />
	<br />Automatically creates an overlay using the div/element's contents as the overlay contents. 
	<br />This simply turns the element into an overlay. A common method is available to show the overlay by simply calling it
	 and passing it the ID of the overlay that you want to open.
	<br />Overlay HTML has been simplified for v18.
	<br />Usage:
		
	<div class="ibm-common-overlay" data-widget="overlay" id="__someID__">
		<p>My overlay content here.</p>
	</div>
	
	__Special case:__ In scenarios where you dynamically inject overlay HTML post-load, you can initialize the widget on your injected overlay HTML like this:
		
	$("#myOverlayDivID").overlay();
		
	@class IBMCore.common.widget.overlay

**/

/**

	TODO (Santelia): 
		1. Check full-width overlay width setting. Don't need to set width on .content.
		
		Still fix these?:
		1. Change resize fix to remove max-height when space is bigger than content?
		2. Add a way to reset the height then reposition overlay. Use case: Dynamically changing content in overlay and need to reset the overlay height. - Use that instead of grabbing orig height for resize.
		Reset by removing the max-height then get the height and use that as max-height.
	
 */
(function ($, IBM) {

	/* Variables.
	***************************************************************************************/
	// Create our namespace and make a shortcut to it for ourselves, 
	//  and set all glob vars for each object instance.
	var me = IBM.namespace(IBM, "common.widget.overlay"),
		$overlayBackdrop,
		overlays = [],
		open_overlays = {},
		stack = [];
		//overlayBackdropTriggerClass = "ibm-overlay-backdrop-trigger",
		//overlayBackdropTriggerRelativeClass = "ibm-overlay-backdrop-trigger-relative";

	
	/**
		Public jQuery plug-in definition.
		<br />Used by core v18 JS file to auto-init overlay HTML that exist on the page on DOM ready.
		<br />If you are dynamically injecting overlay HTML post-load, call this plug-in on your injected overlay container.

		@method $.fn.overlay
		@param [settings] {Object} Settings to override defaults and element's @data-xxxx attributes.
	**/
	$.fn.overlay = function () {
		// NOTE: "this" here is the $selector ARRAY (the jquery instance array, NOT each element!):  $(".ibm-blahblah").overlay();
		return this.each(function(){
			// NOTE: "this" here is a DOM element from the jquery "each" of this:  $(".ibm-blahblah").overlay();
			// Create the overlay widget for this $el and init it. (just does prepping).
			var widget = createOverlay({
				$overlay: $(this)
			});
			widget.init(this);
		});
	};

	// Helpers.
	// Since we rewrite & remove the original overlay, we need to map the original ID/el to our new overlay HTML we injected. 
	// These translates the original ID from original overlay HTML to the new widget object.
	// This is how page devs use these:  onclick="IBMCore.common.widget.overlay.show("__overlayID__");
	
	/**
		Debugging: Loop thru each overlay in the "registered overlays" array console out all registered overlays.

		@method consoleAll
	**/
	me.consoleAll = function () {
		$.each(overlays, function(){
			console.log(this);
		});
	};
	
	/**
		Public API to destroy an overlay. Simply gets the widget for the named ID and calls object destroy method.
		<br />This will restore the overlay's HTML to it's original coded HTML as it was on plug-in init and return
		<br />The element with the passed ID (the original coded overlay element).
		<br />If the overlay was dynamically generated via contentHtml and no HTML DOM element was injected, it simply removes the dynamic overlay element from the DOM.
		
		@method destroy
		@return (jQuery Object) The original coded HTML overlay DOM element (via the ID you called destroy with) if exists.
	**/
	me.destroy = function (id) {
		me.getWidget(id).destroy();

		return $("#" + id);
	};
	
	/**
		Api to get a particular overlay widget instance via original DOM element ID.
		Allows you to get the overlay widget object instance using your original @id since it gets wrapped and attached to
		 a special div@id. Prevents needing to know what that dynamic/auto gen'd ID is and removes dependency on it
		  in the case that we change it. Thanks to John Zimmermann for this idea.

		@method consoleAll
	**/
	me.getWidget = function (id) {
		return $("#"+id).closest("[data-widget='overlay container']").data("widget");
	};
	
	/**
		Hide the specified overlay, via named ID.

		@method hide
		@param id {String} The value of the @id of the overlay div to hide.
	**/
	me.hide = function (id) {
		$("#"+id).closest("[data-widget='overlay container']").data("widget").hide();
	};
	
	/**
		Loop thru each overlay in the "registered overlays" array and hide it.

		@method hideAllOverlays
	**/
	me.hideAllOverlays = function () {
		$.each(overlays, function(){
			this.hide(true);
		});
	};
	
	/**
		Public method/utility to show the specified overlay, via named ID.

		@method show
		@param id {String} The value of the @id of the overlay div to show.
	**/
	me.show = function (id) {
		$("#"+id).closest("[data-widget='overlay container']").data("widget").show();
	};
	
	/**
		Called by our jQuery plug-in.
		<br />Alternate way to create an overlay - Dynamically create one, like doing "new overlay()".
		<br />This creates a new overlay widget and registers the instance into array of all this widget instances.
		<br />The jQuery plugin abstracts this and makes behind-the-scenes changes easy.
		
		@method createOverlay
		@private
		@param [settings] {Object} Settings to override defaults and element's @data-xxxx attributes.
		@return {Object} The widget object instance created.
	**/
	me.createOverlay = createOverlay;
	function createOverlay (settings) {
		var ov = new Overlay(settings);
		overlays.push(ov);
		return ov;
	}

	/**
		Fire a stats event for this widget.
		
		@method fireStatsEvent
		@private 
		@param eventType {String} Type of event that happened.
		@param id {String} The ID of the widget it happened on.
	**/
	function fireStatsEvent (eventType, id) {
		IBM.common.util.statshelper.fireEvent({
			"ibmEV" : "widget",
			"ibmEvGroup" : "Overlay",
			"ibmEvName" : eventType,
			"ibmEvAction" : id
		});
	}

	/**
		Shows/hides the "screen" and sets it's opacity.

		@method updateBackdrop
		@private
	**/
	function updateBackdrop () {
		if (stack.length === 0) {
			$overlayBackdrop.hide();
			IBM.common.util.freezeScrollbars(false);
		}
		else {
			var max = 0,
				i,
				dd,
				len = stack.length;
				
			for (i = 0; i < len; i++) {
				dd = stack[i];
				max = Math.max(max, dd.backdrop_opacity);
			}
			
			$overlayBackdrop.css("opacity", max);
			//console.log("backdrop_opacity: " + stack[stack.length - 1].backdrop_opacity);
			
			$overlayBackdrop.show();
			IBM.common.util.freezeScrollbars(true);
		}
	}
	
	/**
		Publishes this event if the background color changes.
		@event background-change
	**/
	/**
		Publishes this event after the overlay is hidden.
		@event hide
	**/
	/**
		Publishes this event after the trigger is clicked, but before the actual "showing" of the overlay.
		@event pre-show
	**/
	/**
		Publishes this event if the overlay is resized.
		@event resize
	**/
	/**
		Publishes this event after the overlay is shown.
		@event show
	**/
	/**
		Overlay object/constructor for our public jQuery plugin.
		<br />Called by "createOverlay".
		<br />You can't use this directly. Use the standard $(xxxx).overlay() plug-in method to turn your overlay HTML into an overlay widget.

		@method Overlay
		@constructor
		@private
		@param [settings] {Object} Settings to override defaults and element's @data-xxxx attributes.
	**/
	function Overlay (settings) {
		// Merge the settings in the appropriate hierarchy per documentation:
		//   Defaults get overidden by html @data-attrs (.data()) which get overridden by explicit params in the JS call.
		var defaults =  {
				$overlay: null,
				allowResize: true,
				arialabel: "Overlay content",
				ariadescribedby: true,
				backdropopacity: 0.5,
				backgroundcolor: null,
				classes: "",
				contentHtml: null,
				//delay: 0,
				fullwidth: false,
				hidexscroll: false,
				id: "ibm-overlaywidget-" + ($("[data-widget='overlay container']").length + 1),
				//direction: "bottom",
				//positioner: null,
				//trigger: null,
				name: "",
				titled: false
			},
			$overlayDataAttrs = settings.$overlay ? settings.$overlay.data() : {},
			
			// Merge the settings in the proper hierarchy order.			
			appliedSettings = $.extend(true, defaults, $overlayDataAttrs, settings),
			
			// Start our common vars.
			me = this,
			myEvents = IBM.common.util.eventCoordinator(me, "Overlay", [
				"show",
				"hide",
				"pre-show",
				"background-change",
				"direction-change",
				"positioner-change",
				"resize"
			]),
			$closer,
			$content,
			$overlay = appliedSettings.$overlay,
			//$last_used_trigger = null,
			//$positioner = appliedSettings.positioner,
			//$prefocuser,
			//$refocuser,
			//$tip,
			active_class = "active",
			custom_color = appliedSettings.backgroundcolor,
			//delay = appliedSettings.delay,
			//direction = appliedSettings.direction,
			is_first_hide = true,
			is_first_show = true,
			//is_masthead_overlay = false,
			is_open = false,
			last_dim = {
				x : 0,
				y : 0,
				w : 0,
				h : 0
			},
			loop_count = 0,
			loop_limit = 20,
			on_hide_fns = [],
			on_show_fns = [],
			overlayClasses = "ibm-common-overlay " + appliedSettings.classes,
			prepped_class = "prepped",
			//triangleTip,
			//triggers = [],
			returnFocusEl,
			z_index = 0;

		// If the overlay exist, use the ID and classes from it.
		if ($overlay) {
			if ($overlay.attr("id") !== "") {
				appliedSettings.id = "ibm-overlaywidget-" + $overlay.attr("id");
			}

			overlayClasses = $overlay.attr("class");
		}

		// Set public stuff.
		me.backdrop_opacity = appliedSettings.backdropopacity;
		me.id = appliedSettings.id;
		
		/**
			This is a method of the "Overlay" constructor.
			<br />This will hide and destroy the overlay, and restore any coded overlay HTML back to it's original
			<br />state as it was when the overlay widget was init on it.
			
			@method destroy
		**/
		me.destroy = function () {
			hide();
			
			$("#" + me.id).remove();

			$(me.restore.placeholder).after(me.restore.origEl).remove();

			$.each(overlays, function(i){
				if (this.id === me.id) {
					overlays.splice(i, 1);
				}
			});
		};

		/**
			This is a method of the "Overlay" constructor.
			<br />Called by our public jQuery plug-in after a new overlay object has been created and returned by "createOverlay".
			<br />Automatically inits the overlay plug-in merging in any manually passed settings, 
			 @data-xxxxx settings, and our default settings. 
			
			@method init
		**/
		me.init = function () {
			// Currently wrapping contentHtml, or an existing v17 coded overlay in the new wrapper.
			// Should we require new HTML for overlay and ditch old stuff?
			var template = '<div class="" id="$id" role="dialog" aria-describedby="$id-content" aria-label="$ariaLabel" data-widget="overlay container" data-name="$name"><div class="ibm-overlay-heading-con"><p class="ibm-icononly"><a href="#" class="ibm-close-link" role="button">Close</a></p></div><div id="$id-content" class="content">$overlayContent</div></div>',
				html = template.replace('$name', appliedSettings.name).replace(/\$id/g, me.id).replace('$ariaLabel', appliedSettings.arialabel),
				didResize = false;
				
			// Add a restore point to return the HTML back to it's originally coded element.
			me.restore = {
				placeholder: $('<div class="overlayrp"></div>').insertAfter($overlay),
				origEl: appliedSettings.contentHtml || $overlay.clone()
			};

			// If they specified HTML, use that, else use this overlay $el as the content.
			// Santelia TODO: Can we change the standard HTML for v18 to be this and ditch v17/16 HTML instead of wrapping it?
			if (appliedSettings.contentHtml) {
				html = html.replace("$overlayContent", appliedSettings.contentHtml);
			}
			else {
				html = html.replace("$overlayContent", $overlay.attr("class", "").clone().wrap("<div/>").parent().html());
			}
			
			//// IMPORTANT NOTE: These three steps make shit work the way we want:
			// 1. Remove the original overlay HTML DOM,
			// 2. Inject our new cloned/wrapped overlay HTML and attach this Overlay object/instance to the new DOM el.
			// 3. Reset the $overlay to the new DOM el we just injected.
			if ($overlay) {
				$overlay.remove();
			}
			$overlay = $(html).addClass(overlayClasses).appendTo("#ibm-com").data("widget", me);

			// If they don't want the aria-described by, remove the attribute. The only time you don't need is is if there's no content before the focusable element.
			if (appliedSettings.ariadescribedby === false) {
				$overlay.removeAttr("aria-describedby");
			} 
			
			//triangleTip = IBM.common.widget.triangletip.createTriangletip($overlay); // Returns object.
			
			// Setup shortcuts.
			//$tip = $(triangleTip.elem);
			$closer = $(".ibm-overlay-heading-con a.ibm-close-link", $overlay);
			//$refocuser = $("a.refocuser", $overlay);
			//$prefocuser = $("a.prefocuser", $overlay);
			$content = $("div.content [data-widget='overlay']", $overlay);
			
			// If they generated the overlay programatically and didn't use data-widget attribute, 
			// Set the content to be the .content div directly instead of their DIV they init'd the plugin on.
			if ($("div.content [data-widget='overlay']", $overlay).length === 0) {
				$content = $("div.content", $overlay);
			}

			if (appliedSettings.fullwidth) {
				$overlay.addClass("full-width");
			}

			// Get and set translated text for "close".
			if ($("a.ibm-common-overlay-close", $content).length === 1) {
				$closer.html($overlay.find("a.ibm-common-overlay-close").html());
			}
			else {
				IBM.common.translations.subscribe("dataReady", "Overlay", function(){
					$closer.html(IBM.common.translations.data.v18main.misc.close);
				}).runAsap(function(){
					$closer.html(IBM.common.translations.data.v18main.misc.close);
				});
				
			}
			
			// Attach my tip to me.
			//me.tip = triangleTip;
			//me.$tip = $tip;

			if (appliedSettings.seamless) {
				seamless(true);
			}

			if (appliedSettings.titled) {
				titled(true);
			}

			//setDirection(direction);

			if (typeof appliedSettings.width !== "undefined") {
				setWidth(appliedSettings.width);
			}

			if (typeof appliedSettings.height !== "undefined") {
				setHeight(appliedSettings.height);
			}
			
			if (custom_color) {
				setBackground(custom_color);
			}

			if (appliedSettings.hidexscroll) {
				$content.addClass("hidexscroll");
			}

			/**
			if (appliedSettings.trigger) {
				addTrigger(appliedSettings.trigger);
			}
			**/

			// Do bindings.
			$closer.click(function (evt) {
				evt.preventDefault();
				hide();
			});
			
			// Setup position adjustment on scroll or resize.
			$(window).on("scroll resize", function () {
				didResize = true;
			});

			setInterval(function() {
				if (didResize) {
					didResize = false;
					
					if (isOpen()) {
						setPosition();
					}
				}
			}, 50);

			// For proper a11y, set the tabindex on the content div so it's focused and
			// screen readers start reading content from the top.
			// Then on close/hide, remove it from tab ring.
			myEvents.subscribe("show", "Overlay init", function(){
				$overlay.find(".content").attr("tabindex",0).focus();
			});

			// On overlay hide, change tab index and pause any videos.
			myEvents.subscribe("hide", "Overlay init", function(){
				$overlay.find(".content").attr("tabindex", -1);

				if ($overlay.find("[data-widget=videoplayer]").data("widget") && $overlay.find("[data-widget=videoplayer]").data("widget").pauseVideo) {
					$overlay.find("[data-widget=videoplayer]").data("widget").pauseVideo();
				}
			});

			// Setup tab ring for accessibility. 
			// If they tab forward on the last content link, focus on the closer.
			// If they tab backward from the closer focus on the last content link
			$overlay.on("keydown", function (evt) {
				var $lastLink = $(":focusable:last", $overlay),
					$firstLink = $(":focusable:first", $overlay); // Close link.
				
				if (evt.keyCode === 9 && !evt.shiftKey && $(evt.target).is($lastLink)) {
					evt.preventDefault();
					$firstLink.focus();
				}
				else if (evt.keyCode === 9 && evt.shiftKey && $(evt.target).is($firstLink)) {
					evt.preventDefault();
					$lastLink.focus();
				}
			});

		};

		/**
			This is a method of the "Overlay" constructor.
			<br />Returns the ID of this overlay widget instance.

			@method getId
			@return {String} The @ID of the overlay widget.
		**/
		me.getId = function () {
			return me.id;
		};

		/**
		me.getPositioner = getPositioner;
		function getPositioner() {
			return $positioner;
		}
		**/

		/**
		me.closer = closer;
		function closer() {
			if (arguments.length === 0) {
				return $closer;
			}
			$overlay[arguments[0] ? "removeClass" : "addClass"]("no-closer");
			return me;
		}
		**/

		/**
		me.addTrigger = addTrigger;
		function addTrigger($el) {
			triggers.push($el);
			$el.click(function () {
				$last_used_trigger = $el;
				toggle();
			});
		}

		me.removeTriggers = removeTriggers;
		function removeTriggers() {
			triggers = [];
		}

		me.getTriggers = getTriggers;
		function getTriggers() {
			return triggers;
		}
		**/

		/**
			This is a method of the "Overlay" constructor.
			<br />Inserts the provided content HTML into the overlay in the proper place.
			<br />If the overlay is open, it will reposition it according to the new content/size.
			<br />If passed an empty string (not null), it will hide the overlay.

			@method setHtml
			@param html {String} HTML (content) to put in the overlay.
			@return {Object} The overlay widget object (me).
		**/
		me.setHtml = setHtml;
		function setHtml (html) {
			$content.html(html);

			if (isOpen()) {
				setPosition();
			}
			
			if (html === "") {
				hide();
			}
			return me;
		}

		/**
			This is a method of the "Overlay" constructor.
			<br />Sets the width of the overlay using the given # (in px), and will reposition it according to the new size.

			@method setWidth
			@param [px] {Integer} The width in px to set overlay to. If none given (null), it sets it to "auto".
			@return {Object} The overlay widget object (me).
		**/
		me.setWidth = setWidth;
		function setWidth (px) {
			px = typeof px !== "undefined" ? px + "px" : "auto" ;

			$content.css("width", px);

			setPosition();

			return me;
		}

		/**
			This is a method of the "Overlay" constructor.
			<br />Sets the height of the overlay using the given # (in px), and will reposition it according to the new size.

			@method setHeight
			@param [px] {Integer} The height in px to set overlay to. If none given (null), it sets it to "auto".
			@return {Object} The overlay widget object (me).
		**/
		me.setHeight = setHeight;
		function setHeight (px) {
			px = typeof px !== "undefined" ? px + "px" : "auto" ;
			
			$content.css("height", px);

			setPosition();

			return me;
		}

		/**
			This is a method of the "Overlay" constructor.
			<br />Sets the background color of the overlay using the given RGB string and will set the text color to the appropriate
			 accessible opposite color (black or white) based on that background color.

			@method setBackground
			@param rgb {String} The RGB string for the color to set the background to.
			@return {Object} The overlay widget object (me).
		**/
		me.setBackground = setBackground;
		function setBackground (rgb) {
			var newColorSet = IBM.common.util.color.createColor(rgb),
				newBackground = newColorSet.rgba();
			
			$overlay.css({
				//"color": newColorSet.accessibleTextColor,
				"backgroundColor": newBackground
			});

			// Add class to overlay to denote what color the text should be and control it in the CSS.
			// This function ^ is only called if a custom color is used. Otherwise we know it's black text.
			$overlay.addClass("ibm-overlay-text-" + newColorSet.accessibleTextColor);
			
			//triangleTip.setColor(rgb);

			custom_color = newBackground;

			myEvents.publish("background-change");

			return me;
		}

		/**
		me.setDirection = setDirection;
		function setDirection(dir) {
			direction = dir;

			var main_directions = [
				"top",
				"right",
				"bottom",
				"left"
			];

			$.each(main_directions, function() {
				$overlay.removeClass(this);

				if (direction.indexOf(this) === 0) {
					triangleTip.setDirection(this);
					$overlay.addClass(this);
				}
			});

			// For the tip color.. since direction matters
			if (custom_color) {
				setBackground(custom_color);
			}

			if (isOpen()) {
				setPosition();
			}

			myEvents.publish("direction-change");

			return me;
		}
		**/

		/**		
		me.setPositioner = setPositioner;
		function setPositioner($el) {
			$positioner = $el;

			if (isOpen()) {
				setPosition();
			}

			myEvents.publish("positioner-change");

			return me;
		}
		**/

		/**  This is the original with direction functionality. Too complicated for Alpha. Revisit later. Updated simplier function is next.

		me.setPosition = setPosition;
		function setPosition() {
			//var pc = getDimensionsPosition($positioner),
			var max_width = 0,
				max_height = 0;

			//console.log("pc: (" + pc.x + ", " + pc.y + ") "+pc.w+"x"+pc.h);

			var starting_dimension = getDimensionsPosition($overlay),
				min_dim = {
					w : 50,
					h : 50
				},
				window_margin = 10,
				//positioner_margin = 10,
				closer_margin = 20,
				full_width_margin = 10,
				masthead_height = 40,
				extra_right_margin = 20,
				win = getWindowDimensions();

			// Max Width
			switch (direction) {
				case "top":
					break;
				case "top-left":
					break;
				case "top-right":
					break;
				case "bottom":
					break;
				case "bottom-left":
					break;
				case "bottom-right":
					max_width = win.w - ((window_margin + extra_right_margin) * 2);
					break;

				case "left":
					break;
				case "left-top":
					break;
				case "left-bottom":
					max_width = pc.x - (window_margin + extra_right_margin) - positioner_margin;
					break;

				case "right":
					break;
				case "right-top":
					break;
				case "right-bottom":
					max_width = win.w - (pc.x + pc.w + (window_margin + extra_right_margin) + positioner_margin);
					break;
			}

			max_width = Math.max(min_dim.w, max_width);

			if (appliedSettings.fullwidth) {
				max_width = win.w - (full_width_margin * 2);
				$content.css("width", max_width + "px");
			}

			$content.css("maxWidth", max_width + "px");

			//Max Height
			switch (direction) {
				case "left":
					break;
				case "left-top":
					break;
				case "left-bottom":
					break;
				case "right":
					break;
				case "right-top":
					break;
				case "right-bottom":
					max_height = win.h - masthead_height - (window_margin * 2);
					break;

				case "top":
					break;
				case "top-left":
					break;
				case "top-right":
					max_height = pc.y - window_margin - masthead_height;
					break;

				case "bottom":
					break;
				case "bottom-left":
					break;
				case "bottom-right":
					max_height = win.h - (pc.y + pc.h + window_margin * 2);
					break;
			}

			max_height = Math.max(min_dim.h, max_height);

			if (appliedSettings.full_height) {
				//max_height = win.h - (masthead_height + positioner_margin + full_width_margin);
				max_height = win.h - (masthead_height + full_width_margin);
				$content.css("height", max_height + "px");
			}

			$content.css("maxHeight", max_height + "px");

			// "dc" = "overlay coordinates"
			// "pc" = "positioner coordinates"
			var overlayDimensions = getDimensionsPosition($overlay),
				overlayDimensions_offset = {
					x : 0,
					y : 0
				},
				tip = {
					t : "auto",
					r : "auto",
					b : "auto",
					l : "auto",
					w : 0, //8,
					m : 10 + triangleTip.getSize()
				};

			// Position Coordinates

			// center position
			switch (direction) {
				case "top":
					break;
				case "top-left":
					break;
				case "top-right":
					overlayDimensions.x = pc.x + (pc.w / 2) - (overlayDimensions.w / 2);
					overlayDimensions.y = pc.y - positioner_margin - overlayDimensions.h;
					break;

				case "bottom":
					break;
				case "bottom-left":
					break;
				case "bottom-right":
					overlayDimensions.x = pc.x + (pc.w / 2) - (overlayDimensions.w / 2);
					overlayDimensions.y = pc.y + pc.h + positioner_margin;
					break;

				case "right":
					break;
				case "right-top":
					break;
				case "right-bottom":
					overlayDimensions.x = pc.x + pc.w + positioner_margin;
					overlayDimensions.y = pc.y + (pc.h / 2) - (overlayDimensions.h / 2);
					break;

				case "left":
					break;
				case "left-top":
					break;
				case "left-bottom":
					overlayDimensions.x = pc.x - overlayDimensions.w - positioner_margin;
					overlayDimensions.y = pc.y + (pc.h / 2) - (overlayDimensions.h / 2);
					break;
			}

			// special offsets
			switch (direction) {
					// X
				case "top-left":
					overlayDimensions_offset.x =  - ((overlayDimensions.w / 2) - (tip.w / 2) - tip.m);
					break;

				case "top-right":
					overlayDimensions_offset.x = (overlayDimensions.w / 2) - (tip.w / 2) - tip.m;
					break;

				case "bottom-left":
					overlayDimensions_offset.x =  - (overlayDimensions.w / 2) + closer_margin + (tip.w / 2) + tip.m;
					break;

				case "bottom-right":
					overlayDimensions_offset.x = (overlayDimensions.w / 2) - (tip.w / 2) - tip.m;
					break;

					// Y
				case "left-top":
					overlayDimensions_offset.y =  - (overlayDimensions.h / 2) + (tip.w / 2) + tip.m;
					break;

				case "left-bottom":
					overlayDimensions_offset.y = (overlayDimensions.h / 2) - closer_margin - (tip.w / 2) - tip.m;
					break;

				case "right-top":
					overlayDimensions_offset.y =  - ((overlayDimensions.h / 2) - (tip.w / 2) - tip.m);
					break;

				case "right-bottom":
					overlayDimensions_offset.y = (overlayDimensions.h / 2) - (tip.w / 2) - tip.m;
					break;
			}

			// Min/Max Offsets (keeping it inside the window)
			var min = 0,
				max = 0;

			// X offset
			switch (direction) {
				case "top":
					break;
				case "top-left":
					break;
				case "top-right":
					break;
				case "bottom":
					break;
				case "bottom-left":
					break;
				case "bottom-right":
					min =  - (overlayDimensions.x - (window_margin + extra_right_margin));
					max = win.w - (overlayDimensions.x + overlayDimensions.w) - (window_margin + extra_right_margin);
					break;
			}

			// sanity check, but should be impossible
			if (min > max) {
				console.warn("overlay offset.x min > max.. How??");
				min = 0;
				max = 0;
			}

			min = Math.min(min, (overlayDimensions.w / 2) - tip.m);
			max = Math.max(max,  - ((overlayDimensions.w / 2) - tip.m));
			overlayDimensions_offset.x = Math.min(max, Math.max(min, overlayDimensions_offset.x));

			// Y offset
			min = 0;
			max = 0;
			switch (direction) {
				case "left":
					break;
				case "left-top":
					break;
				case "left-bottom":
					break;
				case "right":
					break;
				case "right-top":
					break;
				case "right-bottom":
					min =  - (overlayDimensions.y - window_margin - masthead_height);
					max = win.h - (overlayDimensions.y + overlayDimensions.h) - window_margin;
					break;
			}

			// sanity check, but should be impossible
			if (min > max) {
				console.warn("overlay offset.y min > max.. How??");
				min = 0;
				max = 0;
			}

			min = Math.min(min, (overlayDimensions.h / 2) - tip.m);
			max = Math.max(max,  - ((overlayDimensions.h / 2) - tip.m));
			overlayDimensions_offset.y = Math.min(max, Math.max(min, overlayDimensions_offset.y));

			if (appliedSettings.fullwidth) {
				//overlayDimensions_offset.x = (win.w / 2) - (pc.x + (pc.w / 2));
				overlayDimensions_offset.x = (win.w / 2);
			}

			overlayDimensions.x += overlayDimensions_offset.x;
			overlayDimensions.y += overlayDimensions_offset.y;

			$overlay.css({
				"left": overlayDimensions.x + "px",
				"top": overlayDimensions.y + "px"
			});

			console.log("Overlay set to: left:" + overlayDimensions.x, " || top:" + overlayDimensions.y);


			// Tip Coordinates
			switch (direction) {
				case "bottom":
					break;
				case "bottom-left":
					break;
				case "bottom-right":
					tip.l = ((overlayDimensions.w / 2) - overlayDimensions_offset.x) + "px";
					tip.b = "100%";
					break;

				case "top":
					break;
				case "top-left":
					break;
				case "top-right":
					tip.l = ((overlayDimensions.w / 2) - overlayDimensions_offset.x) + "px";
					tip.t = "100%";
					break;

				case "right":
					break;
				case "right-top":
					break;
				case "right-bottom":
					tip.r = "100%";
					tip.t = ((overlayDimensions.h / 2) - overlayDimensions_offset.y) + "px";
					break;

				case "left":
					break;
				case "left-top":
					break;
				case "left-bottom":
					tip.l = "100%";
					tip.t = ((overlayDimensions.h / 2) - overlayDimensions_offset.y) + "px";
					break;
			}

			$tip.css({
				"top": tip.t,
				"right": tip.r,
				"bottom": tip.b,
				"left": tip.l
			
			});
			var ending_dimension = getDimensionsPosition($overlay);

			if (ending_dimension.w !== starting_dimension.w || ending_dimension.h !== starting_dimension.h) {
				myEvents.publish("resize", ending_dimension);
			}

			return me;
		}
		**/

		/**
			This is a method of the "Overlay" constructor.
			<br />Sets the position of the overlay in the viewport (centers it) based on the overlay w & h and 
			 usable space in the viewport.
			<br />Automatically called on setHtml, setWidth/Height, open, resize, & scroll.

			@method setPosition
			@return {Object} The overlay widget object (me).
		**/
		me.setPosition = setPosition;
		function setPosition () {
			//var pc = getDimensionsPosition($positioner),
			var closer_margin = 40, // cut this in half and that's how much min. margin we get top/bottom.
				contentHeight = $content[0].scrollHeight,
				ending_dimensions,
				full_width_margin = 0,
				/*min_dim = {
					w : 50,
					h : 50
				},*/
				overlayDimensions,
				overlayDimensions_offset = {
					x : 0,
					y : 0
				},
				starting_dimensions = getDimensionsPosition($overlay),
				win = getWindowDimensions(),
				usableHeight = win.h - (full_width_margin*2) - closer_margin,
				contentHeightApplied = contentHeight,
				contentPadding = starting_dimensions.h - $content.height(); 
			
			//console.log($overlay,$content);
			/**
			console.log("win:"+win.h, 
				"usable:"+usableHeight,
				"overlay:"+starting_dimensions.h, 
				"content:"+contentHeight,
				"contentNew:"+$content.height(),
				"contentPadding:"+contentPadding
			);
			**/
			
			// Set the CONTENT width @style.
			if (appliedSettings.fullwidth) {
				//$content.css("width", win.w - (full_width_margin*2) + "px");
			}

			// Adjust the content height so the overlay doesn't flow outside the viewport.
			if (contentHeight > usableHeight - closer_margin) {
				contentHeightApplied = usableHeight - contentPadding;
			}
			
			// Force full height content.
			if (appliedSettings.full_height) {
				contentHeightApplied = usableHeight;
				$content.css({
					"height": contentHeightApplied + "px"
				});
			}
			
			// Set the max height on the content div so it scrolls if there's more content than can fit in the 
			//  usable overlay height that we set.
			// BUG: Fast resizes cause issue, so at any point if usableHeight > content, set to overlay's original height.
			if (appliedSettings.allowResize) {
				$content.css({
					"max-height": contentHeightApplied + "px"
				});
			}

			// Get our new dimensions and figure out offset for centering.
			overlayDimensions = getDimensionsPosition($overlay);
			overlayDimensions_offset.x = overlayDimensions.w / 2;
			overlayDimensions_offset.y = overlayDimensions.h / 2;

			if (appliedSettings.fullwidth) {
				overlayDimensions_offset.x = (win.w / 2);
			}

			overlayDimensions.x = (win.w / 2) - overlayDimensions_offset.x;
			overlayDimensions.y = (win.h / 2) + full_width_margin/2 - overlayDimensions_offset.y;

			$overlay.css({
				"left": overlayDimensions.x + "px",
				"top": overlayDimensions.y + "px"
			});

			ending_dimensions = getDimensionsPosition($overlay);

			if (ending_dimensions.w !== starting_dimensions.w || ending_dimensions.h !== starting_dimensions.h) {
				myEvents.publish("resize", ending_dimensions);
			}

			return me;
		}

		/**
			This is a method of the "Overlay" constructor.
			<br />Gets and returns the index of the overlay in the stack of overlays that are showing.

			@method getStackIndex
			@return {Integer} The index # of the overlay in the stack that's showing.
		**/
		me.getStackIndex = getStackIndex;
		function getStackIndex () {
			var i = -1,
				stackLen = stack.length;
			
			while (++i < stackLen) {
				if (me.id === stack[i].getId()) {
					break;
				}
			}
			
			return i < stackLen ? i : -1;
		}

		/**
			This is a method of the "Overlay" constructor.
			<br />Shows the overlay.

			@method show
			@return {Object} The overlay widget object (me).
		**/
		me.show = show;
		function show () {
			returnFocusEl = document.activeElement;

			//var has_returned_false = false;
			
			if ($content.innerHTML === "") {
				console.warn("Will not open an empty overlay");
				return false;
			}

			if (isOpen()) {
				console.warn("This overlay is already open");
				return false;
			}

			open_overlays[me.id] = me;
			stack.push(me);
			setStackZIndex();
			updateBackdrop();

			$.each(on_show_fns, function(){
				//	console.group("Calling on_show_fns["+i+"]");
				//	console.log(this);
				//	console.groupEnd();
				var ret = this.call(me, is_first_show);
				/**
				if (ret === false) {
					has_returned_false = true;
				}
				**/
			});

			//if (has_returned_false)
			//return false;

			myEvents.publish("pre-show", is_first_show);

			$overlay.addClass(prepped_class);
			loop_count = 0;
			setFinalPositionAndShow();

			fireStatsEvent("show", me.id);

			// is_first_show = false;

			is_open = true;

			return me;
		}

		/**
		me.setAsMastheadOverlay = setAsMastheadOverlay;
		function setAsMastheadOverlay(bool) {
			// console.log("bool: "+bool);
			is_masthead_overlay = bool === true;
		}
		**/

		/**
			Sets the z-index of the overlay we're showing. Used when multiple overlays are opened and stacked on top of each other.

			@method setStackZIndex
			@private
		**/
		function setStackZIndex () {
			z_index = (920) + getStackIndex();
			// console.log("z_index: "+z_index);
			$overlay.css("zIndex", z_index);
		}

		/**
			This is a method of the "Overlay" constructor.
			<br />Gets and returns the z-index property of this overlay instance.

			@method getZindex
			@return {Integer} The z-index of this overlay instance.
		**/
		me.getZindex = function () {
			return z_index;
		};

		/**
		me.isMastheadOverlay = isMastheadOverlay;
		function isMastheadOverlay() {
			return is_masthead_overlay;
		}
		**/

		/**
			Gets and returns the overlay's offset properties in a standard format.

			@method getDimensionsOffset
			@private
			@return {Object} An object with x,y,w,h offset properties of this overlay.
		**/
		/**
		function getDimensionsOffset (el) {
			var obj = {
				x: el.offset().left,
				y: el.offset().top,
				w: el.width(),
				h: el.outerHeight()
			};
			return obj;
		}
		**/

		/**
			Gets and returns the overlay's dimensions/position properties in a standard format.

			@method getDimensionsPosition
			@private
			@return {Object} An object with x,y,w,h dimension/position properties of this overlay.
		**/
		function getDimensionsPosition (el) {
			var obj = {
				x: 0,
				y: 0,
				w: 0,
				h: 0
			};

			if (el) {
				obj = {
					x: el.position().left,
					y: el.position().top,
					w: el.width(),
					h: el.outerHeight()
				};
			}

			return obj;
		}
		
		/**
			Gets and returns the window's dimensions properties in a standard format.

			@method getWindowDimensions
			@private
			@return {Object} An object with w,h properties of the window (viewport).
		**/
		function getWindowDimensions () {
			var obj = {
				w: $(window).width(),
				h: $(window).height()
			};

			return obj;
		}

		/**
			Sets the overlay's position based on content, width, height, then shows it.

			@method setFinalPositionAndShow
			@private
		**/
		function setFinalPositionAndShow () {
			if (++loop_count > loop_limit) {
				$overlay.addClass(active_class);
				console.warn("Could not resolve overlay's final position in time.");
			}
			else {
				//console.log("setting final position");
				setPosition();
				
				var this_dim = getDimensionsPosition($overlay);

				if (this_dim.x === last_dim.x && this_dim.y === last_dim.y && this_dim.w === last_dim.w && this_dim.h === last_dim.h) {
					// We're in! Show the overlay
					$overlay.addClass(active_class);

					//console.log("Will run show in a moment...");
					setTimeout(function () {
						myEvents.publish("show", is_first_show);
						is_first_show = false;
					}, 300);
				}
				else {
					last_dim = getDimensionsPosition($overlay);
					setTimeout(setFinalPositionAndShow, 10);
				}
			}
		}

		/**
			This is a method of the "Overlay" constructor.
			<br />Hides the overlay.

			@method hide
			@return {Object} The overlay widget object (me).
		**/
		me.hide = hide;
		function hide () {
			//var has_returned_false = false;
			
			//console.log("Calling new overlay hide function.. isOpen() = " + isOpen() + " ... It's  " + (isOpen() ? "open" : "closed"));

			if (!isOpen()) {
				return me;
			}

			//console.log("This overlay is open... continuing with close");

			$.each(on_hide_fns, function(){
				var ret = this.call(me, is_first_hide);
				/**
				if (ret === false) {
					has_returned_false = true;
				}
				**/
			});

			//if (has_returned_false)
			//return me;

			delete open_overlays[me.id];

			stack.splice(getStackIndex(), 1);

			updateBackdrop();

			/**
			var $trigger;
			$.each(triggers, function ($trigger) {
				$trigger = this;
				var shared_trigger_found = false,
					dd;

				for (dd in open_overlays) {
					$.each(open_overlays[dd].getTriggers(), function() {
						if ($trigger == this) {
							shared_trigger_found = true;
						}
					});
				}

				if (!shared_trigger_found) {
					$trigger.removeClass(overlayBackdropTriggerClass).removeClass(overlayBackdropTriggerRelativeClass);
				}
				else {
					console.log("Shared trigger found. Leaving visible.");
				}
			});
			**/

			$overlay.removeClass(active_class);
			
			setTimeout(function(){
				$overlay.removeClass(prepped_class);
			}, 100);

			/**
			setTimeout(function () {
				if ($last_used_trigger) {
					var focuser = $last_used_trigger;

					if ($last_used_trigger.nodeName != "A") {
						focuser = $("a", $last_used_trigger)[0];
					}

					if (focuser) {
						console.log("Focusing last trigger");
						focuser.focus();
					}
				}
			}, 100);
			**/

			myEvents.publish("hide", is_first_hide);

			fireStatsEvent("hide", me.id);

			is_first_hide = false;

			is_open = false;

			$(returnFocusEl).focus();

			return me;
		}

		/**
			This is a method of the "Overlay" constructor.
			<br />Toggles the overlay: Shows if currently hidden, hides if currently showing. (DUH)

			@method toggle
			@return {Object} The overlay widget object (me).
		**/
		me.toggle = toggle;
		function toggle () {
			if (isOpen()) {
				hide();
			}
			else {
				show();
			}

			return me;
		}

		/**
			This is a method of the "Overlay" constructor.
			<br />Tells you if the overlay is currently open or not.

			@method isOpen
			@return {Boolean} True or False.
		**/
		me.isOpen = isOpen;
		function isOpen () {
			//console.log("open_overlays["+id+"]:"); console.log(open_overlays[id]);
			//return typeof(open_overlays[id]) != "undefined";
			return is_open;
		}

		/**
			This is a method of the "Overlay" constructor.
			<br />Getter or setter; based on if you pass a param or not:
			<br />If no param passed, it will tell you if the overlay is seamless or not.
			<br />If you pass a bool (true | false), it will set the overlay to be seamless or not (add/remove class).

			@method seamless
			@return {Boolean or Object} True | False, or the overlay widget object (me).
		**/
		me.seamless = seamless;
		function seamless (bool) {
			var classname = "seamless";
			
			if (typeof bool === "undefined") {
				return $overlay.hasClass(classname);
			}

			$overlay[bool === false ? "removeClass" : "addClass"](classname);

			return me;
		}

		/**
			This is a method of the "Overlay" constructor.
			<br />Getter or setter; based on if you pass a param or not:
			<br />If no param passed, it will tell you if the overlay is titled (special class) or not.
			<br />If you pass a bool (true | false), it will set the overlay to be seamless or not (add/remove class).

			@method titled
			@return {Boolean or Object} True | False (if getting), or the overlay widget object (me) (if setting)
		**/
		me.titled = titled;
		function titled (bool) {
			var classname = "titled";
			
			if (typeof bool === "undefined") {
				return $content.hasClass(classname);
			}

			$content[bool === false ? "removeClass" : "addClass"](classname);

			return me;
		}

	}
	
	/* Run now.
	***************************************************************************************/
	
	// Bind esc key to close the topmost overlay in the stack.
	$(document).keydown(function (evt) {
		var kc = evt.keyCode || evt.which;
		
		switch (kc) {
			case 27:
				if (stack.length > 0) {
					stack[stack.length - 1].hide();
				}
				break;
		}
	});

	// On DOM load, inject the backdrop/screen then bind it to show/hide/etc.
	$(function(){
		$overlayBackdrop = $('<div id="ibm-overlay-backdrop"></div>').appendTo('#ibm-com');

		$overlayBackdrop.show = function(){
			$("#ibm-com").addClass("ibm-overlay-backdrop-visible");
		};
		
		$overlayBackdrop.hide = function(){
			$("#ibm-com").removeClass("ibm-overlay-backdrop-visible");
		};
		
		$overlayBackdrop.click(me.hideAllOverlays);
	
		//$("#ibm-mast-options").click(me.hideAllOverlays);
	});
	
})(jQuery, IBMCore);
;

/**
	
	Parallax scrolling widget. 
	<br />
	<br />It's not magic. It simply moves the background up or down as a % of the page's scroll. 
	<br />__NOTE: __This can only be used on bands sections.  (div.ibm-band full-width sections)
	<br />To implement, simply add the attribute to the .ibm-band container:  data-widget="parallaxscroll", shown below.
	<br />Requirement: Obvious, but: You need a big background image for this to work.
	<br />
	<br />Usage:

		<div class="ibm-band" data-widget="parallaxscroll" style="background-image: url(//some/URL/to/your/image.file);">
	
	<br >__NOTE:__ Make sure you only set the @background-image property (don't set @background) else it won't properly.

	@class IBMCore.common.widget.parallaxscroll

**/

(function($, IBM) {

    var me = IBM.namespace(IBM, "common.widget.parallaxscroll");

    // Adds a class to the band element that sets the background image to the proper style to enable BG moving:
    // 50% 100px no-repeat fixed; background-size:cover;

    /**
    	Inits the parallax scroll widget on the passed element.
    	<br />This is automatically called onload by the v18 JS for each element that has the data-widget attribute and is not disabled.
    	<br />If you are dynamically injecting a div.ibm-band HTML, call this function after DOM injection, passing your .ibm-band element to it.

    	@method init
    	@param {DOM element} el The &lt;div>.ibm-band element you want to enable parallax scrolling on.
    **/
    me.init = function (el) {
    	var $el = $(el),
    		scrollspeed = $el.data("scrollspeed") || 6,
    		backgroundX = $el.css("backgroundPosition").split(" ")[0],
    		disabledSmall = $el.data("disablesmallgrid");

    	// Add class that sets the proper styles.
    	$el.addClass("ibm-parallax-scroll");

		function adjustImage () {
			var $window = $(window),
				bgpos = backgroundX + " " + -Math.floor((Math.floor($window.scrollTop()) - Math.floor($el.offset().top)) / scrollspeed) + "px";
			
			if (disabledSmall && $("html").hasClass("ibm-grid-small")) {
				return;
			}
			
			$el.css("background-position", bgpos);
		}

    	// Bind the background to shift whenever the page scrolls.
		$(window).scroll(adjustImage);

		// Adjust image onload.
		adjustImage();
    };

})(jQuery, IBMCore);

;


/**
	Nanoscroller is a very small basic scrolling div plug-in.
	<br >This is used by the <a href="../classes/IBMCore.common.widget.scrollable.html">IBM scrollable</a> widget.
	<br />__NEVER__ use this directly to init the scrollable plug-in as it might change. Always use the IBM scrollable() method.

	@module Nanoscroller
	@main Nanoscroller
**/

/* nanoScrollerJS - v0.8.5 - 2015
 * http://jamesflorentino.github.com/nanoScrollerJS/
 * Copyright (c) 2015 James Florentino; Licensed MIT */
(function(factory) {
	return factory(jQuery, window, document);
})(function($, window, document) {
	"use strict";
	var BROWSER_IS_IE7, BROWSER_SCROLLBAR_WIDTH, DOMSCROLL, DOWN, DRAG, ENTER, KEYDOWN, KEYUP, MOUSEDOWN, MOUSEENTER, MOUSEMOVE, MOUSEUP, MOUSEWHEEL, NanoScroll, PANEDOWN, RESIZE, SCROLL, SCROLLBAR, TOUCHMOVE, UP, WHEEL, cAF, defaults, getBrowserScrollbarWidth, hasTransform, isFFWithBuggyScrollbar, rAF, transform, _elementStyle, _prefixStyle, _vendor;
	defaults = {

	/**
	a classname for the pane element.
	@property paneClass
	@type String
	@default 'nano-pane'
  	*/
		paneClass: 'nano-pane',

	/**
	a classname for the slider element.
	@property sliderClass
	@type String
	@default 'nano-slider'
  	*/
		sliderClass: 'nano-slider',

	/**
	a classname for the content element.
	@property contentClass
	@type String
	@default 'nano-content'
  	*/
		contentClass: 'nano-content',

	/**
	a setting to enable native scrolling in iOS devices.
	@property iOSNativeScrolling
	@type Boolean
	@default false
  	*/
		iOSNativeScrolling: false,

	/**
	a setting to prevent the rest of the page being
	scrolled when user scrolls the `.content` element.
	@property preventPageScrolling
	@type Boolean
	@default false
  	*/
		preventPageScrolling: false,

	/**
	a setting to disable binding to the resize event.
	@property disableResize
	@type Boolean
	@default false
  	*/
		disableResize: false,

	/**
	a setting to make the scrollbar always visible.
	@property alwaysVisible
	@type Boolean
	@default false
  	*/
		alwaysVisible: false,

	/**
	a default timeout for the `flash()` method.
	@property flashDelay
	@type Number
	@default 1500
  	*/
		flashDelay: 1500,

	/**
	a minimum height for the `.slider` element.
	@property sliderMinHeight
	@type Number
	@default 20
  	*/
		sliderMinHeight: 20,

	/**
	a maximum height for the `.slider` element.
	@property sliderMaxHeight
	@type Number
	@default null
  	*/
		sliderMaxHeight: null,

	/**
	an alternate document context.
	@property documentContext
	@type Document
	@default null
  	*/
		documentContext: null,

	/**
	an alternate window context.
	@property windowContext
	@type Window
	@default null
  	*/
		windowContext: null
	};

	/**
    @property SCROLLBAR
    @type String
    @static
    @final
    @private
	*/
	SCROLLBAR = 'scrollbar';

	/**
    @property SCROLL
    @type String
    @static
    @final
    @private
	*/
	SCROLL = 'scroll';

	/**
    @property MOUSEDOWN
    @type String
    @final
    @private
	*/
	MOUSEDOWN = 'mousedown';

	/**
    @property MOUSEENTER
    @type String
    @final
    @private
	*/
	MOUSEENTER = 'mouseenter';

	/**
    @property MOUSEMOVE
    @type String
    @static
    @final
    @private
	*/
	MOUSEMOVE = 'mousemove';

	/**
    @property MOUSEWHEEL
    @type String
    @final
    @private
	*/
	MOUSEWHEEL = 'mousewheel';

	/**
    @property MOUSEUP
    @type String
    @static
    @final
    @private
	*/
	MOUSEUP = 'mouseup';

	/**
    @property RESIZE
    @type String
    @final
    @private
	*/
	RESIZE = 'resize';

	/**
    @property DRAG
    @type String
    @static
    @final
    @private
	*/
	DRAG = 'drag';

	/**
    @property ENTER
    @type String
    @static
    @final
    @private
	*/
	ENTER = 'enter';

	/**
    @property UP
    @type String
    @static
    @final
    @private
	*/
	UP = 'up';

	/**
    @property PANEDOWN
    @type String
    @static
    @final
    @private
	*/
	PANEDOWN = 'panedown';

	/**
    @property DOMSCROLL
    @type String
    @static
    @final
    @private
	*/
	DOMSCROLL = 'DOMMouseScroll';

	/**
    @property DOWN
    @type String
    @static
    @final
    @private
	*/
	DOWN = 'down';

	/**
    @property WHEEL
    @type String
    @static
    @final
    @private
	*/
	WHEEL = 'wheel';

	/**
    @property KEYDOWN
    @type String
    @static
    @final
    @private
	*/
	KEYDOWN = 'keydown';

	/**
    @property KEYUP
    @type String
    @static
    @final
    @private
	*/
	KEYUP = 'keyup';

	/**
    @property TOUCHMOVE
    @type String
    @static
    @final
    @private
	*/
	TOUCHMOVE = 'touchmove';

	/**
    @property BROWSER_IS_IE7
    @type Boolean
    @static
    @final
    @private
	*/
	BROWSER_IS_IE7 = window.navigator.appName === 'Microsoft Internet Explorer' && /msie 7./i.test(window.navigator.appVersion) && window.ActiveXObject;

	/**
    @property BROWSER_SCROLLBAR_WIDTH
    @type Number
    @static
    @default null
    @private
	*/
	BROWSER_SCROLLBAR_WIDTH = null;
	rAF = window.requestAnimationFrame;
	cAF = window.cancelAnimationFrame;
	_elementStyle = document.createElement('div').style;
	_vendor = (function() {
		var i, transform, vendor, vendors, _i, _len;
		vendors = ['t', 'webkitT', 'MozT', 'msT', 'OT'];
		for (i = _i = 0, _len = vendors.length; _i < _len; i = ++_i) {
			vendor = vendors[i];
			transform = vendors[i] + 'ransform';
			if (transform in _elementStyle) {
				return vendors[i].substr(0, vendors[i].length - 1);
			}
		}
		return false;
	})();
	_prefixStyle = function(style) {
		if (_vendor === false) {
			return false;
		}
		if (_vendor === '') {
			return style;
		}
		return _vendor + style.charAt(0).toUpperCase() + style.substr(1);
	};
	transform = _prefixStyle('transform');
	hasTransform = transform !== false;

	/**
    Returns browser's native scrollbar width
    @method getBrowserScrollbarWidth
    @return {Number} the scrollbar width in pixels
    @static
    @private
	*/
	getBrowserScrollbarWidth = function() {
		var outer, outerStyle, scrollbarWidth;
		outer = document.createElement('div');
		outerStyle = outer.style;
		outerStyle.position = 'absolute';
		outerStyle.width = '100px';
		outerStyle.height = '100px';
		outerStyle.overflow = SCROLL;
		outerStyle.top = '-9999px';
		document.body.appendChild(outer);
		scrollbarWidth = outer.offsetWidth - outer.clientWidth;
		document.body.removeChild(outer);
		return scrollbarWidth;
	};
	isFFWithBuggyScrollbar = function() {
		var isOSXFF, ua, version;
		ua = window.navigator.userAgent;
		isOSXFF = /(?=.+Mac OS X)(?=.+Firefox)/.test(ua);
		if (!isOSXFF) {
			return false;
		}
		version = /Firefox\/\d{2}\./.exec(ua);
		if (version) {
			version = version[0].replace(/\D+/g, '');
		}
		return isOSXFF && +version > 23;
	};

	/**
    @class NanoScroll
    @param element {HTMLElement|Node} the main element
    @param options {Object} nanoScroller's options
    @constructor
	*/
	NanoScroll = (function() {
		function NanoScroll(el, options) {
			this.el = el;
			this.options = options;
			BROWSER_SCROLLBAR_WIDTH || (BROWSER_SCROLLBAR_WIDTH = getBrowserScrollbarWidth());
			this.$el = $(this.el);
			this.doc = $(this.options.documentContext || document);
			this.win = $(this.options.windowContext || window);
			this.body = this.doc.find('body');
			this.$content = this.$el.children("." + this.options.contentClass);
			this.$content.attr('tabindex', this.options.tabIndex || 0);
			this.content = this.$content[0];
			this.previousPosition = 0;
			if (this.options.iOSNativeScrolling && (this.el.style.WebkitOverflowScrolling != null)) {
				this.nativeScrolling();
			} else {
				this.generate();
			}
			this.createEvents();
			this.addEvents();
			this.reset();
		}


	/**
	Prevents the rest of the page being scrolled
	when user scrolls the `.nano-content` element.
	@method preventScrolling
	@param event {Event}
	@param direction {String} Scroll direction (up or down)
	@private
  	*/

		NanoScroll.prototype.preventScrolling = function(e, direction) {
			if (!this.isActive) {
				return;
			}
			if (e.type === DOMSCROLL) {
				if (direction === DOWN && e.originalEvent.detail > 0 || direction === UP && e.originalEvent.detail < 0) {
					e.preventDefault();
				}
			} else if (e.type === MOUSEWHEEL) {
				if (!e.originalEvent || !e.originalEvent.wheelDelta) {
					return;
				}
				if (direction === DOWN && e.originalEvent.wheelDelta < 0 || direction === UP && e.originalEvent.wheelDelta > 0) {
					e.preventDefault();
				}
			}
		};


	/**
	Enable iOS native scrolling
	@method nativeScrolling
	@private
  	*/

		NanoScroll.prototype.nativeScrolling = function() {
			this.$content.css({
				WebkitOverflowScrolling: 'touch'
			});
			this.iOSNativeScrolling = true;
			this.isActive = true;
		};


	/**
	Updates those nanoScroller properties that
	are related to current scrollbar position.
	@method updateScrollValues
	@private
  	*/

		NanoScroll.prototype.updateScrollValues = function() {
			var content, direction;
			content = this.content;
			this.maxScrollTop = content.scrollHeight - content.clientHeight;
			this.prevScrollTop = this.contentScrollTop || 0;
			this.contentScrollTop = content.scrollTop;
			direction = this.contentScrollTop > this.previousPosition ? "down" : this.contentScrollTop < this.previousPosition ? "up" : "same";
			this.previousPosition = this.contentScrollTop;
			if (direction !== "same") {
				this.$el.trigger('update', {
					position: this.contentScrollTop,
					maximum: this.maxScrollTop,
					direction: direction
				});
			}
			if (!this.iOSNativeScrolling) {
				this.maxSliderTop = this.paneHeight - this.sliderHeight;
				this.sliderTop = this.maxScrollTop === 0 ? 0 : this.contentScrollTop * this.maxSliderTop / this.maxScrollTop;
			}
		};


	/**
	Updates CSS styles for current scroll position.
	Uses CSS 2d transfroms and `window.requestAnimationFrame` if available.
	@method setOnScrollStyles
	@private
  	*/

		NanoScroll.prototype.setOnScrollStyles = function() {
			var cssValue;
			if (hasTransform) {
				cssValue = {};
				cssValue[transform] = "translate(0, " + this.sliderTop + "px)";
			} else {
				cssValue = {
					top: this.sliderTop
				};
			}
			if (rAF) {
				if (cAF && this.scrollRAF) {
					cAF(this.scrollRAF);
				}
				this.scrollRAF = rAF((function(_this) {
					return function() {
						_this.scrollRAF = null;
						return _this.slider.css(cssValue);
					};
				})(this));
			} else {
				this.slider.css(cssValue);
			}
		};


	/**
	Creates event related methods
	@method createEvents
	@private
  	*/

		NanoScroll.prototype.createEvents = function() {
			this.events = {
				down: (function(_this) {
					return function(e) {
						_this.isBeingDragged = true;
						_this.offsetY = e.pageY - _this.slider.offset().top;
						if (!_this.slider.is(e.target)) {
							_this.offsetY = 0;
						}
						_this.pane.addClass('active');
						_this.doc.bind(MOUSEMOVE, _this.events[DRAG]).bind(MOUSEUP, _this.events[UP]);
						_this.body.bind(MOUSEENTER, _this.events[ENTER]);
						return false;
					};
				})(this),
				drag: (function(_this) {
					return function(e) {
						_this.sliderY = e.pageY - _this.$el.offset().top - _this.paneTop - (_this.offsetY || _this.sliderHeight * 0.5);
						_this.scroll();
						if (_this.contentScrollTop >= _this.maxScrollTop && _this.prevScrollTop !== _this.maxScrollTop) {
							_this.$el.trigger('scrollend');
						} else if (_this.contentScrollTop === 0 && _this.prevScrollTop !== 0) {
							_this.$el.trigger('scrolltop');
						}
						return false;
					};
				})(this),
				up: (function(_this) {
					return function(e) {
						_this.isBeingDragged = false;
						_this.pane.removeClass('active');
						_this.doc.unbind(MOUSEMOVE, _this.events[DRAG]).unbind(MOUSEUP, _this.events[UP]);
						_this.body.unbind(MOUSEENTER, _this.events[ENTER]);
						return false;
					};
				})(this),
				resize: (function(_this) {
					return function(e) {
						_this.reset();
					};
				})(this),
				panedown: (function(_this) {
					return function(e) {
						_this.sliderY = (e.offsetY || e.originalEvent.layerY) - (_this.sliderHeight * 0.5);
						_this.scroll();
						_this.events.down(e);
						return false;
					};
				})(this),
				scroll: (function(_this) {
					return function(e) {
						_this.updateScrollValues();
						if (_this.isBeingDragged) {
							return;
						}
						if (!_this.iOSNativeScrolling) {
							_this.sliderY = _this.sliderTop;
							_this.setOnScrollStyles();
						}
						if (e == null) {
							return;
						}
						if (_this.contentScrollTop >= _this.maxScrollTop) {
							if (_this.options.preventPageScrolling) {
								_this.preventScrolling(e, DOWN);
							}
							if (_this.prevScrollTop !== _this.maxScrollTop) {
								_this.$el.trigger('scrollend');
							}
						} else if (_this.contentScrollTop === 0) {
							if (_this.options.preventPageScrolling) {
								_this.preventScrolling(e, UP);
							}
							if (_this.prevScrollTop !== 0) {
								_this.$el.trigger('scrolltop');
							}
						}
					};
				})(this),
				wheel: (function(_this) {
					return function(e) {
						var delta;
						if (e == null) {
							return;
						}
						delta = e.delta || e.wheelDelta || (e.originalEvent && e.originalEvent.wheelDelta) || -e.detail || (e.originalEvent && -e.originalEvent.detail);
						if (delta) {
							_this.sliderY += -delta / 3;
						}
						_this.scroll();
						return false;
					};
				})(this),
				enter: (function(_this) {
					return function(e) {
						var _ref;
						if (!_this.isBeingDragged) {
							return;
						}
						if ((e.buttons || e.which) !== 1) {
							return (_ref = _this.events)[UP].apply(_ref, arguments);
						}
					};
				})(this)
			};
		};


	/**
	Adds event listeners with jQuery.
	@method addEvents
	@private
  	*/

		NanoScroll.prototype.addEvents = function() {
			var events;
			this.removeEvents();
			events = this.events;
			if (!this.options.disableResize) {
				this.win.bind(RESIZE, events[RESIZE]);
			}
			if (!this.iOSNativeScrolling) {
				this.slider.bind(MOUSEDOWN, events[DOWN]);
				this.pane.bind(MOUSEDOWN, events[PANEDOWN]).bind("" + MOUSEWHEEL + " " + DOMSCROLL, events[WHEEL]);
			}
			this.$content.bind("" + SCROLL + " " + MOUSEWHEEL + " " + DOMSCROLL + " " + TOUCHMOVE, events[SCROLL]);
		};


	/**
	Removes event listeners with jQuery.
	@method removeEvents
	@private
  	*/

		NanoScroll.prototype.removeEvents = function() {
			var events;
			events = this.events;
			this.win.unbind(RESIZE, events[RESIZE]);
			if (!this.iOSNativeScrolling) {
				this.slider.unbind();
				this.pane.unbind();
			}
			this.$content.unbind("" + SCROLL + " " + MOUSEWHEEL + " " + DOMSCROLL + " " + TOUCHMOVE, events[SCROLL]);
		};


	/**
	Generates nanoScroller's scrollbar and elements for it.
	@method generate
	@chainable
	@private
  	*/

		NanoScroll.prototype.generate = function() {
			var contentClass, cssRule, currentPadding, options, pane, paneClass, sliderClass;
			options = this.options;
			paneClass = options.paneClass, sliderClass = options.sliderClass, contentClass = options.contentClass;
			if (!(pane = this.$el.children("." + paneClass)).length && !pane.children("." + sliderClass).length) {
				this.$el.append("<div class=\"" + paneClass + "\"><div class=\"" + sliderClass + "\" /></div>");
			}
			this.pane = this.$el.children("." + paneClass);
			this.slider = this.pane.find("." + sliderClass);
			if (BROWSER_SCROLLBAR_WIDTH === 0 && isFFWithBuggyScrollbar()) {
				currentPadding = window.getComputedStyle(this.content, null).getPropertyValue('padding-right').replace(/[^0-9.]+/g, '');
				cssRule = {
					right: -14,
					paddingRight: +currentPadding + 14
				};
			} else if (BROWSER_SCROLLBAR_WIDTH) {
				cssRule = {
					right: -BROWSER_SCROLLBAR_WIDTH
				};
				this.$el.addClass('has-scrollbar');
			}
			if (cssRule != null) {
				this.$content.css(cssRule);
			}
			return this;
		};


	/**
	@method restore
	@private
  	*/

		NanoScroll.prototype.restore = function() {
			this.stopped = false;
			if (!this.iOSNativeScrolling) {
				this.pane.show();
			}
			this.addEvents();
		};


	/**
	Resets nanoScroller's scrollbar.
	@method reset
	@chainable
	@example
	    $(".nano").nanoScroller();
  	*/

		NanoScroll.prototype.reset = function() {
			var content, contentHeight, contentPosition, contentStyle, contentStyleOverflowY, paneBottom, paneHeight, paneOuterHeight, paneTop, parentMaxHeight, right, sliderHeight;
			if (this.iOSNativeScrolling) {
				this.contentHeight = this.content.scrollHeight;
				return;
			}
			if (!this.$el.find("." + this.options.paneClass).length) {
				this.generate().stop();
			}
			if (this.stopped) {
				this.restore();
			}
			content = this.content;
			contentStyle = content.style;
			contentStyleOverflowY = contentStyle.overflowY;
			if (BROWSER_IS_IE7) {
				this.$content.css({
					height: this.$content.height()
				});
			}
			contentHeight = content.scrollHeight + BROWSER_SCROLLBAR_WIDTH;
			parentMaxHeight = parseInt(this.$el.css("max-height"), 10);
			if (parentMaxHeight > 0) {
				this.$el.height("");
				this.$el.height(content.scrollHeight > parentMaxHeight ? parentMaxHeight : content.scrollHeight);
			}
			paneHeight = this.pane.outerHeight(false);
			paneTop = parseInt(this.pane.css('top'), 10);
			paneBottom = parseInt(this.pane.css('bottom'), 10);
			paneOuterHeight = paneHeight + paneTop + paneBottom;
			sliderHeight = Math.round(paneOuterHeight / contentHeight * paneOuterHeight);
			if (sliderHeight < this.options.sliderMinHeight) {
				sliderHeight = this.options.sliderMinHeight;
			} else if ((this.options.sliderMaxHeight != null) && sliderHeight > this.options.sliderMaxHeight) {
				sliderHeight = this.options.sliderMaxHeight;
			}
			if (contentStyleOverflowY === SCROLL && contentStyle.overflowX !== SCROLL) {
				sliderHeight += BROWSER_SCROLLBAR_WIDTH;
			}
			this.maxSliderTop = paneOuterHeight - sliderHeight;
			this.contentHeight = contentHeight;
			this.paneHeight = paneHeight;
			this.paneOuterHeight = paneOuterHeight;
			this.sliderHeight = sliderHeight;
			this.paneTop = paneTop;
			this.slider.height(sliderHeight);
			this.events.scroll();
			this.pane.show();
			this.isActive = true;
			if ((content.scrollHeight === content.clientHeight) || (this.pane.outerHeight(true) >= content.scrollHeight && contentStyleOverflowY !== SCROLL)) {
				this.pane.hide();
				this.isActive = false;
			} else if (this.el.clientHeight === content.scrollHeight && contentStyleOverflowY === SCROLL) {
				this.slider.hide();
			} else {
				this.slider.show();
			}
			this.pane.css({
				opacity: (this.options.alwaysVisible ? 1 : ''),
				visibility: (this.options.alwaysVisible ? 'visible' : '')
			});
			contentPosition = this.$content.css('position');
			if (contentPosition === 'static' || contentPosition === 'relative') {
				right = parseInt(this.$content.css('right'), 10);
				if (right) {
					this.$content.css({
						right: '',
						marginRight: right
					});
				}
			}
			return this;
		};


	/**
	@method scroll
	@private
	@example
	    $(".nano").nanoScroller({ scroll: 'top' });
  	*/

		NanoScroll.prototype.scroll = function() {
			if (!this.isActive) {
				return;
			}
			this.sliderY = Math.max(0, this.sliderY);
			this.sliderY = Math.min(this.maxSliderTop, this.sliderY);
			this.$content.scrollTop(this.maxScrollTop * this.sliderY / this.maxSliderTop);
			if (!this.iOSNativeScrolling) {
				this.updateScrollValues();
				this.setOnScrollStyles();
			}
			return this;
		};


	/**
	Scroll at the bottom with an offset value
	@method scrollBottom
	@param offsetY {Number}
	@chainable
	@example
	    $(".nano").nanoScroller({ scrollBottom: value });
  	*/

		NanoScroll.prototype.scrollBottom = function(offsetY) {
			if (!this.isActive) {
				return;
			}
			this.$content.scrollTop(this.contentHeight - this.$content.height() - offsetY).trigger(MOUSEWHEEL);
			this.stop().restore();
			return this;
		};


	/**
	Scroll at the top with an offset value
	@method scrollTop
	@param offsetY {Number}
	@chainable
	@example
	    $(".nano").nanoScroller({ scrollTop: value });
  	*/

		NanoScroll.prototype.scrollTop = function(offsetY) {
			if (!this.isActive) {
				return;
			}
			this.$content.scrollTop(+offsetY).trigger(MOUSEWHEEL);
			this.stop().restore();
			return this;
		};


	/**
	Scroll to an element
	@method scrollTo
	@param node {Node} A node to scroll to.
	@chainable
	@example
	    $(".nano").nanoScroller({ scrollTo: $('#a_node') });
  	*/

		NanoScroll.prototype.scrollTo = function(node) {
			if (!this.isActive) {
				return;
			}
			this.scrollTop(this.$el.find(node).get(0).offsetTop);
			return this;
		};


	/**
	To stop the operation.
	This option will tell the plugin to disable all event bindings and hide the gadget scrollbar from the UI.
	@method stop
	@chainable
	@example
	    $(".nano").nanoScroller({ stop: true });
  	*/

		NanoScroll.prototype.stop = function() {
			if (cAF && this.scrollRAF) {
				cAF(this.scrollRAF);
				this.scrollRAF = null;
			}
			this.stopped = true;
			this.removeEvents();
			if (!this.iOSNativeScrolling) {
				this.pane.hide();
			}
			return this;
		};


	/**
	Destroys nanoScroller and restores browser's native scrollbar.
	@method destroy
	@chainable
	@example
	    $(".nano").nanoScroller({ destroy: true });
  	*/

		NanoScroll.prototype.destroy = function() {
			if (!this.stopped) {
				this.stop();
			}
			if (!this.iOSNativeScrolling && this.pane.length) {
				this.pane.remove();
			}
			if (BROWSER_IS_IE7) {
				this.$content.height('');
			}
			this.$content.removeAttr('tabindex');
			if (this.$el.hasClass('has-scrollbar')) {
				this.$el.removeClass('has-scrollbar');
				this.$content.css({
					right: ''
				});
			}
			return this;
		};


	/**
	To flash the scrollbar gadget for an amount of time defined in plugin settings (defaults to 1,5s).
	Useful if you want to show the user (e.g. on pageload) that there is more content waiting for him.
	@method flash
	@chainable
	@example
	    $(".nano").nanoScroller({ flash: true });
  	*/

		NanoScroll.prototype.flash = function() {
			if (this.iOSNativeScrolling) {
				return;
			}
			if (!this.isActive) {
				return;
			}
			this.reset();
			this.pane.addClass('flashed');
			setTimeout((function(_this) {
				return function() {
					_this.pane.removeClass('flashed');
				};
			})(this), this.options.flashDelay);
			return this;
		};

		return NanoScroll;

	})();
	$.fn.nanoScroller = function(settings) {
		return this.each(function() {
			var options, scrollbar;
			if (!(scrollbar = this.nanoscroller)) {
				options = $.extend({}, defaults, settings);
				this.nanoscroller = scrollbar = new NanoScroll(this, options);
			}
			if (settings && typeof settings === "object") {
				$.extend(scrollbar.options, settings);
				if (settings.scrollBottom != null) {
					return scrollbar.scrollBottom(settings.scrollBottom);
				}
				if (settings.scrollTop != null) {
					return scrollbar.scrollTop(settings.scrollTop);
				}
				if (settings.scrollTo) {
					return scrollbar.scrollTo(settings.scrollTo);
				}
				if (settings.scroll === 'bottom') {
					return scrollbar.scrollBottom(0);
				}
				if (settings.scroll === 'top') {
					return scrollbar.scrollTop(0);
				}
				if (settings.scroll && settings.scroll instanceof $) {
					return scrollbar.scrollTo(settings.scroll);
				}
				if (settings.stop) {
					return scrollbar.stop();
				}
				if (settings.destroy) {
					return scrollbar.destroy();
				}
				if (settings.flash) {
					return scrollbar.flash();
				}
			}
			return scrollbar.reset();
		});
	};
	$.fn.nanoScroller.Constructor = NanoScroll;
});

//# sourceMappingURL=jquery.nanoscroller.js.map;

/**

	RSS feed display widget.
	<br />
	<br />Gets a RSS feed and generates a link list using the items from the RSS feed.
	<br />
	<br />Usage:
		
	<div data-widget="rssdisplay" data-feedurl="http://someURL.com/to/rss/feed/"></div>

	__Special case:__ In scenarios where you dynamically inject HTML post page load, you can initialize the widget on your injected container like this:
	
	$("yourRssdisplayContainer").rssdisplay();

	Allowed options and values. __All values are strings__ (html standards):
	<br />__data-widget__: rssdisplay
	<br />__data-feedurl__: http://somefeed/url/here 
	<br />__data-externalicon__: true | false (default)  &nbsp; // Shows the external icon instead of default arrow
	<br />__data-newwindow__: true | false (default)  &nbsp; // Opens all links in new window/tab
		
	@class IBMCore.common.widget.rssdisplay

**/

(function ($, IBM) {

	var me = IBM.namespace(IBM, "common.widget.rssdisplay"),
		rssdisplays = [],
		object_name = "RSS display widget";

	/**
		Public jQuery plug-in definition.
		<br />Used by core v18 JS file to auto-init HTML that exist on the page on DOM ready.
		<br />If you are dynamically injecting and initing the widget HTML post-load, call this plug-in on your injected container.

		@method $.fn.rssdisplay
		@param [settings] {Object} Settings to override defaults and element's @data-xxxx attributes.
	**/
	$.fn.rssdisplay = function (settings) {
		return this.each(function () {
			var d = createRssdisplayWidget(settings);
			d.init($(this));
		});
	};

	/**
		Called by our jQuery plug-in.
		<br />This creates a new rssdisplay object and registers the instance into array of all this widget instances.
		<br />The jQuery plugin abstracts this and makes behind-the-scenes changes easy.
		
		@method createRssdisplayWidget
		@private
		@param [settings] {Object} Settings to override defaults and element's @data-xxxx attributes.
		@return {Object} The rssdisplayWidget object instance created.
	**/
	function createRssdisplayWidget (settings) {
		var widget = new rssdisplayWidget(settings);
		
		rssdisplays.push(widget);
		
		return widget;
	}
	
	/**
		rssdisplayWidget object/constructor for our public jQuery plugin.
		<br />Called by "createRssdisplayWidget".
		<br />You can't use this directly. Use the standard $(xxxx).rssdisplay() plug-in method to initialize the widget.

		@method rssdisplayWidget
		@constructor
		@private
		@param [settings] {Object} Settings to override defaults and element's @data-xxxx attributes.
	**/
	function rssdisplayWidget (settings) {
		var me = this,
			$container,
			config = {},
			defaults = {
				feedurl: "",
				newwindow: false,
				externalicon: false
			};
			
	    /**
			This is a method of the "rssdisplayWidget" constructor.
			<br />Called by our public jQuery plug-in after a new rssdisplayWidget object has been created and returned by "createRssdisplayWidget".
			<br />Automatically inits the rssdisplayWidget plug-in on the passed element, merging in any manually passed settings, 
			 @data-xxxxx settings, and our default settings. 
			
			@method init
			@param $elem {jQuery selector} The element you want to turn into a widget.
		**/
		me.init = init;
		function init ($elem) {
			var randomCallbackName = "dynCallback" + Math.floor((Math.random() * 999999) + 1);

			// If we're here, it means it's enabled, so build it/do your thing. 
			// Binds widget object to the DOM element it was init on by jQuery plugin method.
			// Keep "instance" as-is; ALL element-bound widgets will use this data attribute.
			$elem.data("widget", me);

			$container = $elem;

			// Merge in configuration to use, then init plug-in with them:  JS settings override HTML which override defaults.
			$.extend(config, defaults, $container.data() || {}, settings);

			// Error handling.
			if (config.feedurl === "") {
				console.error("RSS display widget is missing required feedurl parameter.");
			}

			// SWWIF uses unconventional callback param setup, so we have to mimic what jQuery does natively.
			// Dyn. create global function for callback, mapped to this object.
			window[randomCallbackName] = function (data) {
				serviceCallback(data);
			};

			// Fire WSR for feed items, using random callback name above mapped to our private function.
			IBM.common.util.coreservices.makeRequest("200", randomCallbackName, {
				type: "getBlogs",
				blogUrl: config.feedurl
			});

		}
		
	    /**
			This is a method of the "rssdisplayWidget" constructor.
			<br />This is the callback for the service request to get the feed data, mapped to randomized global function name.
			<br />This loops thru the WSR data, creates the actual widget HTML, and echoes it on the glass into the container.
			
			@method serviceCallback
			@private
			@param data {Object} The data JSON object returned from the SWWIF service call.
		**/
		function serviceCallback (data) {
			var html = "",
				iconClass = config.externalicon === true ? "ibm-external-link" : "ibm-forward-link" ,
				newWin = config.newwindow === true ? ' target="_blank"' : '' ;
			
			// Safety in case the service throws a 500 or can't get the feed URL and returns no data.
			if (!data || !data.blogEntries || data.blogEntries.length === 0) {
				console.warn("The service was unable to return data for the RSS url: " + config.feedurl, " It returned: ",data);
				return;
			}

			// Loop thru the returned data items, creating a link list HTML 
			$.each(data.blogEntries, function () {
				html += '<li><a class="' + iconClass + '" href="' + this.link + '"'+ newWin + '>' + this.title + '</a></li>';
			});

			html = '<ul class="ibm-link-list">' + html + '</ul>';

			// DEBUGGING ONLY. Comment out for production use:
			//console.log("Creating a widget here:", $container, " config: ", config, " using this data: ", data);

			// Echo the widget's HTML into the widget's container.
			$container.html(html);
		}

		// END rssdisplaywidget object constructor
	}
	
})(jQuery, IBMCore);

;

/**

	Same height widget
	<br />
	<br />Automatically calculates the tallest height of the array of elements, and sets each element to that height.
	<br />On the single-column grid (small screen = no grid) it sets height to auto b/c everything is vertically stacked.
	<br />The data-items is a CSS selector string that points to the elements you want to set the height on, relative to the element the attribute is on. 
	<br />
	<br />Usage:
		
		<div data-widget="setsameheight" data-items="> div > div">
		
	@class IBMCore.common.widget.setsameheight

**/

(function ($, IBM) {

	var me = IBM.namespace(IBM, "common.widget.setsameheight"),
    	setsameheights = [],
		object_name = "Same height widget";

	/**
		Public jQuery plug-in definition.
		<br />Used by core v18 JS file to auto-init HTML that exist on the page on DOM ready.
		<br />If you are dynamically injecting and initing the widget HTML post-load, call this plug-in on your injected container.

		@method $.fn.setsameheight
		@param [settings] {Object} Settings to override defaults and element's @data-xxxx attributes.
	**/
	$.fn.setsameheight = function (settings) {
		return this.each(function () {
			var d = createSameHeightWidget(settings);
			d.init($(this));
		});
	};

	/**
		Called by our jQuery plug-in.
		<br />This creates a new sameHeightWidget object and registers the instance into array of all this widget instances.
		<br />The jQuery plugin abstracts this and makes behind-the-scenes changes easy.
		
		@method createSameHeightWidget
		@private
		@param [settings] {Object} Settings to override defaults and element's @data-xxxx attributes.
		@return {Object} The sameHeightWidget object instance created.
	**/
	function createSameHeightWidget (settings) {
		var widget = new sameHeightWidget(settings);
		
		setsameheights.push(widget);
		
		return widget;
	}
	
	/**
		sameHeightWidget object/constructor for our public jQuery plugin.
		<br />Called by "createSameHeightWidget".
		<br />You can't use this directly. Use the standard $(xxxx).setsameheight() plug-in method to initialize the widget.

		@method sameHeightWidget
		@constructor
		@private
		@param [settings] {Object} Settings to override defaults and element's @data-xxxx attributes.
	**/
	function sameHeightWidget (settings) {
		var me = this,
			config = {},
			$container,
			$elArr,
			defaults = {
				always: false
			},
			didResize = false,
			gridSetFor;

		/**
			This is a method of the "sameHeightWidget" constructor.
			<br />Called by our public jQuery plug-in after a new sameHeightWidget object has been created and returned by "createSameHeightWidget".
			<br />Automatically inits the sameHeightWidget plug-in on the passed element, merging in any manually passed settings, 
			 @data-xxxxx settings, and our default settings. 
			<br />This binds the widget to re-eval heights on window resize. Calls 'adjustheights'.
			
			@method init
			@param $elem {jQuery selector} The element you want to turn into a widget.
		**/
		me.init = init;
		function init ($elem) {
			// If we're here, it means it's enabled, so build it/do your thing. 
			// Binds widget object to the DOM element it was init on by jQuery plugin method.
			// Keep "instance" as-is; ALL element-bound widgets will use this data attribute.
			
			$elem.data("widget", me);

			$container = $elem;

			// Merge in configuration to use, then init plug-in with them:  JS settings override HTML which override defaults.
			config = $.extend({}, defaults, $container.data() || {}, settings);

			// Add our little helper that tells us when we're viewing a mobile/small screen zero grid layout.
			if ($("#ibm-sameheight-mobile").length === 0) {
				$("#ibm-content-main").append('<div id="ibm-sameheight-mobile" class="ibm-hidden-xlarge ibm-hidden-large ibm-hidden-medium"></div>');
			}

			// Cache the items. Test to see if this works with dynamic content injected in it.
			$elArr = $($container.data("items"), $container);
			
			$(window).resize(function() {
				didResize = true;
			});

			setInterval(function() {
				if (didResize) {
					didResize = false;
					adjustHeights();
				}
			}, 50);

			// Set grid size class onload.
			adjustHeights();

			$container.addClass("ibm-widget-processed");

			// Wait for any images to be loaded, then init for proper height setting.
			$container.imagesLoaded(function () {
				adjustHeights(true);
			});
	
		}
		
	    /**
			This is a method of the "sameHeightWidget" constructor.
			<br />This does the actual height adjustments on resize. BUT it will only resize the heights if the grid has changed since last time it set the height.
			<br />If you dynamically add/remove/update an item that's part of the item set, you can call this passing it a boolean "true" to 
			  force it to recalculate the heights of the elements.
			
			@method adjustHeights
			@param force {Boolean} Set this to true to force a height recalculation and adjustment. Useful when dynamically changing item contents, or adding/removing items.
		**/
		me.adjustHeights = adjustHeights;
		function adjustHeights (force) {
			var tallest = 0,
				$elArr = $($container.data("items"), $container),
				mobileContinuousResize = ($("#ibm-sameheight-mobile:visible").length === 1 && config.always);

			// If we aren't forcing a resize,
			// and it's not set to continuously resize on mobile.
			//  don't reset the height cuz that's dumb and a waste of cycles.
			if (!force && !mobileContinuousResize && gridSetFor === IBM.common.util.getCurrentGridSize()) {
				return;
			}

			// Store the grid that we set this height for.
			gridSetFor = IBM.common.util.getCurrentGridSize();

			// If our div that only shows on small screens is visible, means things are stacked vertically, so don't set heights,
			//   and instead just set to auto height.
			if ($("#ibm-sameheight-mobile:visible").length === 1 && !config.always) {
				$elArr.height("auto");
				return;
			}

			// Set height to find natural height.
			$elArr.height("auto");
				
			// Find the tallest one in the array.
			$elArr.each(function () {
				var thisHeight = $(this).height();
				
				$(this).find(".ibm-card__bottom").each(function(){
					thisHeight += $(this).height();
				});

				if (thisHeight > tallest) {
					tallest = thisHeight;
				}

				// If it's on mobile and set to always set the height, set it for this individual element.
				if (config.always && $("#ibm-sameheight-mobile:visible").length === 1) {
					$(this).height(thisHeight + "px");
				}
			});

			// If it's on mobile and set to always set the height we set the individual element height so don't do this.
			if (config.always && $("#ibm-sameheight-mobile:visible").length === 1) {
				return;
			}
			// Set all the elements to the tallest height.
			$elArr.height(tallest);
		}
	}
	
})(jQuery, IBMCore);

;

/**
	
	Scrollable plug-in pre-processor. 
	<br />
	<br />Sets defaults for the scrollable plug-in, and other random processing . 
	<br />Then it simply inits the jQuery scollable section plug-in. 
	<br />Usage:
		
	<div data-widget="scrollable">
	
	This uses the Nanoscroll plug-in. <a href="NanoScroll.html">View the documentation</a> for full APIs available.

	@class IBMCore.common.widget.scrollable

**/

(function($, IBM) {

    var me = IBM.namespace(IBM, "common.widget.scrollable"),
    	scrollables = [],
		object_name = "Scrollable";

	/**
		Public jQuery plug-in definition.
		<br />Used by core v18 JS file to auto-init scrollable sections that exist on the page on DOM ready.
		<br />If you are dynamically injecting and initing a scrollable section post-load, call this plug-in on your injected scrollable container.

		@method $.fn.scrollable
		@param [settings] {Object} Settings to override defaults and element's @data-xxxx attributes.
	**/
	$.fn.scrollable = function (settings) {
		return this.each(function(){
			var newScrollable = createScrollable(settings);
			
			newScrollable.init($(this));
		});
	};

	/**
		Called by our jQuery plug-in.
		<br />This creates a new scrollable object and registers the instance into array of all this widget instances.
		<br />The jQuery plugin abstracts this and makes behind-the-scenes changes easy.
		
		@method createScrollable
		@private
		@param [settings] {Object} Settings to override defaults and element's @data-xxxx attributes.
		@return {Object} The scrollable object instance created.
	**/
	function createScrollable (settings) {
		var widget = new Scrollable(settings);
		
		scrollables.push(widget);
		
		return widget;
	}
	
	function Scrollable (settings) {
		var me = this,
			$container,
			config,
			defaults = {
				alwaysVisible: true
			},
			myEvents = IBM.common.util.eventCoordinator(me, object_name, [
				"ready",
				"disabled",
				"error"
			]);

	    /**
			This is a method of the "Scrollable" constructor.
			<br />Called by our public jQuery plug-in after a new Scrollable object has been created and returned by "createScrollable".
			<br />Automatically inits the Scrollable plug-in on the passed element, 
			merging in any manually passed settings, @data-xxxxx settings, and our default settings. 
			
			@method init
			@param {jQuery selector} $elem The element you want to turn into a scrollable.
		**/
		me.init = init;
		function init ($elem) {
			try {
				if (!IBM.common.util.checkClearance("scrollable")) {
					myEvents.publish("disabled");
					return false;
				}

				// If we're here, it means it's enabled, so build it/do your thing. 
				// Binds widget object to the DOM element it was init on by jQuery plugin method.
				// Keep "instance" as-is; ALL element-bound widgets will use this data attribute.
				$elem.data("widget", me);

				$container = $elem;

				$container.css({
					height: $container.data("height") + "px"
				});

				// Merge in configuration to use, then init plug-in with them:  JS settings override HTML which override defaults.
				config = $.extend({}, defaults, $container.data() || {}, settings);

				$container.addClass("nano").wrapInner('<div class="nano-content"></div>');
				$container.nanoScroller(config);

				// Fire an event to tell subscribers we're done.
				myEvents.publish("ready", $elem);

			} 
			catch (er) {
				myEvents.publish("error", er);
				throw er;
			}
		}		
	}

})(jQuery, IBMCore);
;

/*!
 * Select2 4.0.1
 * https://select2.github.io
 *
 * Released under the MIT license
 * https://github.com/select2/select2/blob/master/LICENSE.md
 */
(function (factory) {
  if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module.
    define(['jquery'], factory);
  } else if (typeof exports === 'object') {
    // Node/CommonJS
    factory(require('jquery'));
  } else {
    // Browser globals
    factory(jQuery);
  }
}(function (jQuery) {
  // This is needed so we can catch the AMD loader configuration and use it
  // The inner file should be wrapped (by `banner.start.js`) in a function that
  // returns the AMD loader references.
  var S2 =
(function () {
  // Restore the Select2 AMD loader so it can be used
  // Needed mostly in the language files, where the loader is not inserted
  if (jQuery && jQuery.fn && jQuery.fn.select2 && jQuery.fn.select2.amd) {
    var S2 = jQuery.fn.select2.amd;
  }
var S2;(function () { if (!S2 || !S2.requirejs) {
if (!S2) { S2 = {}; } else { require = S2; }
/**
 * @license almond 0.3.1 Copyright (c) 2011-2014, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/almond for details
 */
//Going sloppy to avoid 'use strict' string cost, but strict practices should
//be followed.
/*jslint sloppy: true */
/*global setTimeout: false */

var requirejs, require, define;
(function (undef) {
    var main, req, makeMap, handlers,
        defined = {},
        waiting = {},
        config = {},
        defining = {},
        hasOwn = Object.prototype.hasOwnProperty,
        aps = [].slice,
        jsSuffixRegExp = /\.js$/;

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    /**
     * Given a relative module name, like ./something, normalize it to
     * a real name that can be mapped to a path.
     * @param {String} name the relative name
     * @param {String} baseName a real name that the name arg is relative
     * to.
     * @returns {String} normalized name
     */
    function normalize(name, baseName) {
        var nameParts, nameSegment, mapValue, foundMap, lastIndex,
            foundI, foundStarMap, starI, i, j, part,
            baseParts = baseName && baseName.split("/"),
            map = config.map,
            starMap = (map && map['*']) || {};

        //Adjust any relative paths.
        if (name && name.charAt(0) === ".") {
            //If have a base name, try to normalize against it,
            //otherwise, assume it is a top-level require that will
            //be relative to baseUrl in the end.
            if (baseName) {
                name = name.split('/');
                lastIndex = name.length - 1;

                // Node .js allowance:
                if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {
                    name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');
                }

                //Lop off the last part of baseParts, so that . matches the
                //"directory" and not name of the baseName's module. For instance,
                //baseName of "one/two/three", maps to "one/two/three.js", but we
                //want the directory, "one/two" for this normalization.
                name = baseParts.slice(0, baseParts.length - 1).concat(name);

                //start trimDots
                for (i = 0; i < name.length; i += 1) {
                    part = name[i];
                    if (part === ".") {
                        name.splice(i, 1);
                        i -= 1;
                    } else if (part === "..") {
                        if (i === 1 && (name[2] === '..' || name[0] === '..')) {
                            //End of the line. Keep at least one non-dot
                            //path segment at the front so it can be mapped
                            //correctly to disk. Otherwise, there is likely
                            //no path mapping for a path starting with '..'.
                            //This can still fail, but catches the most reasonable
                            //uses of ..
                            break;
                        } else if (i > 0) {
                            name.splice(i - 1, 2);
                            i -= 2;
                        }
                    }
                }
                //end trimDots

                name = name.join("/");
            } else if (name.indexOf('./') === 0) {
                // No baseName, so this is ID is resolved relative
                // to baseUrl, pull off the leading dot.
                name = name.substring(2);
            }
        }

        //Apply map config if available.
        if ((baseParts || starMap) && map) {
            nameParts = name.split('/');

            for (i = nameParts.length; i > 0; i -= 1) {
                nameSegment = nameParts.slice(0, i).join("/");

                if (baseParts) {
                    //Find the longest baseName segment match in the config.
                    //So, do joins on the biggest to smallest lengths of baseParts.
                    for (j = baseParts.length; j > 0; j -= 1) {
                        mapValue = map[baseParts.slice(0, j).join('/')];

                        //baseName segment has  config, find if it has one for
                        //this name.
                        if (mapValue) {
                            mapValue = mapValue[nameSegment];
                            if (mapValue) {
                                //Match, update name to the new value.
                                foundMap = mapValue;
                                foundI = i;
                                break;
                            }
                        }
                    }
                }

                if (foundMap) {
                    break;
                }

                //Check for a star map match, but just hold on to it,
                //if there is a shorter segment match later in a matching
                //config, then favor over this star map.
                if (!foundStarMap && starMap && starMap[nameSegment]) {
                    foundStarMap = starMap[nameSegment];
                    starI = i;
                }
            }

            if (!foundMap && foundStarMap) {
                foundMap = foundStarMap;
                foundI = starI;
            }

            if (foundMap) {
                nameParts.splice(0, foundI, foundMap);
                name = nameParts.join('/');
            }
        }

        return name;
    }

    function makeRequire(relName, forceSync) {
        return function () {
            //A version of a require function that passes a moduleName
            //value for items that may need to
            //look up paths relative to the moduleName
            var args = aps.call(arguments, 0);

            //If first arg is not require('string'), and there is only
            //one arg, it is the array form without a callback. Insert
            //a null so that the following concat is correct.
            if (typeof args[0] !== 'string' && args.length === 1) {
                args.push(null);
            }
            return req.apply(undef, args.concat([relName, forceSync]));
        };
    }

    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(depName) {
        return function (value) {
            defined[depName] = value;
        };
    }

    function callDep(name) {
        if (hasProp(waiting, name)) {
            var args = waiting[name];
            delete waiting[name];
            defining[name] = true;
            main.apply(undef, args);
        }

        if (!hasProp(defined, name) && !hasProp(defining, name)) {
            throw new Error('No ' + name);
        }
        return defined[name];
    }

    //Turns a plugin!resource to [plugin, resource]
    //with the plugin being undefined if the name
    //did not have a plugin prefix.
    function splitPrefix(name) {
        var prefix,
            index = name ? name.indexOf('!') : -1;
        if (index > -1) {
            prefix = name.substring(0, index);
            name = name.substring(index + 1, name.length);
        }
        return [prefix, name];
    }

    /**
     * Makes a name map, normalizing the name, and using a plugin
     * for normalization if necessary. Grabs a ref to plugin
     * too, as an optimization.
     */
    makeMap = function (name, relName) {
        var plugin,
            parts = splitPrefix(name),
            prefix = parts[0];

        name = parts[1];

        if (prefix) {
            prefix = normalize(prefix, relName);
            plugin = callDep(prefix);
        }

        //Normalize according
        if (prefix) {
            if (plugin && plugin.normalize) {
                name = plugin.normalize(name, makeNormalize(relName));
            } else {
                name = normalize(name, relName);
            }
        } else {
            name = normalize(name, relName);
            parts = splitPrefix(name);
            prefix = parts[0];
            name = parts[1];
            if (prefix) {
                plugin = callDep(prefix);
            }
        }

        //Using ridiculous property names for space reasons
        return {
            f: prefix ? prefix + '!' + name : name, //fullName
            n: name,
            pr: prefix,
            p: plugin
        };
    };

    function makeConfig(name) {
        return function () {
            return (config && config.config && config.config[name]) || {};
        };
    }

    handlers = {
        require: function (name) {
            return makeRequire(name);
        },
        exports: function (name) {
            var e = defined[name];
            if (typeof e !== 'undefined') {
                return e;
            } else {
                return (defined[name] = {});
            }
        },
        module: function (name) {
            return {
                id: name,
                uri: '',
                exports: defined[name],
                config: makeConfig(name)
            };
        }
    };

    main = function (name, deps, callback, relName) {
        var cjsModule, depName, ret, map, i,
            args = [],
            callbackType = typeof callback,
            usingExports;

        //Use name if no relName
        relName = relName || name;

        //Call the callback to define the module, if necessary.
        if (callbackType === 'undefined' || callbackType === 'function') {
            //Pull out the defined dependencies and pass the ordered
            //values to the callback.
            //Default to [require, exports, module] if no deps
            deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;
            for (i = 0; i < deps.length; i += 1) {
                map = makeMap(deps[i], relName);
                depName = map.f;

                //Fast path CommonJS standard dependencies.
                if (depName === "require") {
                    args[i] = handlers.require(name);
                } else if (depName === "exports") {
                    //CommonJS module spec 1.1
                    args[i] = handlers.exports(name);
                    usingExports = true;
                } else if (depName === "module") {
                    //CommonJS module spec 1.1
                    cjsModule = args[i] = handlers.module(name);
                } else if (hasProp(defined, depName) ||
                           hasProp(waiting, depName) ||
                           hasProp(defining, depName)) {
                    args[i] = callDep(depName);
                } else if (map.p) {
                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});
                    args[i] = defined[depName];
                } else {
                    throw new Error(name + ' missing ' + depName);
                }
            }

            ret = callback ? callback.apply(defined[name], args) : undefined;

            if (name) {
                //If setting exports via "module" is in play,
                //favor that over return value and exports. After that,
                //favor a non-undefined return value over exports use.
                if (cjsModule && cjsModule.exports !== undef &&
                        cjsModule.exports !== defined[name]) {
                    defined[name] = cjsModule.exports;
                } else if (ret !== undef || !usingExports) {
                    //Use the return value from the function.
                    defined[name] = ret;
                }
            }
        } else if (name) {
            //May just be an object definition for the module. Only
            //worry about defining if have a module name.
            defined[name] = callback;
        }
    };

    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {
        if (typeof deps === "string") {
            if (handlers[deps]) {
                //callback in this case is really relName
                return handlers[deps](callback);
            }
            //Just return the module wanted. In this scenario, the
            //deps arg is the module name, and second arg (if passed)
            //is just the relName.
            //Normalize module name, if it contains . or ..
            return callDep(makeMap(deps, callback).f);
        } else if (!deps.splice) {
            //deps is a config object, not an array.
            config = deps;
            if (config.deps) {
                req(config.deps, config.callback);
            }
            if (!callback) {
                return;
            }

            if (callback.splice) {
                //callback is an array, which means it is a dependency list.
                //Adjust args if there are dependencies
                deps = callback;
                callback = relName;
                relName = null;
            } else {
                deps = undef;
            }
        }

        //Support require(['a'])
        callback = callback || function () {};

        //If relName is a function, it is an errback handler,
        //so remove it.
        if (typeof relName === 'function') {
            relName = forceSync;
            forceSync = alt;
        }

        //Simulate async callback;
        if (forceSync) {
            main(undef, deps, callback, relName);
        } else {
            //Using a non-zero value because of concern for what old browsers
            //do, and latest browsers "upgrade" to 4 if lower value is used:
            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:
            //If want a value immediately, use require('id') instead -- something
            //that works in almond on the global level, but not guaranteed and
            //unlikely to work in other AMD implementations.
            setTimeout(function () {
                main(undef, deps, callback, relName);
            }, 4);
        }

        return req;
    };

    /**
     * Just drops the config on the floor, but returns req in case
     * the config return value is used.
     */
    req.config = function (cfg) {
        return req(cfg);
    };

    /**
     * Expose module registry for debugging and tooling
     */
    requirejs._defined = defined;

    define = function (name, deps, callback) {
        if (typeof name !== 'string') {
            throw new Error('See almond README: incorrect module build, no module name');
        }

        //This module may not have dependencies
        if (!deps.splice) {
            //deps is not an array, so probably means
            //an object literal or factory function for
            //the value. Adjust args.
            callback = deps;
            deps = [];
        }

        if (!hasProp(defined, name) && !hasProp(waiting, name)) {
            waiting[name] = [name, deps, callback];
        }
    };

    define.amd = {
        jQuery: true
    };
}());

S2.requirejs = requirejs;S2.require = require;S2.define = define;
}
}());
S2.define("almond", function(){});

/* global jQuery:false, $:false */
S2.define('jquery',[],function () {
  var _$ = jQuery || $;

  if (_$ == null && console && console.error) {
    console.error(
      'Select2: An instance of jQuery or a jQuery-compatible library was not ' +
      'found. Make sure that you are including jQuery before Select2 on your ' +
      'web page.'
    );
  }

  return _$;
});

S2.define('select2/utils',[
  'jquery'
], function ($) {
  var Utils = {};

  Utils.Extend = function (ChildClass, SuperClass) {
    var __hasProp = {}.hasOwnProperty;

    function BaseConstructor () {
      this.constructor = ChildClass;
    }

    for (var key in SuperClass) {
      if (__hasProp.call(SuperClass, key)) {
        ChildClass[key] = SuperClass[key];
      }
    }

    BaseConstructor.prototype = SuperClass.prototype;
    ChildClass.prototype = new BaseConstructor();
    ChildClass.__super__ = SuperClass.prototype;

    return ChildClass;
  };

  function getMethods (theClass) {
    var proto = theClass.prototype;

    var methods = [];

    for (var methodName in proto) {
      var m = proto[methodName];

      if (typeof m !== 'function') {
        continue;
      }

      if (methodName === 'constructor') {
        continue;
      }

      methods.push(methodName);
    }

    return methods;
  }

  Utils.Decorate = function (SuperClass, DecoratorClass) {
    var decoratedMethods = getMethods(DecoratorClass);
    var superMethods = getMethods(SuperClass);

    function DecoratedClass () {
      var unshift = Array.prototype.unshift;

      var argCount = DecoratorClass.prototype.constructor.length;

      var calledConstructor = SuperClass.prototype.constructor;

      if (argCount > 0) {
        unshift.call(arguments, SuperClass.prototype.constructor);

        calledConstructor = DecoratorClass.prototype.constructor;
      }

      calledConstructor.apply(this, arguments);
    }

    DecoratorClass.displayName = SuperClass.displayName;

    function ctr () {
      this.constructor = DecoratedClass;
    }

    DecoratedClass.prototype = new ctr();

    for (var m = 0; m < superMethods.length; m++) {
        var superMethod = superMethods[m];

        DecoratedClass.prototype[superMethod] =
          SuperClass.prototype[superMethod];
    }

    var calledMethod = function (methodName) {
      // Stub out the original method if it's not decorating an actual method
      var originalMethod = function () {};

      if (methodName in DecoratedClass.prototype) {
        originalMethod = DecoratedClass.prototype[methodName];
      }

      var decoratedMethod = DecoratorClass.prototype[methodName];

      return function () {
        var unshift = Array.prototype.unshift;

        unshift.call(arguments, originalMethod);

        return decoratedMethod.apply(this, arguments);
      };
    };

    for (var d = 0; d < decoratedMethods.length; d++) {
      var decoratedMethod = decoratedMethods[d];

      DecoratedClass.prototype[decoratedMethod] = calledMethod(decoratedMethod);
    }

    return DecoratedClass;
  };

  var Observable = function () {
    this.listeners = {};
  };

  Observable.prototype.on = function (event, callback) {
    this.listeners = this.listeners || {};

    if (event in this.listeners) {
      this.listeners[event].push(callback);
    } else {
      this.listeners[event] = [callback];
    }
  };

  Observable.prototype.trigger = function (event) {
    var slice = Array.prototype.slice;

    this.listeners = this.listeners || {};

    if (event in this.listeners) {
      this.invoke(this.listeners[event], slice.call(arguments, 1));
    }

    if ('*' in this.listeners) {
      this.invoke(this.listeners['*'], arguments);
    }
  };

  Observable.prototype.invoke = function (listeners, params) {
    for (var i = 0, len = listeners.length; i < len; i++) {
      listeners[i].apply(this, params);
    }
  };

  Utils.Observable = Observable;

  Utils.generateChars = function (length) {
    var chars = '';

    for (var i = 0; i < length; i++) {
      var randomChar = Math.floor(Math.random() * 36);
      chars += randomChar.toString(36);
    }

    return chars;
  };

  Utils.bind = function (func, context) {
    return function () {
      func.apply(context, arguments);
    };
  };

  Utils._convertData = function (data) {
    for (var originalKey in data) {
      var keys = originalKey.split('-');

      var dataLevel = data;

      if (keys.length === 1) {
        continue;
      }

      for (var k = 0; k < keys.length; k++) {
        var key = keys[k];

        // Lowercase the first letter
        // By default, dash-separated becomes camelCase
        key = key.substring(0, 1).toLowerCase() + key.substring(1);

        if (!(key in dataLevel)) {
          dataLevel[key] = {};
        }

        if (k == keys.length - 1) {
          dataLevel[key] = data[originalKey];
        }

        dataLevel = dataLevel[key];
      }

      delete data[originalKey];
    }

    return data;
  };

  Utils.hasScroll = function (index, el) {
    // Adapted from the function created by @ShadowScripter
    // and adapted by @BillBarry on the Stack Exchange Code Review website.
    // The original code can be found at
    // http://codereview.stackexchange.com/q/13338
    // and was designed to be used with the Sizzle selector engine.

    var $el = $(el);
    var overflowX = el.style.overflowX;
    var overflowY = el.style.overflowY;

    //Check both x and y declarations
    if (overflowX === overflowY &&
        (overflowY === 'hidden' || overflowY === 'visible')) {
      return false;
    }

    if (overflowX === 'scroll' || overflowY === 'scroll') {
      return true;
    }

    return ($el.innerHeight() < el.scrollHeight ||
      $el.innerWidth() < el.scrollWidth);
  };

  Utils.escapeMarkup = function (markup) {
    var replaceMap = {
      '\\': '&#92;',
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      '\'': '&#39;',
      '/': '&#47;'
    };

    // Do not try to escape the markup if it's not a string
    if (typeof markup !== 'string') {
      return markup;
    }

    return String(markup).replace(/[&<>"'\/\\]/g, function (match) {
      return replaceMap[match];
    });
  };

  // Append an array of jQuery nodes to a given element.
  Utils.appendMany = function ($element, $nodes) {
    // jQuery 1.7.x does not support $.fn.append() with an array
    // Fall back to a jQuery object collection using $.fn.add()
    if ($.fn.jquery.substr(0, 3) === '1.7') {
      var $jqNodes = $();

      $.map($nodes, function (node) {
        $jqNodes = $jqNodes.add(node);
      });

      $nodes = $jqNodes;
    }

    $element.append($nodes);
  };

  return Utils;
});

S2.define('select2/results',[
  'jquery',
  './utils'
], function ($, Utils) {
  function Results ($element, options, dataAdapter) {
    this.$element = $element;
    this.data = dataAdapter;
    this.options = options;

    Results.__super__.constructor.call(this);
  }

  Utils.Extend(Results, Utils.Observable);

  Results.prototype.render = function () {
    var $results = $(
      '<ul class="select2-results__options" role="tree"></ul>'
    );

    if (this.options.get('multiple')) {
      $results.attr('aria-multiselectable', 'true');
    }

    this.$results = $results;

    return $results;
  };

  Results.prototype.clear = function () {
    this.$results.empty();
  };

  Results.prototype.displayMessage = function (params) {
    var escapeMarkup = this.options.get('escapeMarkup');

    this.clear();
    this.hideLoading();

    var $message = $(
      '<li role="treeitem" aria-live="assertive"' +
      ' class="select2-results__option"></li>'
    );

    var message = this.options.get('translations').get(params.message);

    $message.append(
      escapeMarkup(
        message(params.args)
      )
    );

    $message[0].className += ' select2-results__message';

    this.$results.append($message);
  };

  Results.prototype.hideMessages = function () {
    this.$results.find('.select2-results__message').remove();
  };

  Results.prototype.append = function (data) {
    this.hideLoading();

    var $options = [];

    if (data.results == null || data.results.length === 0) {
      if (this.$results.children().length === 0) {
        this.trigger('results:message', {
          message: 'noResults'
        });
      }

      return;
    }

    data.results = this.sort(data.results);

    for (var d = 0; d < data.results.length; d++) {
      var item = data.results[d];

      var $option = this.option(item);

      $options.push($option);
    }

    this.$results.append($options);
  };

  Results.prototype.position = function ($results, $dropdown) {
    var $resultsContainer = $dropdown.find('.select2-results');
    $resultsContainer.append($results);
  };

  Results.prototype.sort = function (data) {
    var sorter = this.options.get('sorter');

    return sorter(data);
  };

  Results.prototype.setClasses = function () {
    var self = this;

    this.data.current(function (selected) {
      var selectedIds = $.map(selected, function (s) {
        return s.id.toString();
      });

      var $options = self.$results
        .find('.select2-results__option[aria-selected]');

      $options.each(function () {
        var $option = $(this);

        var item = $.data(this, 'data');

        // id needs to be converted to a string when comparing
        var id = '' + item.id;

        if ((item.element != null && item.element.selected) ||
            (item.element == null && $.inArray(id, selectedIds) > -1)) {
          $option.attr('aria-selected', 'true');
        } else {
          $option.attr('aria-selected', 'false');
        }
      });

      var $selected = $options.filter('[aria-selected=true]');

      // Check if there are any selected options
      if ($selected.length > 0) {
        // If there are selected options, highlight the first
        $selected.first().trigger('mouseenter');
      } else {
        // If there are no selected options, highlight the first option
        // in the dropdown
        $options.first().trigger('mouseenter');
      }
    });
  };

  Results.prototype.showLoading = function (params) {
    this.hideLoading();

    var loadingMore = this.options.get('translations').get('searching');

    var loading = {
      disabled: true,
      loading: true,
      text: loadingMore(params)
    };
    var $loading = this.option(loading);
    $loading.className += ' loading-results';

    this.$results.prepend($loading);
  };

  Results.prototype.hideLoading = function () {
    this.$results.find('.loading-results').remove();
  };

  Results.prototype.option = function (data) {
    var option = document.createElement('li');
    option.className = 'select2-results__option';

    var attrs = {
      'role': 'treeitem',
      'aria-selected': 'false'
    };

    if (data.disabled) {
      delete attrs['aria-selected'];
      attrs['aria-disabled'] = 'true';
    }

    if (data.id == null) {
      delete attrs['aria-selected'];
    }

    if (data._resultId != null) {
      option.id = data._resultId;
    }

    if (data.title) {
      option.title = data.title;
    }

    if (data.children) {
      attrs.role = 'group';
      attrs['aria-label'] = data.text;
      delete attrs['aria-selected'];
    }

    for (var attr in attrs) {
      var val = attrs[attr];

      option.setAttribute(attr, val);
    }

    if (data.children) {
      var $option = $(option);

      var label = document.createElement('strong');
      label.className = 'select2-results__group';

      var $label = $(label);
      this.template(data, label);

      var $children = [];

      for (var c = 0; c < data.children.length; c++) {
        var child = data.children[c];

        var $child = this.option(child);

        $children.push($child);
      }

      var $childrenContainer = $('<ul></ul>', {
        'class': 'select2-results__options select2-results__options--nested'
      });

      $childrenContainer.append($children);

      $option.append(label);
      $option.append($childrenContainer);
    } else {
      this.template(data, option);
    }

    $.data(option, 'data', data);

    return option;
  };

  Results.prototype.bind = function (container, $container) {
    var self = this;

    var id = container.id + '-results';

    this.$results.attr('id', id);

    container.on('results:all', function (params) {
      self.clear();
      self.append(params.data);

      if (container.isOpen()) {
        self.setClasses();
      }
    });

    container.on('results:append', function (params) {
      self.append(params.data);

      if (container.isOpen()) {
        self.setClasses();
      }
    });

    container.on('query', function (params) {
      self.hideMessages();
      self.showLoading(params);
    });

    container.on('select', function () {
      if (!container.isOpen()) {
        return;
      }

      self.setClasses();
    });

    container.on('unselect', function () {
      if (!container.isOpen()) {
        return;
      }

      self.setClasses();
    });

    container.on('open', function () {
      // When the dropdown is open, aria-expended="true"
      self.$results.attr('aria-expanded', 'true');
      self.$results.attr('aria-hidden', 'false');

      self.setClasses();
      self.ensureHighlightVisible();
    });

    container.on('close', function () {
      // When the dropdown is closed, aria-expended="false"
      self.$results.attr('aria-expanded', 'false');
      self.$results.attr('aria-hidden', 'true');
      self.$results.removeAttr('aria-activedescendant');
    });

    container.on('results:toggle', function () {
      var $highlighted = self.getHighlightedResults();

      if ($highlighted.length === 0) {
        return;
      }

      $highlighted.trigger('mouseup');
    });

    container.on('results:select', function () {
      var $highlighted = self.getHighlightedResults();

      if ($highlighted.length === 0) {
        return;
      }

      var data = $highlighted.data('data');

      if ($highlighted.attr('aria-selected') == 'true') {
        self.trigger('close', {});
      } else {
        self.trigger('select', {
          data: data
        });
      }
    });

    container.on('results:previous', function () {
      var $highlighted = self.getHighlightedResults();

      var $options = self.$results.find('[aria-selected]');

      var currentIndex = $options.index($highlighted);

      // If we are already at te top, don't move further
      if (currentIndex === 0) {
        return;
      }

      var nextIndex = currentIndex - 1;

      // If none are highlighted, highlight the first
      if ($highlighted.length === 0) {
        nextIndex = 0;
      }

      var $next = $options.eq(nextIndex);

      $next.trigger('mouseenter');

      var currentOffset = self.$results.offset().top;
      var nextTop = $next.offset().top;
      var nextOffset = self.$results.scrollTop() + (nextTop - currentOffset);

      if (nextIndex === 0) {
        self.$results.scrollTop(0);
      } else if (nextTop - currentOffset < 0) {
        self.$results.scrollTop(nextOffset);
      }
    });

    container.on('results:next', function () {
      var $highlighted = self.getHighlightedResults();

      var $options = self.$results.find('[aria-selected]');

      var currentIndex = $options.index($highlighted);

      var nextIndex = currentIndex + 1;

      // If we are at the last option, stay there
      if (nextIndex >= $options.length) {
        return;
      }

      var $next = $options.eq(nextIndex);

      $next.trigger('mouseenter');

      var currentOffset = self.$results.offset().top +
        self.$results.outerHeight(false);
      var nextBottom = $next.offset().top + $next.outerHeight(false);
      var nextOffset = self.$results.scrollTop() + nextBottom - currentOffset;

      if (nextIndex === 0) {
        self.$results.scrollTop(0);
      } else if (nextBottom > currentOffset) {
        self.$results.scrollTop(nextOffset);
      }
    });

    container.on('results:focus', function (params) {
      params.element.addClass('select2-results__option--highlighted');
    });

    container.on('results:message', function (params) {
      self.displayMessage(params);
    });

    if ($.fn.mousewheel) {
      this.$results.on('mousewheel', function (e) {
        var top = self.$results.scrollTop();

        var bottom = (
          self.$results.get(0).scrollHeight -
          self.$results.scrollTop() +
          e.deltaY
        );

        var isAtTop = e.deltaY > 0 && top - e.deltaY <= 0;
        var isAtBottom = e.deltaY < 0 && bottom <= self.$results.height();

        if (isAtTop) {
          self.$results.scrollTop(0);

          e.preventDefault();
          e.stopPropagation();
        } else if (isAtBottom) {
          self.$results.scrollTop(
            self.$results.get(0).scrollHeight - self.$results.height()
          );

          e.preventDefault();
          e.stopPropagation();
        }
      });
    }

    this.$results.on('mouseup', '.select2-results__option[aria-selected]',
      function (evt) {
      var $this = $(this);

      var data = $this.data('data');

      if ($this.attr('aria-selected') === 'true') {
        if (self.options.get('multiple')) {
          self.trigger('unselect', {
            originalEvent: evt,
            data: data
          });
        } else {
          self.trigger('close', {});
        }

        return;
      }

      self.trigger('select', {
        originalEvent: evt,
        data: data
      });
    });

    this.$results.on('mouseenter', '.select2-results__option[aria-selected]',
      function (evt) {
      var data = $(this).data('data');

      self.getHighlightedResults()
          .removeClass('select2-results__option--highlighted');

      self.trigger('results:focus', {
        data: data,
        element: $(this)
      });
    });
  };

  Results.prototype.getHighlightedResults = function () {
    var $highlighted = this.$results
    .find('.select2-results__option--highlighted');

    return $highlighted;
  };

  Results.prototype.destroy = function () {
    this.$results.remove();
  };

  Results.prototype.ensureHighlightVisible = function () {
    var $highlighted = this.getHighlightedResults();

    if ($highlighted.length === 0) {
      return;
    }

    var $options = this.$results.find('[aria-selected]');

    var currentIndex = $options.index($highlighted);

    var currentOffset = this.$results.offset().top;
    var nextTop = $highlighted.offset().top;
    var nextOffset = this.$results.scrollTop() + (nextTop - currentOffset);

    var offsetDelta = nextTop - currentOffset;
    nextOffset -= $highlighted.outerHeight(false) * 2;

    if (currentIndex <= 2) {
      this.$results.scrollTop(0);
    } else if (offsetDelta > this.$results.outerHeight() || offsetDelta < 0) {
      this.$results.scrollTop(nextOffset);
    }
  };

  Results.prototype.template = function (result, container) {
    var template = this.options.get('templateResult');
    var escapeMarkup = this.options.get('escapeMarkup');

    var content = template(result, container);

    if (content == null) {
      container.style.display = 'none';
    } else if (typeof content === 'string') {
      container.innerHTML = escapeMarkup(content);
    } else {
      $(container).append(content);
    }
  };

  return Results;
});

S2.define('select2/keys',[

], function () {
  var KEYS = {
    BACKSPACE: 8,
    TAB: 9,
    ENTER: 13,
    SHIFT: 16,
    CTRL: 17,
    ALT: 18,
    ESC: 27,
    SPACE: 32,
    PAGE_UP: 33,
    PAGE_DOWN: 34,
    END: 35,
    HOME: 36,
    LEFT: 37,
    UP: 38,
    RIGHT: 39,
    DOWN: 40,
    DELETE: 46
  };

  return KEYS;
});

S2.define('select2/selection/base',[
  'jquery',
  '../utils',
  '../keys'
], function ($, Utils, KEYS) {
  function BaseSelection ($element, options) {
    this.$element = $element;
    this.options = options;

    BaseSelection.__super__.constructor.call(this);
  }

  Utils.Extend(BaseSelection, Utils.Observable);

  BaseSelection.prototype.render = function () {
    var $selection = $(
      '<span class="select2-selection" role="combobox" ' +
      ' aria-haspopup="true" aria-expanded="false">' +
      '</span>'
    );

    this._tabindex = 0;

    if (this.$element.data('old-tabindex') != null) {
      this._tabindex = this.$element.data('old-tabindex');
    } else if (this.$element.attr('tabindex') != null) {
      this._tabindex = this.$element.attr('tabindex');
    }

    $selection.attr('title', this.$element.attr('title'));
    $selection.attr('tabindex', this._tabindex);

    this.$selection = $selection;

    return $selection;
  };

  BaseSelection.prototype.bind = function (container, $container) {
    var self = this;

    var id = container.id + '-container';
    var resultsId = container.id + '-results';

    this.container = container;

    this.$selection.on('focus', function (evt) {
      self.trigger('focus', evt);
    });

    this.$selection.on('blur', function (evt) {
      self._handleBlur(evt);
    });

    this.$selection.on('keydown', function (evt) {
      self.trigger('keypress', evt);

      if (evt.which === KEYS.SPACE) {
        evt.preventDefault();
      }
    });

    container.on('results:focus', function (params) {
      self.$selection.attr('aria-activedescendant', params.data._resultId);
    });

    container.on('selection:update', function (params) {
      self.update(params.data);
    });

    container.on('open', function () {
      // When the dropdown is open, aria-expanded="true"
      self.$selection.attr('aria-expanded', 'true');
      self.$selection.attr('aria-owns', resultsId);

      self._attachCloseHandler(container);
    });

    container.on('close', function () {
      // When the dropdown is closed, aria-expanded="false"
      self.$selection.attr('aria-expanded', 'false');
      self.$selection.removeAttr('aria-activedescendant');
      self.$selection.removeAttr('aria-owns');

      self.$selection.focus();

      self._detachCloseHandler(container);
    });

    container.on('enable', function () {
      self.$selection.attr('tabindex', self._tabindex);
    });

    container.on('disable', function () {
      self.$selection.attr('tabindex', '-1');
    });
  };

  BaseSelection.prototype._handleBlur = function (evt) {
    var self = this;

    // This needs to be delayed as the active element is the body when the tab
    // key is pressed, possibly along with others.
    window.setTimeout(function () {
      // Don't trigger `blur` if the focus is still in the selection
      if (
        (document.activeElement == self.$selection[0]) ||
        ($.contains(self.$selection[0], document.activeElement))
      ) {
        return;
      }

      self.trigger('blur', evt);
    }, 1);
  };

  BaseSelection.prototype._attachCloseHandler = function (container) {
    var self = this;

    $(document.body).on('mousedown.select2.' + container.id, function (e) {
      var $target = $(e.target);

      var $select = $target.closest('.select2');

      var $all = $('.select2.select2-container--open');

      $all.each(function () {
        var $this = $(this);

        if (this == $select[0]) {
          return;
        }

        var $element = $this.data('element');

        $element.select2('close');
      });
    });
  };

  BaseSelection.prototype._detachCloseHandler = function (container) {
    $(document.body).off('mousedown.select2.' + container.id);
  };

  BaseSelection.prototype.position = function ($selection, $container) {
    var $selectionContainer = $container.find('.selection');
    $selectionContainer.append($selection);
  };

  BaseSelection.prototype.destroy = function () {
    this._detachCloseHandler(this.container);
  };

  BaseSelection.prototype.update = function (data) {
    throw new Error('The `update` method must be defined in child classes.');
  };

  return BaseSelection;
});

S2.define('select2/selection/single',[
  'jquery',
  './base',
  '../utils',
  '../keys'
], function ($, BaseSelection, Utils, KEYS) {
  function SingleSelection () {
    SingleSelection.__super__.constructor.apply(this, arguments);
  }

  Utils.Extend(SingleSelection, BaseSelection);

  SingleSelection.prototype.render = function () {
    var $selection = SingleSelection.__super__.render.call(this);

    $selection.addClass('select2-selection--single');

    $selection.html(
      '<span class="select2-selection__rendered"></span>' +
      '<span class="select2-selection__arrow" role="presentation">' +
        '<b role="presentation"></b>' +
      '</span>'
    );

    return $selection;
  };

  SingleSelection.prototype.bind = function (container, $container) {
    var self = this;

    SingleSelection.__super__.bind.apply(this, arguments);

    var id = container.id + '-container';

    this.$selection.find('.select2-selection__rendered').attr('id', id);
    this.$selection.attr('aria-labelledby', id);

    this.$selection.on('mousedown', function (evt) {
      // Only respond to left clicks
      if (evt.which !== 1) {
        return;
      }

      self.trigger('toggle', {
        originalEvent: evt
      });
    });

    this.$selection.on('focus', function (evt) {
      // User focuses on the container
    });

    this.$selection.on('blur', function (evt) {
      // User exits the container
    });

    container.on('selection:update', function (params) {
      self.update(params.data);
    });
  };

  SingleSelection.prototype.clear = function () {
    this.$selection.find('.select2-selection__rendered').empty();
  };

  SingleSelection.prototype.display = function (data, container) {
    var template = this.options.get('templateSelection');
    var escapeMarkup = this.options.get('escapeMarkup');

    return escapeMarkup(template(data, container));
  };

  SingleSelection.prototype.selectionContainer = function () {
    return $('<span></span>');
  };

  SingleSelection.prototype.update = function (data) {
    if (data.length === 0) {
      this.clear();
      return;
    }

    var selection = data[0];

    var $rendered = this.$selection.find('.select2-selection__rendered');
    var formatted = this.display(selection, $rendered);

    $rendered.empty().append(formatted);
    $rendered.prop('title', selection.title || selection.text);
  };

  return SingleSelection;
});

S2.define('select2/selection/multiple',[
  'jquery',
  './base',
  '../utils'
], function ($, BaseSelection, Utils) {
  function MultipleSelection ($element, options) {
    MultipleSelection.__super__.constructor.apply(this, arguments);
  }

  Utils.Extend(MultipleSelection, BaseSelection);

  MultipleSelection.prototype.render = function () {
    var $selection = MultipleSelection.__super__.render.call(this);

    $selection.addClass('select2-selection--multiple');

    $selection.html(
      '<ul class="select2-selection__rendered"></ul>'
    );

    return $selection;
  };

  MultipleSelection.prototype.bind = function (container, $container) {
    var self = this;

    MultipleSelection.__super__.bind.apply(this, arguments);

    this.$selection.on('click', function (evt) {
      self.trigger('toggle', {
        originalEvent: evt
      });
    });

    this.$selection.on(
      'click',
      '.select2-selection__choice__remove',
      function (evt) {
        // Ignore the event if it is disabled
        if (self.options.get('disabled')) {
          return;
        }

        var $remove = $(this);
        var $selection = $remove.parent();

        var data = $selection.data('data');

        self.trigger('unselect', {
          originalEvent: evt,
          data: data
        });
      }
    );
  };

  MultipleSelection.prototype.clear = function () {
    this.$selection.find('.select2-selection__rendered').empty();
  };

  MultipleSelection.prototype.display = function (data, container) {
    var template = this.options.get('templateSelection');
    var escapeMarkup = this.options.get('escapeMarkup');

    return escapeMarkup(template(data, container));
  };

  MultipleSelection.prototype.selectionContainer = function () {
    var $container = $(
      '<li class="select2-selection__choice">' +
        '<span class="select2-selection__choice__remove" role="presentation">' +
          '&times;' +
        '</span>' +
      '</li>'
    );

    return $container;
  };

  MultipleSelection.prototype.update = function (data) {
    this.clear();

    if (data.length === 0) {
      return;
    }

    var $selections = [];

    for (var d = 0; d < data.length; d++) {
      var selection = data[d];

      var $selection = this.selectionContainer();
      var formatted = this.display(selection, $selection);

      $selection.append(formatted);
      $selection.prop('title', selection.title || selection.text);

      $selection.data('data', selection);

      $selections.push($selection);
    }

    var $rendered = this.$selection.find('.select2-selection__rendered');

    Utils.appendMany($rendered, $selections);
  };

  return MultipleSelection;
});

S2.define('select2/selection/placeholder',[
  '../utils'
], function (Utils) {
  function Placeholder (decorated, $element, options) {
    this.placeholder = this.normalizePlaceholder(options.get('placeholder'));

    decorated.call(this, $element, options);
  }

  Placeholder.prototype.normalizePlaceholder = function (_, placeholder) {
    if (typeof placeholder === 'string') {
      placeholder = {
        id: '',
        text: placeholder
      };
    }

    return placeholder;
  };

  Placeholder.prototype.createPlaceholder = function (decorated, placeholder) {
    var $placeholder = this.selectionContainer();

    $placeholder.html(this.display(placeholder));
    $placeholder.addClass('select2-selection__placeholder')
                .removeClass('select2-selection__choice');

    return $placeholder;
  };

  Placeholder.prototype.update = function (decorated, data) {
    var singlePlaceholder = (
      data.length == 1 && data[0].id != this.placeholder.id
    );
    var multipleSelections = data.length > 1;

    if (multipleSelections || singlePlaceholder) {
      return decorated.call(this, data);
    }

    this.clear();

    var $placeholder = this.createPlaceholder(this.placeholder);

    this.$selection.find('.select2-selection__rendered').append($placeholder);
  };

  return Placeholder;
});

S2.define('select2/selection/allowClear',[
  'jquery',
  '../keys'
], function ($, KEYS) {
  function AllowClear () { }

  AllowClear.prototype.bind = function (decorated, container, $container) {
    var self = this;

    decorated.call(this, container, $container);

    if (this.placeholder == null) {
      if (this.options.get('debug') && window.console && console.error) {
        console.error(
          'Select2: The `allowClear` option should be used in combination ' +
          'with the `placeholder` option.'
        );
      }
    }

    this.$selection.on('mousedown', '.select2-selection__clear',
      function (evt) {
        self._handleClear(evt);
    });

    container.on('keypress', function (evt) {
      self._handleKeyboardClear(evt, container);
    });
  };

  AllowClear.prototype._handleClear = function (_, evt) {
    // Ignore the event if it is disabled
    if (this.options.get('disabled')) {
      return;
    }

    var $clear = this.$selection.find('.select2-selection__clear');

    // Ignore the event if nothing has been selected
    if ($clear.length === 0) {
      return;
    }

    evt.stopPropagation();

    var data = $clear.data('data');

    for (var d = 0; d < data.length; d++) {
      var unselectData = {
        data: data[d]
      };

      // Trigger the `unselect` event, so people can prevent it from being
      // cleared.
      this.trigger('unselect', unselectData);

      // If the event was prevented, don't clear it out.
      if (unselectData.prevented) {
        return;
      }
    }

    this.$element.val(this.placeholder.id).trigger('change');

    this.trigger('toggle', {});
  };

  AllowClear.prototype._handleKeyboardClear = function (_, evt, container) {
    if (container.isOpen()) {
      return;
    }

    if (evt.which == KEYS.DELETE || evt.which == KEYS.BACKSPACE) {
      this._handleClear(evt);
    }
  };

  AllowClear.prototype.update = function (decorated, data) {
    decorated.call(this, data);

    if (this.$selection.find('.select2-selection__placeholder').length > 0 ||
        data.length === 0) {
      return;
    }

    var $remove = $(
      '<span class="select2-selection__clear">' +
        '&times;' +
      '</span>'
    );
    $remove.data('data', data);

    this.$selection.find('.select2-selection__rendered').prepend($remove);
  };

  return AllowClear;
});

S2.define('select2/selection/search',[
  'jquery',
  '../utils',
  '../keys'
], function ($, Utils, KEYS) {
  function Search (decorated, $element, options) {
    decorated.call(this, $element, options);
  }

  Search.prototype.render = function (decorated) {
    var $search = $(
      '<li class="select2-search select2-search--inline">' +
        '<input class="select2-search__field" type="search" tabindex="-1"' +
        ' autocomplete="off" autocorrect="off" autocapitalize="off"' +
        ' spellcheck="false" role="textbox" aria-autocomplete="list" />' +
      '</li>'
    );

    this.$searchContainer = $search;
    this.$search = $search.find('input');

    var $rendered = decorated.call(this);

    this._transferTabIndex();

    return $rendered;
  };

  Search.prototype.bind = function (decorated, container, $container) {
    var self = this;

    decorated.call(this, container, $container);

    container.on('open', function () {
      self.$search.trigger('focus');
    });

    container.on('close', function () {
      self.$search.val('');
      self.$search.removeAttr('aria-activedescendant');
      self.$search.trigger('focus');
    });

    container.on('enable', function () {
      self.$search.prop('disabled', false);

      self._transferTabIndex();
    });

    container.on('disable', function () {
      self.$search.prop('disabled', true);
    });

    container.on('focus', function (evt) {
      self.$search.trigger('focus');
    });

    container.on('results:focus', function (params) {
      self.$search.attr('aria-activedescendant', params.id);
    });

    this.$selection.on('focusin', '.select2-search--inline', function (evt) {
      self.trigger('focus', evt);
    });

    this.$selection.on('focusout', '.select2-search--inline', function (evt) {
      self._handleBlur(evt);
    });

    this.$selection.on('keydown', '.select2-search--inline', function (evt) {
      evt.stopPropagation();

      self.trigger('keypress', evt);

      self._keyUpPrevented = evt.isDefaultPrevented();

      var key = evt.which;

      if (key === KEYS.BACKSPACE && self.$search.val() === '') {
        var $previousChoice = self.$searchContainer
          .prev('.select2-selection__choice');

        if ($previousChoice.length > 0) {
          var item = $previousChoice.data('data');

          self.searchRemoveChoice(item);

          evt.preventDefault();
        }
      }
    });

    // Try to detect the IE version should the `documentMode` property that
    // is stored on the document. This is only implemented in IE and is
    // slightly cleaner than doing a user agent check.
    // This property is not available in Edge, but Edge also doesn't have
    // this bug.
    var msie = document.documentMode;
    var disableInputEvents = msie && msie <= 11;

    // Workaround for browsers which do not support the `input` event
    // This will prevent double-triggering of events for browsers which support
    // both the `keyup` and `input` events.
    this.$selection.on(
      'input.searchcheck',
      '.select2-search--inline',
      function (evt) {
        // IE will trigger the `input` event when a placeholder is used on a
        // search box. To get around this issue, we are forced to ignore all
        // `input` events in IE and keep using `keyup`.
        if (disableInputEvents) {
          self.$selection.off('input.search input.searchcheck');
          return;
        }

        // Unbind the duplicated `keyup` event
        self.$selection.off('keyup.search');
      }
    );

    this.$selection.on(
      'keyup.search input.search',
      '.select2-search--inline',
      function (evt) {
        // IE will trigger the `input` event when a placeholder is used on a
        // search box. To get around this issue, we are forced to ignore all
        // `input` events in IE and keep using `keyup`.
        if (disableInputEvents && evt.type === 'input') {
          self.$selection.off('input.search input.searchcheck');
          return;
        }

        var key = evt.which;

        // We can freely ignore events from modifier keys
        if (key == KEYS.SHIFT || key == KEYS.CTRL || key == KEYS.ALT) {
          return;
        }

        // Tabbing will be handled during the `keydown` phase
        if (key == KEYS.TAB) {
          return;
        }

        self.handleSearch(evt);
      }
    );
  };

  /**
   * This method will transfer the tabindex attribute from the rendered
   * selection to the search box. This allows for the search box to be used as
   * the primary focus instead of the selection container.
   *
   * @private
   */
  Search.prototype._transferTabIndex = function (decorated) {
    this.$search.attr('tabindex', this.$selection.attr('tabindex'));
    this.$selection.attr('tabindex', '-1');
  };

  Search.prototype.createPlaceholder = function (decorated, placeholder) {
    this.$search.attr('placeholder', placeholder.text);
  };

  Search.prototype.update = function (decorated, data) {
    var searchHadFocus = this.$search[0] == document.activeElement;

    this.$search.attr('placeholder', '');

    decorated.call(this, data);

    this.$selection.find('.select2-selection__rendered')
                   .append(this.$searchContainer);

    this.resizeSearch();
    if (searchHadFocus) {
      this.$search.focus();
    }
  };

  Search.prototype.handleSearch = function () {
    this.resizeSearch();

    if (!this._keyUpPrevented) {
      var input = this.$search.val();

      this.trigger('query', {
        term: input
      });
    }

    this._keyUpPrevented = false;
  };

  Search.prototype.searchRemoveChoice = function (decorated, item) {
    this.trigger('unselect', {
      data: item
    });

    this.$search.val(item.text);
    this.handleSearch();
  };

  Search.prototype.resizeSearch = function () {
    this.$search.css('width', '25px');

    var width = '';

    if (this.$search.attr('placeholder') !== '') {
      width = this.$selection.find('.select2-selection__rendered').innerWidth();
    } else {
      var minimumWidth = this.$search.val().length + 1;

      width = (minimumWidth * 0.75) + 'em';
    }

    this.$search.css('width', width);
  };

  return Search;
});

S2.define('select2/selection/eventRelay',[
  'jquery'
], function ($) {
  function EventRelay () { }

  EventRelay.prototype.bind = function (decorated, container, $container) {
    var self = this;
    var relayEvents = [
      'open', 'opening',
      'close', 'closing',
      'select', 'selecting',
      'unselect', 'unselecting'
    ];

    var preventableEvents = ['opening', 'closing', 'selecting', 'unselecting'];

    decorated.call(this, container, $container);

    container.on('*', function (name, params) {
      // Ignore events that should not be relayed
      if ($.inArray(name, relayEvents) === -1) {
        return;
      }

      // The parameters should always be an object
      params = params || {};

      // Generate the jQuery event for the Select2 event
      var evt = $.Event('select2:' + name, {
        params: params
      });

      self.$element.trigger(evt);

      // Only handle preventable events if it was one
      if ($.inArray(name, preventableEvents) === -1) {
        return;
      }

      params.prevented = evt.isDefaultPrevented();
    });
  };

  return EventRelay;
});

S2.define('select2/translation',[
  'jquery',
  'require'
], function ($, require) {
  function Translation (dict) {
    this.dict = dict || {};
  }

  Translation.prototype.all = function () {
    return this.dict;
  };

  Translation.prototype.get = function (key) {
    return this.dict[key];
  };

  Translation.prototype.extend = function (translation) {
    this.dict = $.extend({}, translation.all(), this.dict);
  };

  // Static functions

  Translation._cache = {};

  Translation.loadPath = function (path) {
    if (!(path in Translation._cache)) {
      var translations = require(path);

      Translation._cache[path] = translations;
    }

    return new Translation(Translation._cache[path]);
  };

  return Translation;
});

S2.define('select2/diacritics',[

], function () {
  var diacritics = {
    '\u24B6': 'A',
    '\uFF21': 'A',
    '\u00C0': 'A',
    '\u00C1': 'A',
    '\u00C2': 'A',
    '\u1EA6': 'A',
    '\u1EA4': 'A',
    '\u1EAA': 'A',
    '\u1EA8': 'A',
    '\u00C3': 'A',
    '\u0100': 'A',
    '\u0102': 'A',
    '\u1EB0': 'A',
    '\u1EAE': 'A',
    '\u1EB4': 'A',
    '\u1EB2': 'A',
    '\u0226': 'A',
    '\u01E0': 'A',
    '\u00C4': 'A',
    '\u01DE': 'A',
    '\u1EA2': 'A',
    '\u00C5': 'A',
    '\u01FA': 'A',
    '\u01CD': 'A',
    '\u0200': 'A',
    '\u0202': 'A',
    '\u1EA0': 'A',
    '\u1EAC': 'A',
    '\u1EB6': 'A',
    '\u1E00': 'A',
    '\u0104': 'A',
    '\u023A': 'A',
    '\u2C6F': 'A',
    '\uA732': 'AA',
    '\u00C6': 'AE',
    '\u01FC': 'AE',
    '\u01E2': 'AE',
    '\uA734': 'AO',
    '\uA736': 'AU',
    '\uA738': 'AV',
    '\uA73A': 'AV',
    '\uA73C': 'AY',
    '\u24B7': 'B',
    '\uFF22': 'B',
    '\u1E02': 'B',
    '\u1E04': 'B',
    '\u1E06': 'B',
    '\u0243': 'B',
    '\u0182': 'B',
    '\u0181': 'B',
    '\u24B8': 'C',
    '\uFF23': 'C',
    '\u0106': 'C',
    '\u0108': 'C',
    '\u010A': 'C',
    '\u010C': 'C',
    '\u00C7': 'C',
    '\u1E08': 'C',
    '\u0187': 'C',
    '\u023B': 'C',
    '\uA73E': 'C',
    '\u24B9': 'D',
    '\uFF24': 'D',
    '\u1E0A': 'D',
    '\u010E': 'D',
    '\u1E0C': 'D',
    '\u1E10': 'D',
    '\u1E12': 'D',
    '\u1E0E': 'D',
    '\u0110': 'D',
    '\u018B': 'D',
    '\u018A': 'D',
    '\u0189': 'D',
    '\uA779': 'D',
    '\u01F1': 'DZ',
    '\u01C4': 'DZ',
    '\u01F2': 'Dz',
    '\u01C5': 'Dz',
    '\u24BA': 'E',
    '\uFF25': 'E',
    '\u00C8': 'E',
    '\u00C9': 'E',
    '\u00CA': 'E',
    '\u1EC0': 'E',
    '\u1EBE': 'E',
    '\u1EC4': 'E',
    '\u1EC2': 'E',
    '\u1EBC': 'E',
    '\u0112': 'E',
    '\u1E14': 'E',
    '\u1E16': 'E',
    '\u0114': 'E',
    '\u0116': 'E',
    '\u00CB': 'E',
    '\u1EBA': 'E',
    '\u011A': 'E',
    '\u0204': 'E',
    '\u0206': 'E',
    '\u1EB8': 'E',
    '\u1EC6': 'E',
    '\u0228': 'E',
    '\u1E1C': 'E',
    '\u0118': 'E',
    '\u1E18': 'E',
    '\u1E1A': 'E',
    '\u0190': 'E',
    '\u018E': 'E',
    '\u24BB': 'F',
    '\uFF26': 'F',
    '\u1E1E': 'F',
    '\u0191': 'F',
    '\uA77B': 'F',
    '\u24BC': 'G',
    '\uFF27': 'G',
    '\u01F4': 'G',
    '\u011C': 'G',
    '\u1E20': 'G',
    '\u011E': 'G',
    '\u0120': 'G',
    '\u01E6': 'G',
    '\u0122': 'G',
    '\u01E4': 'G',
    '\u0193': 'G',
    '\uA7A0': 'G',
    '\uA77D': 'G',
    '\uA77E': 'G',
    '\u24BD': 'H',
    '\uFF28': 'H',
    '\u0124': 'H',
    '\u1E22': 'H',
    '\u1E26': 'H',
    '\u021E': 'H',
    '\u1E24': 'H',
    '\u1E28': 'H',
    '\u1E2A': 'H',
    '\u0126': 'H',
    '\u2C67': 'H',
    '\u2C75': 'H',
    '\uA78D': 'H',
    '\u24BE': 'I',
    '\uFF29': 'I',
    '\u00CC': 'I',
    '\u00CD': 'I',
    '\u00CE': 'I',
    '\u0128': 'I',
    '\u012A': 'I',
    '\u012C': 'I',
    '\u0130': 'I',
    '\u00CF': 'I',
    '\u1E2E': 'I',
    '\u1EC8': 'I',
    '\u01CF': 'I',
    '\u0208': 'I',
    '\u020A': 'I',
    '\u1ECA': 'I',
    '\u012E': 'I',
    '\u1E2C': 'I',
    '\u0197': 'I',
    '\u24BF': 'J',
    '\uFF2A': 'J',
    '\u0134': 'J',
    '\u0248': 'J',
    '\u24C0': 'K',
    '\uFF2B': 'K',
    '\u1E30': 'K',
    '\u01E8': 'K',
    '\u1E32': 'K',
    '\u0136': 'K',
    '\u1E34': 'K',
    '\u0198': 'K',
    '\u2C69': 'K',
    '\uA740': 'K',
    '\uA742': 'K',
    '\uA744': 'K',
    '\uA7A2': 'K',
    '\u24C1': 'L',
    '\uFF2C': 'L',
    '\u013F': 'L',
    '\u0139': 'L',
    '\u013D': 'L',
    '\u1E36': 'L',
    '\u1E38': 'L',
    '\u013B': 'L',
    '\u1E3C': 'L',
    '\u1E3A': 'L',
    '\u0141': 'L',
    '\u023D': 'L',
    '\u2C62': 'L',
    '\u2C60': 'L',
    '\uA748': 'L',
    '\uA746': 'L',
    '\uA780': 'L',
    '\u01C7': 'LJ',
    '\u01C8': 'Lj',
    '\u24C2': 'M',
    '\uFF2D': 'M',
    '\u1E3E': 'M',
    '\u1E40': 'M',
    '\u1E42': 'M',
    '\u2C6E': 'M',
    '\u019C': 'M',
    '\u24C3': 'N',
    '\uFF2E': 'N',
    '\u01F8': 'N',
    '\u0143': 'N',
    '\u00D1': 'N',
    '\u1E44': 'N',
    '\u0147': 'N',
    '\u1E46': 'N',
    '\u0145': 'N',
    '\u1E4A': 'N',
    '\u1E48': 'N',
    '\u0220': 'N',
    '\u019D': 'N',
    '\uA790': 'N',
    '\uA7A4': 'N',
    '\u01CA': 'NJ',
    '\u01CB': 'Nj',
    '\u24C4': 'O',
    '\uFF2F': 'O',
    '\u00D2': 'O',
    '\u00D3': 'O',
    '\u00D4': 'O',
    '\u1ED2': 'O',
    '\u1ED0': 'O',
    '\u1ED6': 'O',
    '\u1ED4': 'O',
    '\u00D5': 'O',
    '\u1E4C': 'O',
    '\u022C': 'O',
    '\u1E4E': 'O',
    '\u014C': 'O',
    '\u1E50': 'O',
    '\u1E52': 'O',
    '\u014E': 'O',
    '\u022E': 'O',
    '\u0230': 'O',
    '\u00D6': 'O',
    '\u022A': 'O',
    '\u1ECE': 'O',
    '\u0150': 'O',
    '\u01D1': 'O',
    '\u020C': 'O',
    '\u020E': 'O',
    '\u01A0': 'O',
    '\u1EDC': 'O',
    '\u1EDA': 'O',
    '\u1EE0': 'O',
    '\u1EDE': 'O',
    '\u1EE2': 'O',
    '\u1ECC': 'O',
    '\u1ED8': 'O',
    '\u01EA': 'O',
    '\u01EC': 'O',
    '\u00D8': 'O',
    '\u01FE': 'O',
    '\u0186': 'O',
    '\u019F': 'O',
    '\uA74A': 'O',
    '\uA74C': 'O',
    '\u01A2': 'OI',
    '\uA74E': 'OO',
    '\u0222': 'OU',
    '\u24C5': 'P',
    '\uFF30': 'P',
    '\u1E54': 'P',
    '\u1E56': 'P',
    '\u01A4': 'P',
    '\u2C63': 'P',
    '\uA750': 'P',
    '\uA752': 'P',
    '\uA754': 'P',
    '\u24C6': 'Q',
    '\uFF31': 'Q',
    '\uA756': 'Q',
    '\uA758': 'Q',
    '\u024A': 'Q',
    '\u24C7': 'R',
    '\uFF32': 'R',
    '\u0154': 'R',
    '\u1E58': 'R',
    '\u0158': 'R',
    '\u0210': 'R',
    '\u0212': 'R',
    '\u1E5A': 'R',
    '\u1E5C': 'R',
    '\u0156': 'R',
    '\u1E5E': 'R',
    '\u024C': 'R',
    '\u2C64': 'R',
    '\uA75A': 'R',
    '\uA7A6': 'R',
    '\uA782': 'R',
    '\u24C8': 'S',
    '\uFF33': 'S',
    '\u1E9E': 'S',
    '\u015A': 'S',
    '\u1E64': 'S',
    '\u015C': 'S',
    '\u1E60': 'S',
    '\u0160': 'S',
    '\u1E66': 'S',
    '\u1E62': 'S',
    '\u1E68': 'S',
    '\u0218': 'S',
    '\u015E': 'S',
    '\u2C7E': 'S',
    '\uA7A8': 'S',
    '\uA784': 'S',
    '\u24C9': 'T',
    '\uFF34': 'T',
    '\u1E6A': 'T',
    '\u0164': 'T',
    '\u1E6C': 'T',
    '\u021A': 'T',
    '\u0162': 'T',
    '\u1E70': 'T',
    '\u1E6E': 'T',
    '\u0166': 'T',
    '\u01AC': 'T',
    '\u01AE': 'T',
    '\u023E': 'T',
    '\uA786': 'T',
    '\uA728': 'TZ',
    '\u24CA': 'U',
    '\uFF35': 'U',
    '\u00D9': 'U',
    '\u00DA': 'U',
    '\u00DB': 'U',
    '\u0168': 'U',
    '\u1E78': 'U',
    '\u016A': 'U',
    '\u1E7A': 'U',
    '\u016C': 'U',
    '\u00DC': 'U',
    '\u01DB': 'U',
    '\u01D7': 'U',
    '\u01D5': 'U',
    '\u01D9': 'U',
    '\u1EE6': 'U',
    '\u016E': 'U',
    '\u0170': 'U',
    '\u01D3': 'U',
    '\u0214': 'U',
    '\u0216': 'U',
    '\u01AF': 'U',
    '\u1EEA': 'U',
    '\u1EE8': 'U',
    '\u1EEE': 'U',
    '\u1EEC': 'U',
    '\u1EF0': 'U',
    '\u1EE4': 'U',
    '\u1E72': 'U',
    '\u0172': 'U',
    '\u1E76': 'U',
    '\u1E74': 'U',
    '\u0244': 'U',
    '\u24CB': 'V',
    '\uFF36': 'V',
    '\u1E7C': 'V',
    '\u1E7E': 'V',
    '\u01B2': 'V',
    '\uA75E': 'V',
    '\u0245': 'V',
    '\uA760': 'VY',
    '\u24CC': 'W',
    '\uFF37': 'W',
    '\u1E80': 'W',
    '\u1E82': 'W',
    '\u0174': 'W',
    '\u1E86': 'W',
    '\u1E84': 'W',
    '\u1E88': 'W',
    '\u2C72': 'W',
    '\u24CD': 'X',
    '\uFF38': 'X',
    '\u1E8A': 'X',
    '\u1E8C': 'X',
    '\u24CE': 'Y',
    '\uFF39': 'Y',
    '\u1EF2': 'Y',
    '\u00DD': 'Y',
    '\u0176': 'Y',
    '\u1EF8': 'Y',
    '\u0232': 'Y',
    '\u1E8E': 'Y',
    '\u0178': 'Y',
    '\u1EF6': 'Y',
    '\u1EF4': 'Y',
    '\u01B3': 'Y',
    '\u024E': 'Y',
    '\u1EFE': 'Y',
    '\u24CF': 'Z',
    '\uFF3A': 'Z',
    '\u0179': 'Z',
    '\u1E90': 'Z',
    '\u017B': 'Z',
    '\u017D': 'Z',
    '\u1E92': 'Z',
    '\u1E94': 'Z',
    '\u01B5': 'Z',
    '\u0224': 'Z',
    '\u2C7F': 'Z',
    '\u2C6B': 'Z',
    '\uA762': 'Z',
    '\u24D0': 'a',
    '\uFF41': 'a',
    '\u1E9A': 'a',
    '\u00E0': 'a',
    '\u00E1': 'a',
    '\u00E2': 'a',
    '\u1EA7': 'a',
    '\u1EA5': 'a',
    '\u1EAB': 'a',
    '\u1EA9': 'a',
    '\u00E3': 'a',
    '\u0101': 'a',
    '\u0103': 'a',
    '\u1EB1': 'a',
    '\u1EAF': 'a',
    '\u1EB5': 'a',
    '\u1EB3': 'a',
    '\u0227': 'a',
    '\u01E1': 'a',
    '\u00E4': 'a',
    '\u01DF': 'a',
    '\u1EA3': 'a',
    '\u00E5': 'a',
    '\u01FB': 'a',
    '\u01CE': 'a',
    '\u0201': 'a',
    '\u0203': 'a',
    '\u1EA1': 'a',
    '\u1EAD': 'a',
    '\u1EB7': 'a',
    '\u1E01': 'a',
    '\u0105': 'a',
    '\u2C65': 'a',
    '\u0250': 'a',
    '\uA733': 'aa',
    '\u00E6': 'ae',
    '\u01FD': 'ae',
    '\u01E3': 'ae',
    '\uA735': 'ao',
    '\uA737': 'au',
    '\uA739': 'av',
    '\uA73B': 'av',
    '\uA73D': 'ay',
    '\u24D1': 'b',
    '\uFF42': 'b',
    '\u1E03': 'b',
    '\u1E05': 'b',
    '\u1E07': 'b',
    '\u0180': 'b',
    '\u0183': 'b',
    '\u0253': 'b',
    '\u24D2': 'c',
    '\uFF43': 'c',
    '\u0107': 'c',
    '\u0109': 'c',
    '\u010B': 'c',
    '\u010D': 'c',
    '\u00E7': 'c',
    '\u1E09': 'c',
    '\u0188': 'c',
    '\u023C': 'c',
    '\uA73F': 'c',
    '\u2184': 'c',
    '\u24D3': 'd',
    '\uFF44': 'd',
    '\u1E0B': 'd',
    '\u010F': 'd',
    '\u1E0D': 'd',
    '\u1E11': 'd',
    '\u1E13': 'd',
    '\u1E0F': 'd',
    '\u0111': 'd',
    '\u018C': 'd',
    '\u0256': 'd',
    '\u0257': 'd',
    '\uA77A': 'd',
    '\u01F3': 'dz',
    '\u01C6': 'dz',
    '\u24D4': 'e',
    '\uFF45': 'e',
    '\u00E8': 'e',
    '\u00E9': 'e',
    '\u00EA': 'e',
    '\u1EC1': 'e',
    '\u1EBF': 'e',
    '\u1EC5': 'e',
    '\u1EC3': 'e',
    '\u1EBD': 'e',
    '\u0113': 'e',
    '\u1E15': 'e',
    '\u1E17': 'e',
    '\u0115': 'e',
    '\u0117': 'e',
    '\u00EB': 'e',
    '\u1EBB': 'e',
    '\u011B': 'e',
    '\u0205': 'e',
    '\u0207': 'e',
    '\u1EB9': 'e',
    '\u1EC7': 'e',
    '\u0229': 'e',
    '\u1E1D': 'e',
    '\u0119': 'e',
    '\u1E19': 'e',
    '\u1E1B': 'e',
    '\u0247': 'e',
    '\u025B': 'e',
    '\u01DD': 'e',
    '\u24D5': 'f',
    '\uFF46': 'f',
    '\u1E1F': 'f',
    '\u0192': 'f',
    '\uA77C': 'f',
    '\u24D6': 'g',
    '\uFF47': 'g',
    '\u01F5': 'g',
    '\u011D': 'g',
    '\u1E21': 'g',
    '\u011F': 'g',
    '\u0121': 'g',
    '\u01E7': 'g',
    '\u0123': 'g',
    '\u01E5': 'g',
    '\u0260': 'g',
    '\uA7A1': 'g',
    '\u1D79': 'g',
    '\uA77F': 'g',
    '\u24D7': 'h',
    '\uFF48': 'h',
    '\u0125': 'h',
    '\u1E23': 'h',
    '\u1E27': 'h',
    '\u021F': 'h',
    '\u1E25': 'h',
    '\u1E29': 'h',
    '\u1E2B': 'h',
    '\u1E96': 'h',
    '\u0127': 'h',
    '\u2C68': 'h',
    '\u2C76': 'h',
    '\u0265': 'h',
    '\u0195': 'hv',
    '\u24D8': 'i',
    '\uFF49': 'i',
    '\u00EC': 'i',
    '\u00ED': 'i',
    '\u00EE': 'i',
    '\u0129': 'i',
    '\u012B': 'i',
    '\u012D': 'i',
    '\u00EF': 'i',
    '\u1E2F': 'i',
    '\u1EC9': 'i',
    '\u01D0': 'i',
    '\u0209': 'i',
    '\u020B': 'i',
    '\u1ECB': 'i',
    '\u012F': 'i',
    '\u1E2D': 'i',
    '\u0268': 'i',
    '\u0131': 'i',
    '\u24D9': 'j',
    '\uFF4A': 'j',
    '\u0135': 'j',
    '\u01F0': 'j',
    '\u0249': 'j',
    '\u24DA': 'k',
    '\uFF4B': 'k',
    '\u1E31': 'k',
    '\u01E9': 'k',
    '\u1E33': 'k',
    '\u0137': 'k',
    '\u1E35': 'k',
    '\u0199': 'k',
    '\u2C6A': 'k',
    '\uA741': 'k',
    '\uA743': 'k',
    '\uA745': 'k',
    '\uA7A3': 'k',
    '\u24DB': 'l',
    '\uFF4C': 'l',
    '\u0140': 'l',
    '\u013A': 'l',
    '\u013E': 'l',
    '\u1E37': 'l',
    '\u1E39': 'l',
    '\u013C': 'l',
    '\u1E3D': 'l',
    '\u1E3B': 'l',
    '\u017F': 'l',
    '\u0142': 'l',
    '\u019A': 'l',
    '\u026B': 'l',
    '\u2C61': 'l',
    '\uA749': 'l',
    '\uA781': 'l',
    '\uA747': 'l',
    '\u01C9': 'lj',
    '\u24DC': 'm',
    '\uFF4D': 'm',
    '\u1E3F': 'm',
    '\u1E41': 'm',
    '\u1E43': 'm',
    '\u0271': 'm',
    '\u026F': 'm',
    '\u24DD': 'n',
    '\uFF4E': 'n',
    '\u01F9': 'n',
    '\u0144': 'n',
    '\u00F1': 'n',
    '\u1E45': 'n',
    '\u0148': 'n',
    '\u1E47': 'n',
    '\u0146': 'n',
    '\u1E4B': 'n',
    '\u1E49': 'n',
    '\u019E': 'n',
    '\u0272': 'n',
    '\u0149': 'n',
    '\uA791': 'n',
    '\uA7A5': 'n',
    '\u01CC': 'nj',
    '\u24DE': 'o',
    '\uFF4F': 'o',
    '\u00F2': 'o',
    '\u00F3': 'o',
    '\u00F4': 'o',
    '\u1ED3': 'o',
    '\u1ED1': 'o',
    '\u1ED7': 'o',
    '\u1ED5': 'o',
    '\u00F5': 'o',
    '\u1E4D': 'o',
    '\u022D': 'o',
    '\u1E4F': 'o',
    '\u014D': 'o',
    '\u1E51': 'o',
    '\u1E53': 'o',
    '\u014F': 'o',
    '\u022F': 'o',
    '\u0231': 'o',
    '\u00F6': 'o',
    '\u022B': 'o',
    '\u1ECF': 'o',
    '\u0151': 'o',
    '\u01D2': 'o',
    '\u020D': 'o',
    '\u020F': 'o',
    '\u01A1': 'o',
    '\u1EDD': 'o',
    '\u1EDB': 'o',
    '\u1EE1': 'o',
    '\u1EDF': 'o',
    '\u1EE3': 'o',
    '\u1ECD': 'o',
    '\u1ED9': 'o',
    '\u01EB': 'o',
    '\u01ED': 'o',
    '\u00F8': 'o',
    '\u01FF': 'o',
    '\u0254': 'o',
    '\uA74B': 'o',
    '\uA74D': 'o',
    '\u0275': 'o',
    '\u01A3': 'oi',
    '\u0223': 'ou',
    '\uA74F': 'oo',
    '\u24DF': 'p',
    '\uFF50': 'p',
    '\u1E55': 'p',
    '\u1E57': 'p',
    '\u01A5': 'p',
    '\u1D7D': 'p',
    '\uA751': 'p',
    '\uA753': 'p',
    '\uA755': 'p',
    '\u24E0': 'q',
    '\uFF51': 'q',
    '\u024B': 'q',
    '\uA757': 'q',
    '\uA759': 'q',
    '\u24E1': 'r',
    '\uFF52': 'r',
    '\u0155': 'r',
    '\u1E59': 'r',
    '\u0159': 'r',
    '\u0211': 'r',
    '\u0213': 'r',
    '\u1E5B': 'r',
    '\u1E5D': 'r',
    '\u0157': 'r',
    '\u1E5F': 'r',
    '\u024D': 'r',
    '\u027D': 'r',
    '\uA75B': 'r',
    '\uA7A7': 'r',
    '\uA783': 'r',
    '\u24E2': 's',
    '\uFF53': 's',
    '\u00DF': 's',
    '\u015B': 's',
    '\u1E65': 's',
    '\u015D': 's',
    '\u1E61': 's',
    '\u0161': 's',
    '\u1E67': 's',
    '\u1E63': 's',
    '\u1E69': 's',
    '\u0219': 's',
    '\u015F': 's',
    '\u023F': 's',
    '\uA7A9': 's',
    '\uA785': 's',
    '\u1E9B': 's',
    '\u24E3': 't',
    '\uFF54': 't',
    '\u1E6B': 't',
    '\u1E97': 't',
    '\u0165': 't',
    '\u1E6D': 't',
    '\u021B': 't',
    '\u0163': 't',
    '\u1E71': 't',
    '\u1E6F': 't',
    '\u0167': 't',
    '\u01AD': 't',
    '\u0288': 't',
    '\u2C66': 't',
    '\uA787': 't',
    '\uA729': 'tz',
    '\u24E4': 'u',
    '\uFF55': 'u',
    '\u00F9': 'u',
    '\u00FA': 'u',
    '\u00FB': 'u',
    '\u0169': 'u',
    '\u1E79': 'u',
    '\u016B': 'u',
    '\u1E7B': 'u',
    '\u016D': 'u',
    '\u00FC': 'u',
    '\u01DC': 'u',
    '\u01D8': 'u',
    '\u01D6': 'u',
    '\u01DA': 'u',
    '\u1EE7': 'u',
    '\u016F': 'u',
    '\u0171': 'u',
    '\u01D4': 'u',
    '\u0215': 'u',
    '\u0217': 'u',
    '\u01B0': 'u',
    '\u1EEB': 'u',
    '\u1EE9': 'u',
    '\u1EEF': 'u',
    '\u1EED': 'u',
    '\u1EF1': 'u',
    '\u1EE5': 'u',
    '\u1E73': 'u',
    '\u0173': 'u',
    '\u1E77': 'u',
    '\u1E75': 'u',
    '\u0289': 'u',
    '\u24E5': 'v',
    '\uFF56': 'v',
    '\u1E7D': 'v',
    '\u1E7F': 'v',
    '\u028B': 'v',
    '\uA75F': 'v',
    '\u028C': 'v',
    '\uA761': 'vy',
    '\u24E6': 'w',
    '\uFF57': 'w',
    '\u1E81': 'w',
    '\u1E83': 'w',
    '\u0175': 'w',
    '\u1E87': 'w',
    '\u1E85': 'w',
    '\u1E98': 'w',
    '\u1E89': 'w',
    '\u2C73': 'w',
    '\u24E7': 'x',
    '\uFF58': 'x',
    '\u1E8B': 'x',
    '\u1E8D': 'x',
    '\u24E8': 'y',
    '\uFF59': 'y',
    '\u1EF3': 'y',
    '\u00FD': 'y',
    '\u0177': 'y',
    '\u1EF9': 'y',
    '\u0233': 'y',
    '\u1E8F': 'y',
    '\u00FF': 'y',
    '\u1EF7': 'y',
    '\u1E99': 'y',
    '\u1EF5': 'y',
    '\u01B4': 'y',
    '\u024F': 'y',
    '\u1EFF': 'y',
    '\u24E9': 'z',
    '\uFF5A': 'z',
    '\u017A': 'z',
    '\u1E91': 'z',
    '\u017C': 'z',
    '\u017E': 'z',
    '\u1E93': 'z',
    '\u1E95': 'z',
    '\u01B6': 'z',
    '\u0225': 'z',
    '\u0240': 'z',
    '\u2C6C': 'z',
    '\uA763': 'z',
    '\u0386': '\u0391',
    '\u0388': '\u0395',
    '\u0389': '\u0397',
    '\u038A': '\u0399',
    '\u03AA': '\u0399',
    '\u038C': '\u039F',
    '\u038E': '\u03A5',
    '\u03AB': '\u03A5',
    '\u038F': '\u03A9',
    '\u03AC': '\u03B1',
    '\u03AD': '\u03B5',
    '\u03AE': '\u03B7',
    '\u03AF': '\u03B9',
    '\u03CA': '\u03B9',
    '\u0390': '\u03B9',
    '\u03CC': '\u03BF',
    '\u03CD': '\u03C5',
    '\u03CB': '\u03C5',
    '\u03B0': '\u03C5',
    '\u03C9': '\u03C9',
    '\u03C2': '\u03C3'
  };

  return diacritics;
});

S2.define('select2/data/base',[
  '../utils'
], function (Utils) {
  function BaseAdapter ($element, options) {
    BaseAdapter.__super__.constructor.call(this);
  }

  Utils.Extend(BaseAdapter, Utils.Observable);

  BaseAdapter.prototype.current = function (callback) {
    throw new Error('The `current` method must be defined in child classes.');
  };

  BaseAdapter.prototype.query = function (params, callback) {
    throw new Error('The `query` method must be defined in child classes.');
  };

  BaseAdapter.prototype.bind = function (container, $container) {
    // Can be implemented in subclasses
  };

  BaseAdapter.prototype.destroy = function () {
    // Can be implemented in subclasses
  };

  BaseAdapter.prototype.generateResultId = function (container, data) {
    var id = container.id + '-result-';

    id += Utils.generateChars(4);

    if (data.id != null) {
      id += '-' + data.id.toString();
    } else {
      id += '-' + Utils.generateChars(4);
    }
    return id;
  };

  return BaseAdapter;
});

S2.define('select2/data/select',[
  './base',
  '../utils',
  'jquery'
], function (BaseAdapter, Utils, $) {
  function SelectAdapter ($element, options) {
    this.$element = $element;
    this.options = options;

    SelectAdapter.__super__.constructor.call(this);
  }

  Utils.Extend(SelectAdapter, BaseAdapter);

  SelectAdapter.prototype.current = function (callback) {
    var data = [];
    var self = this;

    this.$element.find(':selected').each(function () {
      var $option = $(this);

      var option = self.item($option);

      data.push(option);
    });

    callback(data);
  };

  SelectAdapter.prototype.select = function (data) {
    var self = this;

    data.selected = true;

    // If data.element is a DOM node, use it instead
    if ($(data.element).is('option')) {
      data.element.selected = true;

      this.$element.trigger('change');

      return;
    }

    if (this.$element.prop('multiple')) {
      this.current(function (currentData) {
        var val = [];

        data = [data];
        data.push.apply(data, currentData);

        for (var d = 0; d < data.length; d++) {
          var id = data[d].id;

          if ($.inArray(id, val) === -1) {
            val.push(id);
          }
        }

        self.$element.val(val);
        self.$element.trigger('change');
      });
    } else {
      var val = data.id;

      this.$element.val(val);
      this.$element.trigger('change');
    }
  };

  SelectAdapter.prototype.unselect = function (data) {
    var self = this;

    if (!this.$element.prop('multiple')) {
      return;
    }

    data.selected = false;

    if ($(data.element).is('option')) {
      data.element.selected = false;

      this.$element.trigger('change');

      return;
    }

    this.current(function (currentData) {
      var val = [];

      for (var d = 0; d < currentData.length; d++) {
        var id = currentData[d].id;

        if (id !== data.id && $.inArray(id, val) === -1) {
          val.push(id);
        }
      }

      self.$element.val(val);

      self.$element.trigger('change');
    });
  };

  SelectAdapter.prototype.bind = function (container, $container) {
    var self = this;

    this.container = container;

    container.on('select', function (params) {
      self.select(params.data);
    });

    container.on('unselect', function (params) {
      self.unselect(params.data);
    });
  };

  SelectAdapter.prototype.destroy = function () {
    // Remove anything added to child elements
    this.$element.find('*').each(function () {
      // Remove any custom data set by Select2
      $.removeData(this, 'data');
    });
  };

  SelectAdapter.prototype.query = function (params, callback) {
    var data = [];
    var self = this;

    var $options = this.$element.children();

    $options.each(function () {
      var $option = $(this);

      if (!$option.is('option') && !$option.is('optgroup')) {
        return;
      }

      var option = self.item($option);

      var matches = self.matches(params, option);

      if (matches !== null) {
        data.push(matches);
      }
    });

    callback({
      results: data
    });
  };

  SelectAdapter.prototype.addOptions = function ($options) {
    Utils.appendMany(this.$element, $options);
  };

  SelectAdapter.prototype.option = function (data) {
    var option;

    if (data.children) {
      option = document.createElement('optgroup');
      option.label = data.text;
    } else {
      option = document.createElement('option');

      if (option.textContent !== undefined) {
        option.textContent = data.text;
      } else {
        option.innerText = data.text;
      }
    }

    if (data.id) {
      option.value = data.id;
    }

    if (data.disabled) {
      option.disabled = true;
    }

    if (data.selected) {
      option.selected = true;
    }

    if (data.title) {
      option.title = data.title;
    }

    var $option = $(option);

    var normalizedData = this._normalizeItem(data);
    normalizedData.element = option;

    // Override the option's data with the combined data
    $.data(option, 'data', normalizedData);

    return $option;
  };

  SelectAdapter.prototype.item = function ($option) {
    var data = {};

    data = $.data($option[0], 'data');

    if (data != null) {
      return data;
    }

    if ($option.is('option')) {
      data = {
        id: $option.val(),
        text: $option.text(),
        disabled: $option.prop('disabled'),
        selected: $option.prop('selected'),
        title: $option.prop('title')
      };
    } else if ($option.is('optgroup')) {
      data = {
        text: $option.prop('label'),
        children: [],
        title: $option.prop('title')
      };

      var $children = $option.children('option');
      var children = [];

      for (var c = 0; c < $children.length; c++) {
        var $child = $($children[c]);

        var child = this.item($child);

        children.push(child);
      }

      data.children = children;
    }

    data = this._normalizeItem(data);
    data.element = $option[0];

    $.data($option[0], 'data', data);

    return data;
  };

  SelectAdapter.prototype._normalizeItem = function (item) {
    if (!$.isPlainObject(item)) {
      item = {
        id: item,
        text: item
      };
    }

    item = $.extend({}, {
      text: ''
    }, item);

    var defaults = {
      selected: false,
      disabled: false
    };

    if (item.id != null) {
      item.id = item.id.toString();
    }

    if (item.text != null) {
      item.text = item.text.toString();
    }

    if (item._resultId == null && item.id && this.container != null) {
      item._resultId = this.generateResultId(this.container, item);
    }

    return $.extend({}, defaults, item);
  };

  SelectAdapter.prototype.matches = function (params, data) {
    var matcher = this.options.get('matcher');

    return matcher(params, data);
  };

  return SelectAdapter;
});

S2.define('select2/data/array',[
  './select',
  '../utils',
  'jquery'
], function (SelectAdapter, Utils, $) {
  function ArrayAdapter ($element, options) {
    var data = options.get('data') || [];

    ArrayAdapter.__super__.constructor.call(this, $element, options);

    this.addOptions(this.convertToOptions(data));
  }

  Utils.Extend(ArrayAdapter, SelectAdapter);

  ArrayAdapter.prototype.select = function (data) {
    var $option = this.$element.find('option').filter(function (i, elm) {
      return elm.value == data.id.toString();
    });

    if ($option.length === 0) {
      $option = this.option(data);

      this.addOptions($option);
    }

    ArrayAdapter.__super__.select.call(this, data);
  };

  ArrayAdapter.prototype.convertToOptions = function (data) {
    var self = this;

    var $existing = this.$element.find('option');
    var existingIds = $existing.map(function () {
      return self.item($(this)).id;
    }).get();

    var $options = [];

    // Filter out all items except for the one passed in the argument
    function onlyItem (item) {
      return function () {
        return $(this).val() == item.id;
      };
    }

    for (var d = 0; d < data.length; d++) {
      var item = this._normalizeItem(data[d]);

      // Skip items which were pre-loaded, only merge the data
      if ($.inArray(item.id, existingIds) >= 0) {
        var $existingOption = $existing.filter(onlyItem(item));

        var existingData = this.item($existingOption);
        var newData = $.extend(true, {}, item, existingData);

        var $newOption = this.option(newData);

        $existingOption.replaceWith($newOption);

        continue;
      }

      var $option = this.option(item);

      if (item.children) {
        var $children = this.convertToOptions(item.children);

        Utils.appendMany($option, $children);
      }

      $options.push($option);
    }

    return $options;
  };

  return ArrayAdapter;
});

S2.define('select2/data/ajax',[
  './array',
  '../utils',
  'jquery'
], function (ArrayAdapter, Utils, $) {
  function AjaxAdapter ($element, options) {
    this.ajaxOptions = this._applyDefaults(options.get('ajax'));

    if (this.ajaxOptions.processResults != null) {
      this.processResults = this.ajaxOptions.processResults;
    }

    AjaxAdapter.__super__.constructor.call(this, $element, options);
  }

  Utils.Extend(AjaxAdapter, ArrayAdapter);

  AjaxAdapter.prototype._applyDefaults = function (options) {
    var defaults = {
      data: function (params) {
        return $.extend({}, params, {
          q: params.term
        });
      },
      transport: function (params, success, failure) {
        var $request = $.ajax(params);

        $request.then(success);
        $request.fail(failure);

        return $request;
      }
    };

    return $.extend({}, defaults, options, true);
  };

  AjaxAdapter.prototype.processResults = function (results) {
    return results;
  };

  AjaxAdapter.prototype.query = function (params, callback) {
    var matches = [];
    var self = this;

    if (this._request != null) {
      // JSONP requests cannot always be aborted
      if ($.isFunction(this._request.abort)) {
        this._request.abort();
      }

      this._request = null;
    }

    var options = $.extend({
      type: 'GET'
    }, this.ajaxOptions);

    if (typeof options.url === 'function') {
      options.url = options.url.call(this.$element, params);
    }

    if (typeof options.data === 'function') {
      options.data = options.data.call(this.$element, params);
    }

    function request () {
      var $request = options.transport(options, function (data) {
        var results = self.processResults(data, params);

        if (self.options.get('debug') && window.console && console.error) {
          // Check to make sure that the response included a `results` key.
          if (!results || !results.results || !$.isArray(results.results)) {
            console.error(
              'Select2: The AJAX results did not return an array in the ' +
              '`results` key of the response.'
            );
          }
        }

        callback(results);
      }, function () {
        self.trigger('results:message', {
          message: 'errorLoading'
        });
      });

      self._request = $request;
    }

    if (this.ajaxOptions.delay && params.term !== '') {
      if (this._queryTimeout) {
        window.clearTimeout(this._queryTimeout);
      }

      this._queryTimeout = window.setTimeout(request, this.ajaxOptions.delay);
    } else {
      request();
    }
  };

  return AjaxAdapter;
});

S2.define('select2/data/tags',[
  'jquery'
], function ($) {
  function Tags (decorated, $element, options) {
    var tags = options.get('tags');

    var createTag = options.get('createTag');

    if (createTag !== undefined) {
      this.createTag = createTag;
    }

    var insertTag = options.get('insertTag');

    if (insertTag !== undefined) {
        this.insertTag = insertTag;
    }

    decorated.call(this, $element, options);

    if ($.isArray(tags)) {
      for (var t = 0; t < tags.length; t++) {
        var tag = tags[t];
        var item = this._normalizeItem(tag);

        var $option = this.option(item);

        this.$element.append($option);
      }
    }
  }

  Tags.prototype.query = function (decorated, params, callback) {
    var self = this;

    this._removeOldTags();

    if (params.term == null || params.page != null) {
      decorated.call(this, params, callback);
      return;
    }

    function wrapper (obj, child) {
      var data = obj.results;

      for (var i = 0; i < data.length; i++) {
        var option = data[i];

        var checkChildren = (
          option.children != null &&
          !wrapper({
            results: option.children
          }, true)
        );

        var checkText = option.text === params.term;

        if (checkText || checkChildren) {
          if (child) {
            return false;
          }

          obj.data = data;
          callback(obj);

          return;
        }
      }

      if (child) {
        return true;
      }

      var tag = self.createTag(params);

      if (tag != null) {
        var $option = self.option(tag);
        $option.attr('data-select2-tag', true);

        self.addOptions([$option]);

        self.insertTag(data, tag);
      }

      obj.results = data;

      callback(obj);
    }

    decorated.call(this, params, wrapper);
  };

  Tags.prototype.createTag = function (decorated, params) {
    var term = $.trim(params.term);

    if (term === '') {
      return null;
    }

    return {
      id: term,
      text: term
    };
  };

  Tags.prototype.insertTag = function (_, data, tag) {
    data.unshift(tag);
  };

  Tags.prototype._removeOldTags = function (_) {
    var tag = this._lastTag;

    var $options = this.$element.find('option[data-select2-tag]');

    $options.each(function () {
      if (this.selected) {
        return;
      }

      $(this).remove();
    });
  };

  return Tags;
});

S2.define('select2/data/tokenizer',[
  'jquery'
], function ($) {
  function Tokenizer (decorated, $element, options) {
    var tokenizer = options.get('tokenizer');

    if (tokenizer !== undefined) {
      this.tokenizer = tokenizer;
    }

    decorated.call(this, $element, options);
  }

  Tokenizer.prototype.bind = function (decorated, container, $container) {
    decorated.call(this, container, $container);

    this.$search =  container.dropdown.$search || container.selection.$search ||
      $container.find('.select2-search__field');
  };

  Tokenizer.prototype.query = function (decorated, params, callback) {
    var self = this;

    function select (data) {
      self.trigger('select', {
        data: data
      });
    }

    params.term = params.term || '';

    var tokenData = this.tokenizer(params, this.options, select);

    if (tokenData.term !== params.term) {
      // Replace the search term if we have the search box
      if (this.$search.length) {
        this.$search.val(tokenData.term);
        this.$search.focus();
      }

      params.term = tokenData.term;
    }

    decorated.call(this, params, callback);
  };

  Tokenizer.prototype.tokenizer = function (_, params, options, callback) {
    var separators = options.get('tokenSeparators') || [];
    var term = params.term;
    var i = 0;

    var createTag = this.createTag || function (params) {
      return {
        id: params.term,
        text: params.term
      };
    };

    while (i < term.length) {
      var termChar = term[i];

      if ($.inArray(termChar, separators) === -1) {
        i++;

        continue;
      }

      var part = term.substr(0, i);
      var partParams = $.extend({}, params, {
        term: part
      });

      var data = createTag(partParams);

      if (data == null) {
        i++;
        continue;
      }

      callback(data);

      // Reset the term to not include the tokenized portion
      term = term.substr(i + 1) || '';
      i = 0;
    }

    return {
      term: term
    };
  };

  return Tokenizer;
});

S2.define('select2/data/minimumInputLength',[

], function () {
  function MinimumInputLength (decorated, $e, options) {
    this.minimumInputLength = options.get('minimumInputLength');

    decorated.call(this, $e, options);
  }

  MinimumInputLength.prototype.query = function (decorated, params, callback) {
    params.term = params.term || '';

    if (params.term.length < this.minimumInputLength) {
      this.trigger('results:message', {
        message: 'inputTooShort',
        args: {
          minimum: this.minimumInputLength,
          input: params.term,
          params: params
        }
      });

      return;
    }

    decorated.call(this, params, callback);
  };

  return MinimumInputLength;
});

S2.define('select2/data/maximumInputLength',[

], function () {
  function MaximumInputLength (decorated, $e, options) {
    this.maximumInputLength = options.get('maximumInputLength');

    decorated.call(this, $e, options);
  }

  MaximumInputLength.prototype.query = function (decorated, params, callback) {
    params.term = params.term || '';

    if (this.maximumInputLength > 0 &&
        params.term.length > this.maximumInputLength) {
      this.trigger('results:message', {
        message: 'inputTooLong',
        args: {
          maximum: this.maximumInputLength,
          input: params.term,
          params: params
        }
      });

      return;
    }

    decorated.call(this, params, callback);
  };

  return MaximumInputLength;
});

S2.define('select2/data/maximumSelectionLength',[

], function (){
  function MaximumSelectionLength (decorated, $e, options) {
    this.maximumSelectionLength = options.get('maximumSelectionLength');

    decorated.call(this, $e, options);
  }

  MaximumSelectionLength.prototype.query =
    function (decorated, params, callback) {
      var self = this;

      this.current(function (currentData) {
        var count = currentData != null ? currentData.length : 0;
        if (self.maximumSelectionLength > 0 &&
          count >= self.maximumSelectionLength) {
          self.trigger('results:message', {
            message: 'maximumSelected',
            args: {
              maximum: self.maximumSelectionLength
            }
          });
          return;
        }
        decorated.call(self, params, callback);
      });
  };

  return MaximumSelectionLength;
});

S2.define('select2/dropdown',[
  'jquery',
  './utils'
], function ($, Utils) {
  function Dropdown ($element, options) {
    this.$element = $element;
    this.options = options;

    Dropdown.__super__.constructor.call(this);
  }

  Utils.Extend(Dropdown, Utils.Observable);

  Dropdown.prototype.render = function () {
    var $dropdown = $(
      '<span class="select2-dropdown">' +
        '<span class="select2-results"></span>' +
      '</span>'
    );

    $dropdown.attr('dir', this.options.get('dir'));

    this.$dropdown = $dropdown;

    return $dropdown;
  };

  Dropdown.prototype.bind = function () {
    // Should be implemented in subclasses
  };

  Dropdown.prototype.position = function ($dropdown, $container) {
    // Should be implmented in subclasses
  };

  Dropdown.prototype.destroy = function () {
    // Remove the dropdown from the DOM
    this.$dropdown.remove();
  };

  return Dropdown;
});

S2.define('select2/dropdown/search',[
  'jquery',
  '../utils'
], function ($, Utils) {
  function Search () { }

  Search.prototype.render = function (decorated) {
    var $rendered = decorated.call(this);

    var $search = $(
      '<span class="select2-search select2-search--dropdown">' +
        '<input class="select2-search__field" type="search" tabindex="-1"' +
        ' autocomplete="off" autocorrect="off" autocapitalize="off"' +
        ' spellcheck="false" role="textbox" />' +
      '</span>'
    );

    this.$searchContainer = $search;
    this.$search = $search.find('input');

    $rendered.prepend($search);

    return $rendered;
  };

  Search.prototype.bind = function (decorated, container, $container) {
    var self = this;

    decorated.call(this, container, $container);

    this.$search.on('keydown', function (evt) {
      self.trigger('keypress', evt);

      self._keyUpPrevented = evt.isDefaultPrevented();
    });

    // Workaround for browsers which do not support the `input` event
    // This will prevent double-triggering of events for browsers which support
    // both the `keyup` and `input` events.
    this.$search.on('input', function (evt) {
      // Unbind the duplicated `keyup` event
      $(this).off('keyup');
    });

    this.$search.on('keyup input', function (evt) {
      self.handleSearch(evt);
    });

    container.on('open', function () {
      self.$search.attr('tabindex', 0);

      self.$search.focus();

      window.setTimeout(function () {
        self.$search.focus();
      }, 0);
    });

    container.on('close', function () {
      self.$search.attr('tabindex', -1);

      self.$search.val('');
    });

    container.on('results:all', function (params) {
      if (params.query.term == null || params.query.term === '') {
        var showSearch = self.showSearch(params);

        if (showSearch) {
          self.$searchContainer.removeClass('select2-search--hide');
        } else {
          self.$searchContainer.addClass('select2-search--hide');
        }
      }
    });
  };

  Search.prototype.handleSearch = function (evt) {
    if (!this._keyUpPrevented) {
      var input = this.$search.val();

      this.trigger('query', {
        term: input
      });
    }

    this._keyUpPrevented = false;
  };

  Search.prototype.showSearch = function (_, params) {
    return true;
  };

  return Search;
});

S2.define('select2/dropdown/hidePlaceholder',[

], function () {
  function HidePlaceholder (decorated, $element, options, dataAdapter) {
    this.placeholder = this.normalizePlaceholder(options.get('placeholder'));

    decorated.call(this, $element, options, dataAdapter);
  }

  HidePlaceholder.prototype.append = function (decorated, data) {
    data.results = this.removePlaceholder(data.results);

    decorated.call(this, data);
  };

  HidePlaceholder.prototype.normalizePlaceholder = function (_, placeholder) {
    if (typeof placeholder === 'string') {
      placeholder = {
        id: '',
        text: placeholder
      };
    }

    return placeholder;
  };

  HidePlaceholder.prototype.removePlaceholder = function (_, data) {
    var modifiedData = data.slice(0);

    for (var d = data.length - 1; d >= 0; d--) {
      var item = data[d];

      if (this.placeholder.id === item.id) {
        modifiedData.splice(d, 1);
      }
    }

    return modifiedData;
  };

  return HidePlaceholder;
});

S2.define('select2/dropdown/infiniteScroll',[
  'jquery'
], function ($) {
  function InfiniteScroll (decorated, $element, options, dataAdapter) {
    this.lastParams = {};

    decorated.call(this, $element, options, dataAdapter);

    this.$loadingMore = this.createLoadingMore();
    this.loading = false;
  }

  InfiniteScroll.prototype.append = function (decorated, data) {
    this.$loadingMore.remove();
    this.loading = false;

    decorated.call(this, data);

    if (this.showLoadingMore(data)) {
      this.$results.append(this.$loadingMore);
    }
  };

  InfiniteScroll.prototype.bind = function (decorated, container, $container) {
    var self = this;

    decorated.call(this, container, $container);

    container.on('query', function (params) {
      self.lastParams = params;
      self.loading = true;
    });

    container.on('query:append', function (params) {
      self.lastParams = params;
      self.loading = true;
    });

    this.$results.on('scroll', function () {
      var isLoadMoreVisible = $.contains(
        document.documentElement,
        self.$loadingMore[0]
      );

      if (self.loading || !isLoadMoreVisible) {
        return;
      }

      var currentOffset = self.$results.offset().top +
        self.$results.outerHeight(false);
      var loadingMoreOffset = self.$loadingMore.offset().top +
        self.$loadingMore.outerHeight(false);

      if (currentOffset + 50 >= loadingMoreOffset) {
        self.loadMore();
      }
    });
  };

  InfiniteScroll.prototype.loadMore = function () {
    this.loading = true;

    var params = $.extend({}, {page: 1}, this.lastParams);

    params.page++;

    this.trigger('query:append', params);
  };

  InfiniteScroll.prototype.showLoadingMore = function (_, data) {
    return data.pagination && data.pagination.more;
  };

  InfiniteScroll.prototype.createLoadingMore = function () {
    var $option = $(
      '<li ' +
      'class="select2-results__option select2-results__option--load-more"' +
      'role="treeitem" aria-disabled="true"></li>'
    );

    var message = this.options.get('translations').get('loadingMore');

    $option.html(message(this.lastParams));

    return $option;
  };

  return InfiniteScroll;
});

S2.define('select2/dropdown/attachBody',[
  'jquery',
  '../utils'
], function ($, Utils) {
  function AttachBody (decorated, $element, options) {
    this.$dropdownParent = options.get('dropdownParent') || $(document.body);

    decorated.call(this, $element, options);
  }

  AttachBody.prototype.bind = function (decorated, container, $container) {
    var self = this;

    var setupResultsEvents = false;

    decorated.call(this, container, $container);

    container.on('open', function () {
      self._showDropdown();
      self._attachPositioningHandler(container);

      if (!setupResultsEvents) {
        setupResultsEvents = true;

        container.on('results:all', function () {
          self._positionDropdown();
          self._resizeDropdown();
        });

        container.on('results:append', function () {
          self._positionDropdown();
          self._resizeDropdown();
        });
      }
    });

    container.on('close', function () {
      self._hideDropdown();
      self._detachPositioningHandler(container);
    });

    this.$dropdownContainer.on('mousedown', function (evt) {
      evt.stopPropagation();
    });
  };

  AttachBody.prototype.destroy = function (decorated) {
    decorated.call(this);

    this.$dropdownContainer.remove();
  };

  AttachBody.prototype.position = function (decorated, $dropdown, $container) {
    // Clone all of the container classes
    $dropdown.attr('class', $container.attr('class'));

    $dropdown.removeClass('select2');
    $dropdown.addClass('select2-container--open');

    $dropdown.css({
      position: 'absolute',
      top: -999999
    });

    this.$container = $container;
  };

  AttachBody.prototype.render = function (decorated) {
    var $container = $('<span></span>');

    var $dropdown = decorated.call(this);
    $container.append($dropdown);

    this.$dropdownContainer = $container;

    return $container;
  };

  AttachBody.prototype._hideDropdown = function (decorated) {
    this.$dropdownContainer.detach();
  };

  AttachBody.prototype._attachPositioningHandler =
      function (decorated, container) {
    var self = this;

    var scrollEvent = 'scroll.select2.' + container.id;
    var resizeEvent = 'resize.select2.' + container.id;
    var orientationEvent = 'orientationchange.select2.' + container.id;

    var $watchers = this.$container.parents().filter(Utils.hasScroll);
    $watchers.each(function () {
      $(this).data('select2-scroll-position', {
        x: $(this).scrollLeft(),
        y: $(this).scrollTop()
      });
    });

    $watchers.on(scrollEvent, function (ev) {
      var position = $(this).data('select2-scroll-position');
      $(this).scrollTop(position.y);
    });

    $(window).on(scrollEvent + ' ' + resizeEvent + ' ' + orientationEvent,
      function (e) {
      self._positionDropdown();
      self._resizeDropdown();
    });
  };

  AttachBody.prototype._detachPositioningHandler =
      function (decorated, container) {
    var scrollEvent = 'scroll.select2.' + container.id;
    var resizeEvent = 'resize.select2.' + container.id;
    var orientationEvent = 'orientationchange.select2.' + container.id;

    var $watchers = this.$container.parents().filter(Utils.hasScroll);
    $watchers.off(scrollEvent);

    $(window).off(scrollEvent + ' ' + resizeEvent + ' ' + orientationEvent);
  };

  AttachBody.prototype._positionDropdown = function () {
    var $window = $(window);

    var isCurrentlyAbove = this.$dropdown.hasClass('select2-dropdown--above');
    var isCurrentlyBelow = this.$dropdown.hasClass('select2-dropdown--below');

    var newDirection = null;

    var offset = this.$container.offset();

    offset.bottom = offset.top + this.$container.outerHeight(false);

    var container = {
      height: this.$container.outerHeight(false)
    };

    container.top = offset.top;
    container.bottom = offset.top + container.height;

    var dropdown = {
      height: this.$dropdown.outerHeight(false)
    };

    var viewport = {
      top: $window.scrollTop(),
      bottom: $window.scrollTop() + $window.height()
    };

    var enoughRoomAbove = viewport.top < (offset.top - dropdown.height);
    var enoughRoomBelow = viewport.bottom > (offset.bottom + dropdown.height);

    var css = {
      left: offset.left,
      top: container.bottom
    };

    // Determine what the parent element is to use for calciulating the offset
    var $offsetParent = this.$dropdownParent;

    // For statically positoned elements, we need to get the element
    // that is determining the offset
    if ($offsetParent.css('position') === 'static') {
      $offsetParent = $offsetParent.offsetParent();
    }

    var parentOffset = $offsetParent.offset();

    css.top -= parentOffset.top;
    css.left -= parentOffset.left;

    if (!isCurrentlyAbove && !isCurrentlyBelow) {
      newDirection = 'below';
    }

    if (!enoughRoomBelow && enoughRoomAbove && !isCurrentlyAbove) {
      newDirection = 'above';
    } else if (!enoughRoomAbove && enoughRoomBelow && isCurrentlyAbove) {
      newDirection = 'below';
    }

    if (newDirection == 'above' ||
      (isCurrentlyAbove && newDirection !== 'below')) {
      css.top = container.top - dropdown.height;
    }

    if (newDirection != null) {
      this.$dropdown
        .removeClass('select2-dropdown--below select2-dropdown--above')
        .addClass('select2-dropdown--' + newDirection);
      this.$container
        .removeClass('select2-container--below select2-container--above')
        .addClass('select2-container--' + newDirection);
    }

    this.$dropdownContainer.css(css);
  };

  AttachBody.prototype._resizeDropdown = function () {
    var css = {
      width: this.$container.outerWidth(false) + 'px'
    };

    if (this.options.get('dropdownAutoWidth')) {
      css.minWidth = css.width;
      css.width = 'auto';
    }

    this.$dropdown.css(css);
  };

  AttachBody.prototype._showDropdown = function (decorated) {
    this.$dropdownContainer.appendTo(this.$dropdownParent);

    this._positionDropdown();
    this._resizeDropdown();
  };

  return AttachBody;
});

S2.define('select2/dropdown/minimumResultsForSearch',[

], function () {
  function countResults (data) {
    var count = 0;

    for (var d = 0; d < data.length; d++) {
      var item = data[d];

      if (item.children) {
        count += countResults(item.children);
      } else {
        count++;
      }
    }

    return count;
  }

  function MinimumResultsForSearch (decorated, $element, options, dataAdapter) {
    this.minimumResultsForSearch = options.get('minimumResultsForSearch');

    if (this.minimumResultsForSearch < 0) {
      this.minimumResultsForSearch = Infinity;
    }

    decorated.call(this, $element, options, dataAdapter);
  }

  MinimumResultsForSearch.prototype.showSearch = function (decorated, params) {
    if (countResults(params.data.results) < this.minimumResultsForSearch) {
      return false;
    }

    return decorated.call(this, params);
  };

  return MinimumResultsForSearch;
});

S2.define('select2/dropdown/selectOnClose',[

], function () {
  function SelectOnClose () { }

  SelectOnClose.prototype.bind = function (decorated, container, $container) {
    var self = this;

    decorated.call(this, container, $container);

    container.on('close', function () {
      self._handleSelectOnClose();
    });
  };

  SelectOnClose.prototype._handleSelectOnClose = function () {
    var $highlightedResults = this.getHighlightedResults();

    // Only select highlighted results
    if ($highlightedResults.length < 1) {
      return;
    }

    var data = $highlightedResults.data('data');

    // Don't re-select already selected resulte
    if (
      (data.element != null && data.element.selected) ||
      (data.element == null && data.selected)
    ) {
      return;
    }

    this.trigger('select', {
        data: data
    });
  };

  return SelectOnClose;
});

S2.define('select2/dropdown/closeOnSelect',[

], function () {
  function CloseOnSelect () { }

  CloseOnSelect.prototype.bind = function (decorated, container, $container) {
    var self = this;

    decorated.call(this, container, $container);

    container.on('select', function (evt) {
      self._selectTriggered(evt);
    });

    container.on('unselect', function (evt) {
      self._selectTriggered(evt);
    });
  };

  CloseOnSelect.prototype._selectTriggered = function (_, evt) {
    var originalEvent = evt.originalEvent;

    // Don't close if the control key is being held
    if (originalEvent && originalEvent.ctrlKey) {
      return;
    }

    this.trigger('close', {});
  };

  return CloseOnSelect;
});

S2.define('select2/i18n/en',[],function () {
  // English
  return {
    errorLoading: function () {
      return 'The results could not be loaded.';
    },
    inputTooLong: function (args) {
      var overChars = args.input.length - args.maximum;

      var message = 'Please delete ' + overChars + ' character';

      if (overChars != 1) {
        message += 's';
      }

      return message;
    },
    inputTooShort: function (args) {
      var remainingChars = args.minimum - args.input.length;

      var message = 'Please enter ' + remainingChars + ' or more characters';

      return message;
    },
    loadingMore: function () {
      return 'Loading more results…';
    },
    maximumSelected: function (args) {
      var message = 'You can only select ' + args.maximum + ' item';

      if (args.maximum != 1) {
        message += 's';
      }

      return message;
    },
    noResults: function () {
      return 'No results found';
    },
    searching: function () {
      return 'Searching…';
    }
  };
});

S2.define('select2/defaults',[
  'jquery',
  'require',

  './results',

  './selection/single',
  './selection/multiple',
  './selection/placeholder',
  './selection/allowClear',
  './selection/search',
  './selection/eventRelay',

  './utils',
  './translation',
  './diacritics',

  './data/select',
  './data/array',
  './data/ajax',
  './data/tags',
  './data/tokenizer',
  './data/minimumInputLength',
  './data/maximumInputLength',
  './data/maximumSelectionLength',

  './dropdown',
  './dropdown/search',
  './dropdown/hidePlaceholder',
  './dropdown/infiniteScroll',
  './dropdown/attachBody',
  './dropdown/minimumResultsForSearch',
  './dropdown/selectOnClose',
  './dropdown/closeOnSelect',

  './i18n/en'
], function ($, require,

             ResultsList,

             SingleSelection, MultipleSelection, Placeholder, AllowClear,
             SelectionSearch, EventRelay,

             Utils, Translation, DIACRITICS,

             SelectData, ArrayData, AjaxData, Tags, Tokenizer,
             MinimumInputLength, MaximumInputLength, MaximumSelectionLength,

             Dropdown, DropdownSearch, HidePlaceholder, InfiniteScroll,
             AttachBody, MinimumResultsForSearch, SelectOnClose, CloseOnSelect,

             EnglishTranslation) {
  function Defaults () {
    this.reset();
  }

  Defaults.prototype.apply = function (options) {
    options = $.extend({}, this.defaults, options);

    if (options.dataAdapter == null) {
      if (options.ajax != null) {
        options.dataAdapter = AjaxData;
      } else if (options.data != null) {
        options.dataAdapter = ArrayData;
      } else {
        options.dataAdapter = SelectData;
      }

      if (options.minimumInputLength > 0) {
        options.dataAdapter = Utils.Decorate(
          options.dataAdapter,
          MinimumInputLength
        );
      }

      if (options.maximumInputLength > 0) {
        options.dataAdapter = Utils.Decorate(
          options.dataAdapter,
          MaximumInputLength
        );
      }

      if (options.maximumSelectionLength > 0) {
        options.dataAdapter = Utils.Decorate(
          options.dataAdapter,
          MaximumSelectionLength
        );
      }

      if (options.tags) {
        options.dataAdapter = Utils.Decorate(options.dataAdapter, Tags);
      }

      if (options.tokenSeparators != null || options.tokenizer != null) {
        options.dataAdapter = Utils.Decorate(
          options.dataAdapter,
          Tokenizer
        );
      }

      if (options.query != null) {
        var Query = require(options.amdBase + 'compat/query');

        options.dataAdapter = Utils.Decorate(
          options.dataAdapter,
          Query
        );
      }

      if (options.initSelection != null) {
        var InitSelection = require(options.amdBase + 'compat/initSelection');

        options.dataAdapter = Utils.Decorate(
          options.dataAdapter,
          InitSelection
        );
      }
    }

    if (options.resultsAdapter == null) {
      options.resultsAdapter = ResultsList;

      if (options.ajax != null) {
        options.resultsAdapter = Utils.Decorate(
          options.resultsAdapter,
          InfiniteScroll
        );
      }

      if (options.placeholder != null) {
        options.resultsAdapter = Utils.Decorate(
          options.resultsAdapter,
          HidePlaceholder
        );
      }

      if (options.selectOnClose) {
        options.resultsAdapter = Utils.Decorate(
          options.resultsAdapter,
          SelectOnClose
        );
      }
    }

    if (options.dropdownAdapter == null) {
      if (options.multiple) {
        options.dropdownAdapter = Dropdown;
      } else {
        var SearchableDropdown = Utils.Decorate(Dropdown, DropdownSearch);

        options.dropdownAdapter = SearchableDropdown;
      }

      if (options.minimumResultsForSearch !== 0) {
        options.dropdownAdapter = Utils.Decorate(
          options.dropdownAdapter,
          MinimumResultsForSearch
        );
      }

      if (options.closeOnSelect) {
        options.dropdownAdapter = Utils.Decorate(
          options.dropdownAdapter,
          CloseOnSelect
        );
      }

      if (
        options.dropdownCssClass != null ||
        options.dropdownCss != null ||
        options.adaptDropdownCssClass != null
      ) {
        var DropdownCSS = require(options.amdBase + 'compat/dropdownCss');

        options.dropdownAdapter = Utils.Decorate(
          options.dropdownAdapter,
          DropdownCSS
        );
      }

      options.dropdownAdapter = Utils.Decorate(
        options.dropdownAdapter,
        AttachBody
      );
    }

    if (options.selectionAdapter == null) {
      if (options.multiple) {
        options.selectionAdapter = MultipleSelection;
      } else {
        options.selectionAdapter = SingleSelection;
      }

      // Add the placeholder mixin if a placeholder was specified
      if (options.placeholder != null) {
        options.selectionAdapter = Utils.Decorate(
          options.selectionAdapter,
          Placeholder
        );
      }

      if (options.allowClear) {
        options.selectionAdapter = Utils.Decorate(
          options.selectionAdapter,
          AllowClear
        );
      }

      if (options.multiple) {
        options.selectionAdapter = Utils.Decorate(
          options.selectionAdapter,
          SelectionSearch
        );
      }

      if (
        options.containerCssClass != null ||
        options.containerCss != null ||
        options.adaptContainerCssClass != null
      ) {
        var ContainerCSS = require(options.amdBase + 'compat/containerCss');

        options.selectionAdapter = Utils.Decorate(
          options.selectionAdapter,
          ContainerCSS
        );
      }

      options.selectionAdapter = Utils.Decorate(
        options.selectionAdapter,
        EventRelay
      );
    }

    if (typeof options.language === 'string') {
      // Check if the language is specified with a region
      if (options.language.indexOf('-') > 0) {
        // Extract the region information if it is included
        var languageParts = options.language.split('-');
        var baseLanguage = languageParts[0];

        options.language = [options.language, baseLanguage];
      } else {
        options.language = [options.language];
      }
    }

    if ($.isArray(options.language)) {
      var languages = new Translation();
      options.language.push('en');

      var languageNames = options.language;

      for (var l = 0; l < languageNames.length; l++) {
        var name = languageNames[l];
        var language = {};

        try {
          // Try to load it with the original name
          language = Translation.loadPath(name);
        } catch (e) {
          try {
            // If we couldn't load it, check if it wasn't the full path
            name = this.defaults.amdLanguageBase + name;
            language = Translation.loadPath(name);
          } catch (ex) {
            // The translation could not be loaded at all. Sometimes this is
            // because of a configuration problem, other times this can be
            // because of how Select2 helps load all possible translation files.
            if (options.debug && window.console && console.warn) {
              console.warn(
                'Select2: The language file for "' + name + '" could not be ' +
                'automatically loaded. A fallback will be used instead.'
              );
            }

            continue;
          }
        }

        languages.extend(language);
      }

      options.translations = languages;
    } else {
      var baseTranslation = Translation.loadPath(
        this.defaults.amdLanguageBase + 'en'
      );
      var customTranslation = new Translation(options.language);

      customTranslation.extend(baseTranslation);

      options.translations = customTranslation;
    }

    return options;
  };

  Defaults.prototype.reset = function () {
    function stripDiacritics (text) {
      // Used 'uni range + named function' from http://jsperf.com/diacritics/18
      function match(a) {
        return DIACRITICS[a] || a;
      }

      return text.replace(/[^\u0000-\u007E]/g, match);
    }

    function matcher (params, data) {
      // Always return the object if there is nothing to compare
      if ($.trim(params.term) === '') {
        return data;
      }

      // Do a recursive check for options with children
      if (data.children && data.children.length > 0) {
        // Clone the data object if there are children
        // This is required as we modify the object to remove any non-matches
        var match = $.extend(true, {}, data);

        // Check each child of the option
        for (var c = data.children.length - 1; c >= 0; c--) {
          var child = data.children[c];

          var matches = matcher(params, child);

          // If there wasn't a match, remove the object in the array
          if (matches == null) {
            match.children.splice(c, 1);
          }
        }

        // If any children matched, return the new object
        if (match.children.length > 0) {
          return match;
        }

        // If there were no matching children, check just the plain object
        return matcher(params, match);
      }

      var original = stripDiacritics(data.text).toUpperCase();
      var term = stripDiacritics(params.term).toUpperCase();

      // Check if the text contains the term
      if (original.indexOf(term) > -1) {
        return data;
      }

      // If it doesn't contain the term, don't return anything
      return null;
    }

    this.defaults = {
      amdBase: './',
      amdLanguageBase: './i18n/',
      closeOnSelect: true,
      debug: false,
      dropdownAutoWidth: false,
      escapeMarkup: Utils.escapeMarkup,
      language: EnglishTranslation,
      matcher: matcher,
      minimumInputLength: 0,
      maximumInputLength: 0,
      maximumSelectionLength: 0,
      minimumResultsForSearch: 0,
      selectOnClose: false,
      sorter: function (data) {
        return data;
      },
      templateResult: function (result) {
        return result.text;
      },
      templateSelection: function (selection) {
        return selection.text;
      },
      theme: 'default',
      width: 'resolve'
    };
  };

  Defaults.prototype.set = function (key, value) {
    var camelKey = $.camelCase(key);

    var data = {};
    data[camelKey] = value;

    var convertedData = Utils._convertData(data);

    $.extend(this.defaults, convertedData);
  };

  var defaults = new Defaults();

  return defaults;
});

S2.define('select2/options',[
  'require',
  'jquery',
  './defaults',
  './utils'
], function (require, $, Defaults, Utils) {
  function Options (options, $element) {
    this.options = options;

    if ($element != null) {
      this.fromElement($element);
    }

    this.options = Defaults.apply(this.options);

    if ($element && $element.is('input')) {
      var InputCompat = require(this.get('amdBase') + 'compat/inputData');

      this.options.dataAdapter = Utils.Decorate(
        this.options.dataAdapter,
        InputCompat
      );
    }
  }

  Options.prototype.fromElement = function ($e) {
    var excludedData = ['select2'];

    if (this.options.multiple == null) {
      this.options.multiple = $e.prop('multiple');
    }

    if (this.options.disabled == null) {
      this.options.disabled = $e.prop('disabled');
    }

    if (this.options.language == null) {
      if ($e.prop('lang')) {
        this.options.language = $e.prop('lang').toLowerCase();
      } else if ($e.closest('[lang]').prop('lang')) {
        this.options.language = $e.closest('[lang]').prop('lang');
      }
    }

    if (this.options.dir == null) {
      if ($e.prop('dir')) {
        this.options.dir = $e.prop('dir');
      } else if ($e.closest('[dir]').prop('dir')) {
        this.options.dir = $e.closest('[dir]').prop('dir');
      } else {
        this.options.dir = 'ltr';
      }
    }

    $e.prop('disabled', this.options.disabled);
    $e.prop('multiple', this.options.multiple);

    if ($e.data('select2Tags')) {
      if (this.options.debug && window.console && console.warn) {
        console.warn(
          'Select2: The `data-select2-tags` attribute has been changed to ' +
          'use the `data-data` and `data-tags="true"` attributes and will be ' +
          'removed in future versions of Select2.'
        );
      }

      $e.data('data', $e.data('select2Tags'));
      $e.data('tags', true);
    }

    if ($e.data('ajaxUrl')) {
      if (this.options.debug && window.console && console.warn) {
        console.warn(
          'Select2: The `data-ajax-url` attribute has been changed to ' +
          '`data-ajax--url` and support for the old attribute will be removed' +
          ' in future versions of Select2.'
        );
      }

      $e.attr('ajax--url', $e.data('ajaxUrl'));
      $e.data('ajax--url', $e.data('ajaxUrl'));
    }

    var dataset = {};

    // Prefer the element's `dataset` attribute if it exists
    // jQuery 1.x does not correctly handle data attributes with multiple dashes
    if ($.fn.jquery && $.fn.jquery.substr(0, 2) == '1.' && $e[0].dataset) {
      dataset = $.extend(true, {}, $e[0].dataset, $e.data());
    } else {
      dataset = $e.data();
    }

    var data = $.extend(true, {}, dataset);

    data = Utils._convertData(data);

    for (var key in data) {
      if ($.inArray(key, excludedData) > -1) {
        continue;
      }

      if ($.isPlainObject(this.options[key])) {
        $.extend(this.options[key], data[key]);
      } else {
        this.options[key] = data[key];
      }
    }

    return this;
  };

  Options.prototype.get = function (key) {
    return this.options[key];
  };

  Options.prototype.set = function (key, val) {
    this.options[key] = val;
  };

  return Options;
});

S2.define('select2/core',[
  'jquery',
  './options',
  './utils',
  './keys'
], function ($, Options, Utils, KEYS) {
  var Select2 = function ($element, options) {
    if ($element.data('select2') != null) {
      $element.data('select2').destroy();
    }

    this.$element = $element;

    this.id = this._generateId($element);

    options = options || {};

    this.options = new Options(options, $element);

    Select2.__super__.constructor.call(this);

    // Set up the tabindex

    var tabindex = $element.attr('tabindex') || 0;
    $element.data('old-tabindex', tabindex);
    $element.attr('tabindex', '-1');

    // Set up containers and adapters

    var DataAdapter = this.options.get('dataAdapter');
    this.dataAdapter = new DataAdapter($element, this.options);

    var $container = this.render();

    this._placeContainer($container);

    var SelectionAdapter = this.options.get('selectionAdapter');
    this.selection = new SelectionAdapter($element, this.options);
    this.$selection = this.selection.render();

    this.selection.position(this.$selection, $container);

    var DropdownAdapter = this.options.get('dropdownAdapter');
    this.dropdown = new DropdownAdapter($element, this.options);
    this.$dropdown = this.dropdown.render();

    this.dropdown.position(this.$dropdown, $container);

    var ResultsAdapter = this.options.get('resultsAdapter');
    this.results = new ResultsAdapter($element, this.options, this.dataAdapter);
    this.$results = this.results.render();

    this.results.position(this.$results, this.$dropdown);

    // Bind events

    var self = this;

    // Bind the container to all of the adapters
    this._bindAdapters();

    // Register any DOM event handlers
    this._registerDomEvents();

    // Register any internal event handlers
    this._registerDataEvents();
    this._registerSelectionEvents();
    this._registerDropdownEvents();
    this._registerResultsEvents();
    this._registerEvents();

    // Set the initial state
    this.dataAdapter.current(function (initialData) {
      self.trigger('selection:update', {
        data: initialData
      });
    });

    // Hide the original select
    $element.addClass('select2-hidden-accessible');
    $element.attr('aria-hidden', 'true');

    // Synchronize any monitored attributes
    this._syncAttributes();

    $element.data('select2', this);
  };

  Utils.Extend(Select2, Utils.Observable);

  Select2.prototype._generateId = function ($element) {
    var id = '';

    if ($element.attr('id') != null) {
      id = $element.attr('id');
    } else if ($element.attr('name') != null) {
      id = $element.attr('name') + '-' + Utils.generateChars(2);
    } else {
      id = Utils.generateChars(4);
    }

    id = 'select2-' + id;

    return id;
  };

  Select2.prototype._placeContainer = function ($container) {
    $container.insertAfter(this.$element);

    var width = this._resolveWidth(this.$element, this.options.get('width'));

    if (width != null) {
      $container.css('width', width);
    }
  };

  Select2.prototype._resolveWidth = function ($element, method) {
    var WIDTH = /^width:(([-+]?([0-9]*\.)?[0-9]+)(px|em|ex|%|in|cm|mm|pt|pc))/i;

    if (method == 'resolve') {
      var styleWidth = this._resolveWidth($element, 'style');

      if (styleWidth != null) {
        return styleWidth;
      }

      return this._resolveWidth($element, 'element');
    }

    if (method == 'element') {
      var elementWidth = $element.outerWidth(false);

      if (elementWidth <= 0) {
        return 'auto';
      }

      return elementWidth + 'px';
    }

    if (method == 'style') {
      var style = $element.attr('style');

      if (typeof(style) !== 'string') {
        return null;
      }

      var attrs = style.split(';');

      for (var i = 0, l = attrs.length; i < l; i = i + 1) {
        var attr = attrs[i].replace(/\s/g, '');
        var matches = attr.match(WIDTH);

        if (matches !== null && matches.length >= 1) {
          return matches[1];
        }
      }

      return null;
    }

    return method;
  };

  Select2.prototype._bindAdapters = function () {
    this.dataAdapter.bind(this, this.$container);
    this.selection.bind(this, this.$container);

    this.dropdown.bind(this, this.$container);
    this.results.bind(this, this.$container);
  };

  Select2.prototype._registerDomEvents = function () {
    var self = this;

    this.$element.on('change.select2', function () {
      self.dataAdapter.current(function (data) {
        self.trigger('selection:update', {
          data: data
        });
      });
    });

    this._sync = Utils.bind(this._syncAttributes, this);

    if (this.$element[0].attachEvent) {
      this.$element[0].attachEvent('onpropertychange', this._sync);
    }

    var observer = window.MutationObserver ||
      window.WebKitMutationObserver ||
      window.MozMutationObserver
    ;

    if (observer != null) {
      this._observer = new observer(function (mutations) {
        $.each(mutations, self._sync);
      });
      this._observer.observe(this.$element[0], {
        attributes: true,
        subtree: false
      });
    } else if (this.$element[0].addEventListener) {
      this.$element[0].addEventListener('DOMAttrModified', self._sync, false);
    }
  };

  Select2.prototype._registerDataEvents = function () {
    var self = this;

    this.dataAdapter.on('*', function (name, params) {
      self.trigger(name, params);
    });
  };

  Select2.prototype._registerSelectionEvents = function () {
    var self = this;
    var nonRelayEvents = ['toggle', 'focus'];

    this.selection.on('toggle', function () {
      self.toggleDropdown();
    });

    this.selection.on('focus', function (params) {
      self.focus(params);
    });

    this.selection.on('*', function (name, params) {
      if ($.inArray(name, nonRelayEvents) !== -1) {
        return;
      }

      self.trigger(name, params);
    });
  };

  Select2.prototype._registerDropdownEvents = function () {
    var self = this;

    this.dropdown.on('*', function (name, params) {
      self.trigger(name, params);
    });
  };

  Select2.prototype._registerResultsEvents = function () {
    var self = this;

    this.results.on('*', function (name, params) {
      self.trigger(name, params);
    });
  };

  Select2.prototype._registerEvents = function () {
    var self = this;

    this.on('open', function () {
      self.$container.addClass('select2-container--open');
    });

    this.on('close', function () {
      self.$container.removeClass('select2-container--open');
    });

    this.on('enable', function () {
      self.$container.removeClass('select2-container--disabled');
    });

    this.on('disable', function () {
      self.$container.addClass('select2-container--disabled');
    });

    this.on('blur', function () {
      self.$container.removeClass('select2-container--focus');
    });

    this.on('query', function (params) {
      if (!self.isOpen()) {
        self.trigger('open', {});
      }

      this.dataAdapter.query(params, function (data) {
        self.trigger('results:all', {
          data: data,
          query: params
        });
      });
    });

    this.on('query:append', function (params) {
      this.dataAdapter.query(params, function (data) {
        self.trigger('results:append', {
          data: data,
          query: params
        });
      });
    });

    this.on('keypress', function (evt) {
      var key = evt.which;

      if (self.isOpen()) {
        if (key === KEYS.ESC || key === KEYS.TAB ||
            (key === KEYS.UP && evt.altKey)) {
          self.close();

          evt.preventDefault();
        } else if (key === KEYS.ENTER) {
          self.trigger('results:select', {});

          evt.preventDefault();
        } else if ((key === KEYS.SPACE && evt.ctrlKey)) {
          self.trigger('results:toggle', {});

          evt.preventDefault();
        } else if (key === KEYS.UP) {
          self.trigger('results:previous', {});

          evt.preventDefault();
        } else if (key === KEYS.DOWN) {
          self.trigger('results:next', {});

          evt.preventDefault();
        }
      } else {
        if (key === KEYS.ENTER || key === KEYS.SPACE ||
            (key === KEYS.DOWN && evt.altKey)) {
          self.open();

          evt.preventDefault();
        }
      }
    });
  };

  Select2.prototype._syncAttributes = function () {
    this.options.set('disabled', this.$element.prop('disabled'));

    if (this.options.get('disabled')) {
      if (this.isOpen()) {
        this.close();
      }

      this.trigger('disable', {});
    } else {
      this.trigger('enable', {});
    }
  };

  /**
   * Override the trigger method to automatically trigger pre-events when
   * there are events that can be prevented.
   */
  Select2.prototype.trigger = function (name, args) {
    var actualTrigger = Select2.__super__.trigger;
    var preTriggerMap = {
      'open': 'opening',
      'close': 'closing',
      'select': 'selecting',
      'unselect': 'unselecting'
    };

    if (args === undefined) {
      args = {};
    }

    if (name in preTriggerMap) {
      var preTriggerName = preTriggerMap[name];
      var preTriggerArgs = {
        prevented: false,
        name: name,
        args: args
      };

      actualTrigger.call(this, preTriggerName, preTriggerArgs);

      if (preTriggerArgs.prevented) {
        args.prevented = true;

        return;
      }
    }

    actualTrigger.call(this, name, args);
  };

  Select2.prototype.toggleDropdown = function () {
    if (this.options.get('disabled')) {
      return;
    }

    if (this.isOpen()) {
      this.close();
    } else {
      this.open();
    }
  };

  Select2.prototype.open = function () {
    if (this.isOpen()) {
      return;
    }

    this.trigger('query', {});
  };

  Select2.prototype.close = function () {
    if (!this.isOpen()) {
      return;
    }

    this.trigger('close', {});
  };

  Select2.prototype.isOpen = function () {
    return this.$container.hasClass('select2-container--open');
  };

  Select2.prototype.hasFocus = function () {
    return this.$container.hasClass('select2-container--focus');
  };

  Select2.prototype.focus = function (data) {
    // No need to re-trigger focus events if we are already focused
    if (this.hasFocus()) {
      return;
    }

    this.$container.addClass('select2-container--focus');
    this.trigger('focus', {});
  };

  Select2.prototype.enable = function (args) {
    if (this.options.get('debug') && window.console && console.warn) {
      console.warn(
        'Select2: The `select2("enable")` method has been deprecated and will' +
        ' be removed in later Select2 versions. Use $element.prop("disabled")' +
        ' instead.'
      );
    }

    if (args == null || args.length === 0) {
      args = [true];
    }

    var disabled = !args[0];

    this.$element.prop('disabled', disabled);
  };

  Select2.prototype.data = function () {
    if (this.options.get('debug') &&
        arguments.length > 0 && window.console && console.warn) {
      console.warn(
        'Select2: Data can no longer be set using `select2("data")`. You ' +
        'should consider setting the value instead using `$element.val()`.'
      );
    }

    var data = [];

    this.dataAdapter.current(function (currentData) {
      data = currentData;
    });

    return data;
  };

  Select2.prototype.val = function (args) {
    if (this.options.get('debug') && window.console && console.warn) {
      console.warn(
        'Select2: The `select2("val")` method has been deprecated and will be' +
        ' removed in later Select2 versions. Use $element.val() instead.'
      );
    }

    if (args == null || args.length === 0) {
      return this.$element.val();
    }

    var newVal = args[0];

    if ($.isArray(newVal)) {
      newVal = $.map(newVal, function (obj) {
        return obj.toString();
      });
    }

    this.$element.val(newVal).trigger('change');
  };

  Select2.prototype.destroy = function () {
    this.$container.remove();

    if (this.$element[0].detachEvent) {
      this.$element[0].detachEvent('onpropertychange', this._sync);
    }

    if (this._observer != null) {
      this._observer.disconnect();
      this._observer = null;
    } else if (this.$element[0].removeEventListener) {
      this.$element[0]
        .removeEventListener('DOMAttrModified', this._sync, false);
    }

    this._sync = null;

    this.$element.off('.select2');
    this.$element.attr('tabindex', this.$element.data('old-tabindex'));

    this.$element.removeClass('select2-hidden-accessible');
    this.$element.attr('aria-hidden', 'false');
    this.$element.removeData('select2');

    this.dataAdapter.destroy();
    this.selection.destroy();
    this.dropdown.destroy();
    this.results.destroy();

    this.dataAdapter = null;
    this.selection = null;
    this.dropdown = null;
    this.results = null;
  };

  Select2.prototype.render = function () {
    var $container = $(
      '<span class="select2 select2-container">' +
        '<span class="selection"></span>' +
        '<span class="dropdown-wrapper" aria-hidden="true"></span>' +
      '</span>'
    );

    $container.attr('dir', this.options.get('dir'));

    this.$container = $container;

    this.$container.addClass('select2-container--' + this.options.get('theme'));

    $container.data('element', this.$element);

    return $container;
  };

  return Select2;
});

S2.define('jquery-mousewheel',[
  'jquery'
], function ($) {
  // Used to shim jQuery.mousewheel for non-full builds.
  return $;
});

S2.define('jquery.select2',[
  'jquery',
  'jquery-mousewheel',

  './select2/core',
  './select2/defaults'
], function ($, _, Select2, Defaults) {
  if ($.fn.select2 == null) {
    // All methods that should return the element
    var thisMethods = ['open', 'close', 'destroy'];

    $.fn.select2 = function (options) {
      options = options || {};

      if (typeof options === 'object') {
        this.each(function () {
          var instanceOptions = $.extend(true, {}, options);

          var instance = new Select2($(this), instanceOptions);
        });

        return this;
      } else if (typeof options === 'string') {
        var ret;

        this.each(function () {
          var instance = $(this).data('select2');

          if (instance == null && window.console && console.error) {
            console.error(
              'The select2(\'' + options + '\') method was called on an ' +
              'element that is not using Select2.'
            );
          }

          var args = Array.prototype.slice.call(arguments, 1);

          ret = instance[options].apply(instance, args);
        });

        // Check if we should be returning `this`
        if ($.inArray(options, thisMethods) > -1) {
          return this;
        }

        return ret;
      } else {
        throw new Error('Invalid arguments for Select2: ' + options);
      }
    };
  }

  if ($.fn.select2.defaults == null) {
    $.fn.select2.defaults = Defaults;
  }

  return Select2;
});

  // Return the AMD loader configuration so it can be used outside of this file
  return {
    define: S2.define,
    require: S2.require
  };
}());

  // Autoload the jQuery bindings
  // We know that all of the modules exist above this, so we're safe
  var select2 = S2.require('jquery.select2');

  // Hold the AMD module references on the jQuery function that was just loaded
  // This allows Select2 to use the internal loader outside of this file, such
  // as in the language files.
  jQuery.fn.select2.amd = S2;

  // Return the Select2 instance for anyone who is importing it.
  return select2;
}));
;

/**
	
	Select list widget/styling.
	<br />
	<br />This simply wraps all select lists in a div so we can style until all browser allow custom select styling.
	
	__Special case:__ In scenarios where you dynamically inject HTML post-load, you can initialize the widget on your injected select HTML like this:
		
	$("select").each(function(){
		IBMCore.common.widget.selectlist.init(this);
	});
	
	@class IBMCore.common.widget.selectlist

**/


(function ($, IBM) {

	var me = IBM.namespace(IBM, "common.widget.selectlist");

	// For safety in case someone does something dumb and omits select2 from their custom build.
	if ($.fn.select2) {
		$.fn.select2.defaults.set("minimumResultsForSearch", 8);
		$.fn.select2.defaults.set("width", "resolve");
	}

    me.init = function (el, settings) {
		var $elem = $(el),
			userConfig = {},
			select2_dropdown,
			select2_closing_timeout;

		// For safety in case someone does something dumb and omits select2 from their custom build.	
		if (!$.fn.select2) {
			return;
		}

		// Merge in configuration to use, then init plug-in with them:  JS settings override HTML which override defaults.
		userConfig = $.extend({}, $elem.data() || {}, settings);

		// Translate data-attr lowercase'd to required camelcase ones.
		if (userConfig.searchenabled === false) {
			userConfig.minimumResultsForSearch = -1;
		}
		
		$elem.css("width", $elem.outerWidth(true) + 20);
		
		// INIT the actual plug-in and add special bindings to account for animations.
		$elem.select2(userConfig).on("select2:opening", function() {
				//temp disabled closing animation until solution is found - https://studio.somerslab.ibm.com/jira/browse/VR-94
				// Fired to the original element when the dropdown opens
				// Used for closing animations
				//$('.select2-dropdown').removeClass('select2-dropdown--closing');

			}).on("select2:closing", function () {
				//temp disabled closing animation until solution is found - https://studio.somerslab.ibm.com/jira/browse/VR-94
				// fired to the original element when the dropdown closes
				//select2_dropdown = $('.select2-dropdown');
				//select2_dropdown.addClass('select2-dropdown--closing');
			})
			.on("select2:close", function () {
				//temp disabled closing animation until solution is found - https://studio.somerslab.ibm.com/jira/browse/VR-94
				/*
				//fired after the dropdown has been closed (removed)
				var local_select2_dropdown = select2_dropdown;

				
				//everything else should be closed by now as this is select2 default behaviour - so if somehow user spammed selects and bugged them, make sure they are closen
				//this is also needed because of the timeout solution
				clearTimeout(select2_closing_timeout);
				$(".select2-dropdown").each(function() {
					$(this).parent().detach();
					$(this).removeClass('select2-dropdown--closing');
				});

				//append it again because select2 has removed it - our animation removes it
				$("body").append(select2_dropdown.parent());

				//make sure the element gets removed - this is fix for when there are multiple select boxes under eachother - things got buggy
				
				select2_closing_timeout = setTimeout(function() {
					local_select2_dropdown.parent().detach();
					local_select2_dropdown.removeClass('select2-dropdown--closing');
				}, 300);
*/
			});
	};

})(jQuery, IBMCore);

;

/**
	
	Select list nav widget.
	<br />
	<br />This is simply a select list with values that are FULLY QUALIFIED URLs.
	<br />On selection of an item in the list, the user goes to that URL.
	<br />
	<br />__Requirements:__ 
	<br />The form __must__ be set with the @action pointing to the IBM redirect script for cases where JS is disabled or broken.
	<br />The form's select list __must__ have a @name="url" so that it sends the proper param to the IBM redirect script.
	<br />The form's options' values __must__ be fully qualified URLs.
	<br />
	<br />Usage:
		
	<form action="http://www.ibm.com/links" method="get" data-widget="selectlistnav">
		<select id="__SOMEID___" name="url">
		.....
	
	__Special case:__ In scenarios where you dynamically inject the HTML post-load, you can initialize the widget on your injected form HTML like this:
		
	$("myForm").selectlistnav();
		
	@class IBMCore.common.widget.selectlistnav

**/

(function ($, IBM) {

	var me = IBM.namespace(IBM, "common.widget.selectlistnav"),
		selectlistnavWidgets = [],
		object_name = "Selectlistnav";

	/**
		Public jQuery plug-in definition.
		<br />Used by core v18 JS file to auto-init selectlistnav forms HTML that exist on the page on DOM ready.
		<br />If you are dynamically injecting and initing HTML post-load, call this plug-in on your injected selectlistnav FORM.

		@method $.fn.selectlistnav
		@param [settings] {Object} Settings to override defaults and element's @data-xxxx attributes.
	**/
	$.fn.selectlistnav = function (settings) {
		return this.each(function(){
			var d = createSelectlistNav(settings);
			d.init($(this));
		});
	};

	/**
		Called by our jQuery plug-in.
		<br />This creates a new selectlistnav form widget and registers the instance into array of all this widget instances.
		<br />The jQuery plugin abstracts this and makes behind-the-scenes changes easy.
		
		@method createSelectlistNav
		@private
		@param [settings] {Object} Settings to override defaults and element's @data-xxxx attributes.
		@return {Object} The widget object instance created.
	**/
	function createSelectlistNav(settings) {
		var newWidget = new SelectlistNav(settings);
		selectlistnavWidgets.push(newWidget);
		return newWidget;
	}

	/**
		Publishes this event if there was an error creating the widget.
		
		@event error
	**/
	/**
		Publishes this event after the widget has been created successfully.
		
		@event ready
	**/
	/**
		SelectlistNav object/constructor for our public jQuery plugin.
		<br />Called by "createSelectlistNav".
		<br />You can't use this directly. Use the standard $(xxxx).selectlistnav() plug-in method to dynamically turn your
		 select list nav form into the widget.

		@method SelectlistNav
		@constructor
		@private
		@param [settings] {Object} Settings to override defaults and element's @data-xxxx attributes.
	**/
	function SelectlistNav(settings) {
		var me = this,
			containerElement,
			selectElement,
			myEvents = IBM.common.util.eventCoordinator(me, object_name, [
				"ready",
				"error"
			]);

	    /**
			This is a method of the "SelectlistNav" constructor.
			<br />Called by our public jQuery plug-in after a new SelectlistNav form object has been created and returned by "createSelectlistNav".
			<br />Automatically inits the plug-in on the passed form, 
			merging in any manually passed settings, @data-xxxxx settings, and our default settings. 
			
			@method init
			@param $elem {jQuery selector} The form you want to turn into a selectlistnav form widget.
		**/
		me.init = init;
		function init($elem) {
			try {
				// If we're here, it means it's enabled, so build it/do your thing.
				// Binds widget object to the DOM element it was init on by jQuery plugin method.
				// Keep "instance" as-is; ALL element-bound widgets will use this data attribute.
				$elem.data("widget", me);

				containerElement = $elem;
				
				selectElement = $elem.find("select");

				if (selectElement.length === 0) {
					throw "The selectlistnav form must contain a selectlist element. Please add one.";
				}

				initHtml();
				initEvents();

				// Fire an event to tell subscribers we're done.
				myEvents.publish("ready");

			}
			catch (er) {
				myEvents.publish("error", er);
				throw er;
			}
		}

		/**
			Alters HTML for widget (removed submit button)
			
			@method initHtml
			@private
		**/
		function initHtml() {
			containerElement.find("input.ibm-btn-go").remove();
		}

		/**
			Sets up and binds select list to goto selected opion's URL (option value) if not blank.
			
			@method initEvents
			@private
		**/
		function initEvents() {
			selectElement.on("change", function () {
				if ($(this).val() !== "") {
					location.href = $(this).val();
				}
			});
		}
	}

})(jQuery, IBMCore);
;

/**
	
	The show/hide widget (not twisty).
	<br />
	<br />This creates a basic show/hide section, a multi-panel (accordion), and the description show/hide widget.
	<br />Usage:
		
	<!-- Show/hide descriptions -->
	<div data-widget="showhide" class="ibm-simple-show-hide">...</div>
		
	<!-- Show/hide single and multiple panels (accordion) -->
	<div data-widget="showhide" data-type="panel" class="ibm-show-hide">...</div>
	
	__Special case:__ In scenarios where you dynamically inject overlay HTML post-load, you can initialize the widget on your injected show/hide HTML like this:
		
	$("myShowHideDiv").showhide();
	
	<br />Allowed options and values. __All values are strings__ (html standards):
	<br />__data-widget__: showhide
	<br />__data-type__: panel &nbsp; // Creates single and multi-panel (accordion) widgets

	@class IBMCore.common.widget.showhide

**/

(function ($, IBM) {

	var me = IBM.namespace(IBM, "common.widget.showhide"),
		showHideWidgets = [],
		object_name = "ShowHide",
		defaults = {
			type : "simple"
		};

	/**
		Public jQuery plug-in definition.
		<br />Used by core v18 JS file to auto-init show/hide HTML that exist on the page on DOM ready.
		<br />If you are dynamically injecting show/hide HTML post-load, call this plug-in on your injected show/hide container.

		@method $.fn.showhide
		@param [settings] {Object} Settings to override defaults and element's @data-xxxx attributes.
	**/
	$.fn.showhide = function (settings) {
		return this.each(function(){
			var d = createShowHide(settings);
			d.init($(this));
		});
	};

	/**
		Called by our jQuery plug-in.
		<br />This creates a new show/hide widget and registers the instance into array of all this widget instances.
		<br />The jQuery plugin abstracts this and makes behind-the-scenes changes easy.
		
		@method createShowHide
		@private
		@param [settings] {Object} Settings to override defaults and element's @data-xxxx attributes.
		@return {Object} The widget object instance created.
	**/
	function createShowHide (settings) {
		var newShowHide = new ShowHide(settings);
		showHideWidgets.push(newShowHide);
		return newShowHide;
	}

	/**
		Fire a stats event for this widget.
		
		@method fireStatsEvent
		@private 
		@param eventType {String} Type of event that happened.
		@param id {String} The ID of the widget it happened on.
	**/
	function fireStatsEvent (eventType, id) {
		IBM.common.util.statshelper.fireEvent({
			'ibmEV' : 'widget',
			'ibmEvGroup' : 'Showhide',
			'ibmEvName' : eventType,
			'ibmEvAction' : id
		});
	}

	/**
		Publishes this event if the widget was disabled and didn't init.
		
		@event disabled
	**/
	/**
		Publishes this event if there was an error creating the widget.
		
		@event error
	**/
	/**
		Publishes this event after the widget has been created successfully.
		
		@event ready
	**/
	/**
		ShowHide object/constructor for our public jQuery plugin.
		<br />Called by "createShowHide".
		<br />You can't use this directly. Use the standard $(xxxx).showhide() plug-in method to turn your show/hide HTML into a widget.

		@method ShowHide
		@constructor
		@private
		@param [settings] {Object} Settings to override defaults and element's @data-xxxx attributes.
	**/
	function ShowHide (settings) {
		var me = this,
			$container,
			$hideables, // Things to be toggled by "show all" and "hide all" links
			$containers, // Individual panels to be toggled by their headings.
			$headings,
			$controls, // "Show all" and "hide all" contils
			config,
			myEvents = IBM.common.util.eventCoordinator(me, object_name, [
					// Add/remove event names for what this widget needs.
					"ready",
					"disabled",
					"error"
				]),
			slideupSpeed = "fast",
			slideDownSpeed = "fast";

	    /**
			This is a method of the "ShowHide" constructor.
			<br />Called by our public jQuery plug-in after a new show/hide object has been created and returned by "createShowHide".
			<br />Automatically inits the show/hide plug-in merging in any manually passed settings, 
			 @data-xxxxx settings, and our default settings. 
			
			@method init
			@param $elem {jQuery selector} The jQuery selector element to init the plug-in on.
		**/
		me.init = init;
		function init ($elem) {
			try {
				if (!IBM.common.util.checkClearance("show_hide")) {
					myEvents.publish("disabled");
					return false;
				}

				$elem.data("widget", me);

				$container = $elem;
				$hideables = $container.find(".ibm-hideable");
				$containers = $container.find("div.ibm-container-body");
				$controls = $container.find("p.ibm-show-hide-controls");

				config = $.extend({}, defaults, settings, $container.data() || {});
				
				// The headings are only used as the show/hide controls in a type="panel", so if it's not a panel type,
				//  don't accidentally hotlink and bind text heading for the special "description" show/hide.
				if (config.type === "panel") {
					// REAL ONE: $headings = $container.find(" > h2").wrapInner('<a href="#show-hide"></a>');
					// TEMP FIX: until ECM makes update in Feb. Should not have links coded in the h2 for v18.
					$headings = $container.find(" > h2 > a");
					if ($headings.length === 0) {
						$headings = $container.find(" > h2").wrapInner('<a href="#show-hide"></a>').children("a");
					}
				}

				initHtml();
				initEvents();

				// Fire an event to tell subscribers we're done.
				myEvents.publish("ready");

			} 
			catch (er) {
				myEvents.publish("error", er);
				throw er;
			}
		}

		/**
			Alters HTML for widget initialization.
			
			@method initHtml
			@private
		**/
		function initHtml () {
			$container.addClass("ibm-widget-processed");

			if (config.type === "simple") {
				$hideables.addClass("ibm-hide");
			}

			if (config.type === "panel") {
				$headings.removeClass("ibm-active");
				$containers.slideUp(slideupSpeed);
			}
		}

		/**
			Sets up and binds HTML to do show/hide actions.
			
			@method initEvents
			@private
		**/
		function initEvents () {
			if (config.type === "simple") {
				initEventsSimple();
			}
			else if (config.type === "panel") {
				initEventsPanel();
			}
			else {
				throw "Invalid showhide type specified: \"" + config.type + "\". Type must be \"simple\" or \"panel.\"";
			}

			$("h2[data-open='true'] a", $container).each(function(){
				openPanel($(this));
			});
		}

		/**
			Sets up bindings and actions for the description show/hiding.
			
			@method initEventsSimple
			@private
		**/
		function initEventsSimple () {
			$controls.children("a").click(function (evt) {
				evt.preventDefault();

				var $thisLink = $(this),
					$links = $controls.find("a"),
					action = $thisLink.attr("href");

				$links.removeClass("ibm-active");
				$thisLink.addClass("ibm-active");

				if (action === '#show') {
					$hideables.slideDown(slideDownSpeed);
					
					// Fire stats event so they know someone used this widget and what they clicked on.
					fireStatsEvent("show descriptions", "descriptions widget");
				}
				else if (action === '#hide') {
					$hideables.slideUp(slideupSpeed);
					
					// Fire stats event so they know someone used this widget and what they clicked on.
					fireStatsEvent("hide descriptions", "descriptions widget");
				}
			});
		}

		/**
			Sets up bindings and actions for the single and multi-panel (accordion) show/hiding.
			
			@method initEventsPanel
			@private
		**/
		function initEventsPanel () {
			$headings.click(function (evt) {
				evt.preventDefault();

				// If we clicked an open panel, just hide it.
				if ($(this).hasClass("ibm-show-active")) {
					closePanel($(this));

					// Fire stats event saying they hid this section/panel.
					fireStatsEvent("hide", $(this).text());
				}

				// Otherwise, open this panel and hide the others. (Accordion functionality)
				else {
					openPanel($(this));

					// Fire stats event saying they opened this section/panel.
					fireStatsEvent("show", $(this).text());

				}
			});
		}

		function closePanel ($headingLink) {
			var index = $headings.index($headingLink);
			
			$headingLink.removeClass("ibm-show-active").parent().removeClass("ibm-showing");
			
			$containers.eq(index).slideUp(slideupSpeed);
		}

		function openPanel ($headingLink) {
			var index = $headings.index($headingLink);

			// Hide ALL containers:
			$headings.removeClass("ibm-show-active");
			$containers.slideUp(slideupSpeed);

			// Now show this one:
			$headingLink.addClass("ibm-show-active").parent().addClass("ibm-showing");
			$containers.eq(index).slideDown(slideDownSpeed);
		}
		
	}

})(jQuery, IBMCore);
;

/**
	
	The step indicator widget.
	<br />
	<br />This creates a step indicator widget. The same as v17 but using the new data-attributes.
	<br />Usage:
		
	<div data-widget="stepindicator" class="ibm-tab-section ibm-step-indicator">
	
	__Special case:__ In scenarios where you dynamically inject overlay HTML post-load, you can initialize the widget on your injected step indicator HTML like this:
		
	$("myStepindicatorDiv").stepindicator();
	
	<br />Allowed options and values. __All values are strings__ (html standards):
	<br />__data-widget__: stepindicator
	<br />__data-disableprevious__: true | false (default) &nbsp; // Disables ability to go to any previous step except the immediate previous.

	@class IBMCore.common.widget.stepindicator

**/

(function ($, IBM) {

	var me = IBM.namespace(IBM, "common.widget.stepindicator"),
		stepindicatorWidgets = [],
		object_name = "StepIndicator";

	/**
		Public jQuery plug-in definition.
		<br />Used by core v18 JS file to auto-init step indicator HTML that exist on the page on DOM ready.
		<br />If you are dynamically injecting step indicator HTML post-load, call this plug-in on your injected step indicator container.

		@method $.fn.stepindicator
		@param [settings] {Object} Settings to override defaults and element's @data-xxxx attributes.
	**/
	$.fn.stepindicator = function (settings) {
		return this.each(function(){
			var d = createStepIndicator(settings);
			d.init($(this));
		});
	};

	/**
		Called by our jQuery plug-in.
		<br />This creates a new step indicator widget and registers the instance into array of all this widget instances.
		<br />The jQuery plugin abstracts this and makes behind-the-scenes changes easy.
		
		@method createStepIndicator
		@private
		@param [settings] {Object} Settings to override defaults and element's @data-xxxx attributes.
		@return {Object} The widget object instance created.
	**/
	function createStepIndicator (settings) {
		var newStepindicator = new StepIndicator(settings);
		stepindicatorWidgets.push(newStepindicator);
		return newStepindicator;
	}

	/**
		StepIndicator object/constructor for our public jQuery plugin.
		<br />Called by "createStepIndicator".
		<br />You can't use this directly. Use the standard $(xxxx).stepindicator() plug-in method to turn your step indicator HTML into a widget.

		@method StepIndicator
		@constructor
		@private
		@param [settings] {Object} Settings to override defaults and element's @data-xxxx attributes.
	**/
	function StepIndicator (settings) {
		var $container,
			classnames = {
				indicator : "ibm-step-indicator",
				container : "ibm-step-container",
				past_step : "ibm-active-completed",
				present_step : "ibm-active-current",
				future_step : "ibm-disabled",
				inactive_content : "ibm-hidden-content",
				disable_previous : "ibm-disable-previous"
			},
			contents,
			currentStep,
			me = this,
			params,
			steps;

	    /**
			This is a method of the "StepIndicator" constructor.
			<br />Called by our public jQuery plug-in after a new step indicator object has been created and returned by "createStepIndicator".
			<br />Automatically inits the step indicator plug-in merging in any manually passed settings, 
			 @data-xxxxx settings, and our default settings. 
			
			@method init
			@param $elem {jQuery selector} The jQuery selector element to init the plug-in on.
		**/
		me.init = function ($elem) {
			$container = $elem;
			
			console.info($container);

			params = {
				future_clickable: false,
				disable_previous: $elem.data("disableprevious") === true ? true : false,
				content: $elem.next(),
				focus_index: -1
			};
			
			contents = $('.' + classnames.container, params.content);
			
			settings = settings || {};
			
			steps = $("li", $container);

			$.extend(true, params, settings);

			// Remove ibm-access if its there
			if ($("h2.ibm-access", $elem)[0]) {
				$("h2.ibm-access", $elem).remove();
			}

			contents.each(function (i, this_node) {
				$("[data-step=next]", this_node).on("click", function(){
					me.next();
				});

				$("[data-step=prev]", this_node).on("click", function(){
					me.prev();
				});
			});

			params.content.addClass("ibm-widget-processed");

			currentStep = me.getCurrentStep();
			if (currentStep === -1) {
				currentStep = 0;
			}

			me.goToStep(currentStep);

			// A11y.
			IBM.common.util.a11y.makeTabsAccessible({
				el: $elem.children("ul")
			});

			steps.each(function (i, this_node) {
				var $a;
				$a = $("a:eq(0)", this_node);

				$a.click(function (evt) {
					var is_future = me.getCurrentStep() < i;
					if ((!is_future || (is_future && params.future_clickable)) && !params.disable_previous) {
						me.goToStep(i);
					}
					evt.preventDefault();
				});

				// OLD
				// $a.keypress(function (evt) {
				// 	var key = evt.keyCode || evt.which,
				// 		$a_focus = "";

				// 	// If it's right (39) or left (37) key...
				// 	if (key === 39 || key === 37) {
				// 		// Adjust focus index
				// 		params.focus_index = (params.focus_index === -1) ? me.getCurrentStep() : params.focus_index;
				// 		params.focus_index += (key === 39) ? 1 : -1;

				// 		// Check bounds
				// 		if (params.focus_index === me.totalSteps()) {
				// 			params.focus_index = me.totalSteps() - 1;
				// 		}
				// 		else if (params.focus_index < 0) {
				// 			params.focus_index = 0;
				// 		}

				// 		// Focus
				// 		steps.each(function (i, this_node) {
				// 			$a_focus = $("a:eq(0)", this_node);

				// 			if (params.focus_index === i) {
				// 				$a_focus.focus();
				// 			}
				// 		});
				// 	} 
				// 	// Else if it's a spacebar (32).
				// 	else if (key === 32 && !params.disable_previous) {
				// 		me.goToStep(params.focus_index);
				// 		evt.preventDefault();
				// 	}
				// });
			});
		};

	    /**
			This is a method of the "StepIndicator" constructor.
			<br />Gets and returns the current step #.
			
			@method getCurrentStep
			@return {Integer} The current step #.
		**/
		me.getCurrentStep = function () {
			var cs = -1;

			steps.each(function (i,node) {
				if ($('.' + classnames.present_step, node).length > 0) {
					cs = i;
				}
			});

			return cs;
		};

	    /**
			This is a method of the "StepIndicator" constructor.
			<br />Gets and returns the total # of steps.
			
			@method totalSteps
			@return {Integer} The total # of steps.
		**/
		me.totalSteps = function () {
			return steps.length;
		};

	    /**
			This is a method of the "StepIndicator" constructor.
			<br />Tells you if the user is on the first step.
			
			@method isOnFirst
			@return {Boolean} True | False if the user is on the first step.
		**/
		me.isOnFirst = function () {
			return me.getCurrentStep() === 0;
		};

	    /**
			This is a method of the "StepIndicator" constructor.
			<br />Tells you if the user is on the last step.
			
			@method isOnLast
			@return {Boolean} True | False if the user is on the last step.
		**/
		me.isOnLast = function () {
			return me.getCurrentStep() === me.totalSteps() - 1;
		};

	    /**
			This is a method of the "StepIndicator" constructor.
			<br />Advances to the named step #.
			
			@method goToStep
			@param index {Integer} The step # to go to.
		**/
		me.goToStep = function (index) {
			var $a;
			
			steps.each(function (i, this_node) {
				$a = $("a:eq(0)", this_node);

				if (params.disable_previous) {
					$a[(i !== index) ? "addClass" : "removeClass"](classnames.future_step);
					$a[(i === index) ? "addClass" : "removeClass"](classnames.present_step);
				} 
				else {
					$a[(i < index) ? "addClass" : "removeClass"](classnames.past_step);
					$a[(i === index) ? "addClass" : "removeClass"](classnames.present_step);
					$a[(i > index) ? "addClass" : "removeClass"](classnames.future_step);
				}

				// Accessibility updates
				if (i === index) {
					$a.attr("aria-selected", true);
					$a[0].tabIndex = 0;
				}
				else {
					$a.attr("aria-selected", false);
					$a[0].tabIndex = -1;
				}
			});

			contents.each(function (i, this_node) {
				//$(this_node)[(i === index) ? "removeClass" : "addClass"](classnames.inactive_content);
				$(this_node).css("display", (i === index) ? "block" : "none");
				//$(this_node).attr("role","tabpanel");
			});

			params.focus_index = index;
		};

	    /**
			This is a method of the "StepIndicator" constructor.
			<br />Advances to the next step #.
			
			@method next
		**/
		me.next = function () {
			if (!me.isOnLast()) {
				me.goToStep(me.getCurrentStep() + 1);
			}
		};

	    /**
			This is a method of the "StepIndicator" constructor.
			<br />Advances to the previous step #.
			
			@method prev
		**/
		me.prev = function () {
			if (!me.isOnFirst()) {
				me.goToStep(me.getCurrentStep() - 1);
			}
		};
	}

})(jQuery, IBMCore);
;

/**
	
	Syntaxhighlighter plug-in pre-processor. 
	<br />
	<br />Sets defaults for the Syntaxhighlighter plug-in, cleans it up and other random processing to make the widget work. 
	<br />Then it simply inits the jQuery Syntaxhighlighter plug-in. 
	<br />
	<br />Usage:
		
	<pre data-widget="syntaxhighlighter">
	
	__Special case:__ In scenarios where you dynamically inject the &lt;pre> HTML post-load, you can initialize the widget on your injected &lt;pre> HTML like this:
		
	$("myPreElement").syntaxhighlighter();
	
	Styling options are set via the class attribute. __All values are strings__ (html standards):
	<br />__class="brush: js; html-script: true"__ &nbsp; // (default if no class is set) Format for HTML and JS inside &lt;script> tags.
	<br />__class="brush: js"__ &nbsp; // Format for inline/pure JS code only.
	<br />__class="brush: js; html-script: true; gutter: true"__ &nbsp; // Show the gutter and line #s.
	<br />__class="brush: js; html-script: true; gutter: true; highlight: [4]"__ &nbsp; // Highlight the 4th line in the code.
	<br /><br />The highlighter style accepts an array of 1 or more #s, or a range. All of the following are valid:
	<br />__highlight: [4]__
	<br />__highlight: [2,4,7,13]__
	<br />__highlight: [3-7]__

	@class IBMCore.common.widget.syntaxhighlighter

**/

(function($, IBM) {

    var me = IBM.namespace(IBM, 'common.widget.syntaxhighlighter');

	/**
		Public jQuery plug-in definition.
		<br />Used by core v18 JS file to auto-init syntaxhighlighter HTML that exist on the page on DOM ready.
		<br />If you are dynamically injecting code HTML post-load, call this plug-in on your injected &lt;pre> container.

		@method $.fn.syntaxhighlighter
	**/
	$.fn.syntaxhighlighter = function () {
		return this.each(function(){
			createSyntaxHighlighter(this);
		});
	};

 	/**
		Called by our jQuery plug-in.
		<br />This initializes a new syntaxhighlighter widget on the passed DOM element.
		<br />The jQuery plugin abstracts this and makes behind-the-scenes changes easy.
		
		@method createSyntaxHighlighter
		@private
		@param el {DOM element} The DOM element to turn into a syntaxHighlighter widget.
	**/
   function createSyntaxHighlighter (el) {
    	var $el = $(el),
    		$thisContainer = $el.wrap('<div class="ibm-syntax-container"></div>').parent(),
			maxHeight = $el.data("maxheight");

		// Base config defaults to set.
		window.SyntaxHighlighter.defaults.toolbar = false;
		window.SyntaxHighlighter.defaults["auto-links"] = false;
		window.SyntaxHighlighter.defaults.gutter = false;

		// Set default styling option if there is no class.
		if (!$el.attr("class")) {
			$el.attr("class", "brush: js; html-script: true");
		}

		// Automatically convert < to &lt; so their code snippet doesn't execute.
		$el.html($el.html().replace(/</g, "&lt;"));

		// Init the actual plug-in on the element.
		window.SyntaxHighlighter.highlight(window.SyntaxHighlighter.defaults, el);

		// Set the height and allow vertical scroll if option was set.
		if (maxHeight) {
			$(".syntaxhighlighter", $thisContainer).css({
				"max-height": maxHeight,
				"overflow-y": "auto"
			});
		}
    }

})(jQuery, IBMCore);

;

/*
 * tipso - A Lightweight Responsive jQuery Tooltip Plugin v1.0.5
 * Copyright (c) 2014-2015 Bojan Petkovski
 * http://tipso.object505.com
 * Licensed under the MIT license
 * http://object505.mit-license.org/
 */
 // CommonJS, AMD or browser globals
(function (factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define(['jquery'], factory);
    } else if (typeof exports === 'object') {
        // Node/CommonJS
        module.exports = factory(require('jquery'));
    } else {
        // Browser globals
        factory(jQuery);
    }
}(function($) {
  var pluginName = "tipso",
    defaults = {
      speed           : 400,
      background      : '#55b555',
      color           : '#ffffff',
      position        : 'top',
      width           : 200,
      maxWidth        : '',
      delay           : 200,
      animationIn     : '',
      animationOut    : '',
      offsetX         : 0,
      offsetY         : 0,
      tooltipHover    : false,
      content         : null,
      ajaxContentUrl  : null,
      useTitle        : true,
      onBeforeShow    : null,
      onShow          : null,
      onHide          : null
    };

  function Plugin(element, options) {
    this.element = $(element);
    this.doc = $(document);
    this.win = $(window);
    this.settings = $.extend({}, defaults, options);
    this._defaults = defaults;
    this._name = pluginName;
    this._title = this.element.attr('title');
    this.mode = 'hide';
    this.ieFade = !supportsTransitions;

    this.init();
  }
  $.extend(Plugin.prototype, {
    init: function() {
      var obj = this,
        $e = this.element,
        $doc = this.doc;
      $e.addClass('tipso_style').removeAttr('title');
      if (isTouchSupported()) {
        $e.on('click' + '.' + pluginName, function(e) {
          obj.mode == 'hide' ? obj.show() : obj.hide();
          e.stopPropagation();
        });
        $doc.on('click', function closeTipso () {
          if (obj.mode == 'show') {
            obj.hide();
          }
        });
      } else {
        if (obj.settings.tooltipHover) {
          var waitForHover = null,
              hoverHelper = null;
          $e.on('mouseover' + '.' + pluginName, function() {
            clearTimeout(waitForHover);
            clearTimeout(hoverHelper);
            hoverHelper = setTimeout(function(){
              obj.show();
            }, 150);
          });
          $e.on('mouseout' + '.' + pluginName, function() {
            clearTimeout(waitForHover);
            clearTimeout(hoverHelper);
            waitForHover = setTimeout(function(){
              obj.hide();
            }, 200);

            obj.tooltip()
              .on('mouseover' + '.' + pluginName, function() {
                obj.mode = 'tooltipHover';
              })
              .on('mouseout' + '.' + pluginName, function() {
                obj.mode = 'show';
                clearTimeout(waitForHover);
                waitForHover = setTimeout(function(){
                  obj.hide();
                }, 200);
              })
          ;
          });
        } else {
          $e.on('mouseover' + '.' + pluginName, function() {
            obj.show();
          });
          $e.on('mouseout' + '.' + pluginName, function() {
            obj.hide();
          });
        }
      }
    },
    tooltip: function() {
      if (!this.tipso_bubble) {
        this.tipso_bubble = $(
          '<div class="tipso_bubble"><div class="tipso_content"></div><div class="tipso_arrow"></div></div>'
        );
      }
      return this.tipso_bubble;
    },
    show: function() {
      var tipso_bubble = this.tooltip(),
        obj = this,
        $win = this.win;

      if (obj.mode == 'hide') {
        if ($.isFunction(obj.settings.onBeforeShow)) {
          obj.settings.onBeforeShow($(this));
        }
        if (obj.settings.width){
          tipso_bubble.css({
            background: obj.settings.background,
            color: obj.settings.color,
            width: obj.settings.width
          }).hide();
        } else if (obj.settings.maxWidth){
          tipso_bubble.css({
            background: obj.settings.background,
            color: obj.settings.color,
            maxWidth: obj.settings.maxWidth
          }).hide();
        } else {
          tipso_bubble.css({
            background: obj.settings.background,
            color: obj.settings.color,
            width: 200
          }).hide();
        }
        tipso_bubble.find('.tipso_content').html(obj.content());
        reposition(obj);
        $win.resize(function tipsoResizeHandler () {
            reposition(obj);
        });
        obj.timeout = window.setTimeout(function() {
          if (obj.ieFade || obj.settings.animationIn === '' || obj.settings.animationOut === ''){
            tipso_bubble.appendTo('body').stop(true, true).fadeIn(obj.settings
            .speed, function() {
              obj.mode = 'show';
              if ($.isFunction(obj.settings.onShow)) {
                obj.settings.onShow($(this));
              }
            });
          } else {
            tipso_bubble.remove().appendTo('body')
            .stop(true, true)
            .removeClass('animated ' + obj.settings.animationOut)
            .addClass('noAnimation')
            .removeClass('noAnimation')
            .addClass('animated ' + obj.settings.animationIn).fadeIn(obj.settings.speed, function() {
              $(this).one('webkitAnimationEnd mozAnimationEnd MSAnimationEnd oanimationend animationend', function(){
                $(this).removeClass('animated ' + obj.settings.animationIn);
              });
              obj.mode = 'show';
              if ($.isFunction(obj.settings.onShow)) {
                obj.settings.onShow($(this));
              }
              $win.off('resize', null, 'tipsoResizeHandler');
            });
          }
        }, obj.settings.delay);
      }
    },
    hide: function() {
      var obj = this,
        $win = this.win;
        tipso_bubble = this.tooltip();

      window.clearTimeout(obj.timeout);
      obj.timeout = null;
      if (obj.mode != 'tooltipHover') {
        if (obj.ieFade || obj.settings.animationIn === '' || obj.settings.animationOut === ''){
          tipso_bubble.stop(true, true).fadeOut(obj.settings.speed,
          function() {
            $(this).remove();
            if ($.isFunction(obj.settings.onHide) && obj.mode == 'show') {
              obj.settings.onHide($(this));
            }
            obj.mode = 'hide';
            $win.off('resize', null, 'tipsoResizeHandler');
          });
        } else {
          tipso_bubble.stop(true, true)
          .removeClass('animated ' + obj.settings.animationIn)
          .addClass('noAnimation').removeClass('noAnimation')
          .addClass('animated ' + obj.settings.animationOut)
          .one('webkitAnimationEnd mozAnimationEnd MSAnimationEnd oanimationend animationend', function(){
            $(this).removeClass('animated ' + obj.settings.animationOut).remove();
            if ($.isFunction(obj.settings.onHide) && obj.mode == 'show') {
              obj.settings.onHide($(this));
            }
            obj.mode = 'hide';
            $win.off('resize', null, 'tipsoResizeHandler');
          });
        }
      }
    },
    destroy: function() {
      var $e = this.element,
        $win = this.win,
        $doc = this.doc;
      $e.off('.' + pluginName);
      $win.off('resize', null, 'tipsoResizeHandler');
      if (isTouchSupported()) {
        $doc.off('click', null, 'closeTipso' );
      }
      $e.removeData(pluginName);
      $e.removeClass('tipso_style').attr('title', this._title);
    },
    content: function() {
      var content,
        $e = this.element,
        obj = this,
        title = this._title;
      if (obj.settings.ajaxContentUrl) {
        content = $.ajax({
          type: "GET",
          url: obj.settings.ajaxContentUrl,
          async: false
        }).responseText;
      } else if (obj.settings.content) {
        content = obj.settings.content;
      } else {
        if (obj.settings.useTitle === true) {
          content = title;
        } else {
          content = $e.data('tipso');
        }
      }
      return content;
    },
    update: function(key, value) {
      var obj = this;
      if (value) {
        obj.settings[key] = value;
      } else {
        return obj.settings[key];
      }
    }
  });

  function isTouchSupported() {
    var msTouchEnabled = window.navigator.msMaxTouchPoints;
    var generalTouchEnabled = "ontouchstart" in document.createElement(
      "div");
    if (msTouchEnabled || generalTouchEnabled) {
      return true;
    }
    return false;
  }

  function realHeight(obj) {
    var clone = obj.clone();
    clone.css("visibility", "hidden");
    $('body').append(clone);
    var height = clone.outerHeight();
    var width = clone.outerWidth();
    clone.remove();
    return {
      'width' : width,
      'height' : height
    };
  }

  var supportsTransitions = (function() {
    var s = document.createElement('p').style,
        v = ['ms','O','Moz','Webkit'];
    if( s['transition'] == '' ) return true;
    while( v.length )
        if( v.pop() + 'Transition' in s )
            return true;
    return false;
  })();

  function reposition(thisthat) {
    var tipso_bubble = thisthat.tooltip(),
      $e = thisthat.element,
      obj = thisthat,
      $win = $(window),
      arrow = 10,
      pos_top, pos_left, diff;

      if ( $e.parent().outerWidth() > $win.outerWidth() ){
        $win = $e.parent();
      }
    switch (obj.settings.position) {
      case 'top':
        pos_left = $e.offset().left + ($e.outerWidth() / 2) - (realHeight(tipso_bubble).width / 2);
        pos_top = $e.offset().top - realHeight(tipso_bubble).height - arrow;
        tipso_bubble.find('.tipso_arrow').css({
          marginLeft: -8,
          marginTop: ''
        });
        if (pos_top < $win.scrollTop()) {
          pos_top = $e.offset().top + $e.outerHeight() + arrow;
          tipso_bubble.find('.tipso_arrow').css({
            'border-bottom-color': obj.settings.background,
            'border-top-color': 'transparent',
            'border-left-color': 'transparent',
            'border-right-color': 'transparent'
          });
          tipso_bubble.removeClass('top bottom left right');
          tipso_bubble.addClass('bottom');
        } else {
          tipso_bubble.find('.tipso_arrow').css({
            'border-top-color': obj.settings.background,
            'border-bottom-color': 'transparent',
            'border-left-color': 'transparent',
            'border-right-color': 'transparent'
          });
          tipso_bubble.removeClass('top bottom left right');
          tipso_bubble.addClass('top');
        }
        break;
      case 'bottom':
        pos_left = $e.offset().left + ($e.outerWidth() / 2) - (realHeight(tipso_bubble).width / 2);
        pos_top = $e.offset().top + $e.outerHeight() + arrow;
        tipso_bubble.find('.tipso_arrow').css({
          marginLeft: -8,
          marginTop: ''
        });
        if (pos_top + realHeight(tipso_bubble).height > $win.scrollTop() + $win.outerHeight()) {
          pos_top = $e.offset().top - realHeight(tipso_bubble).height - arrow;
          tipso_bubble.find('.tipso_arrow').css({
            'border-top-color': obj.settings.background,
            'border-bottom-color': 'transparent',
            'border-left-color': 'transparent',
            'border-right-color': 'transparent'
          });
          tipso_bubble.removeClass('top bottom left right');
          tipso_bubble.addClass('top');
        } else {
          tipso_bubble.find('.tipso_arrow').css({
            'border-bottom-color': obj.settings.background,
            'border-top-color': 'transparent',
            'border-left-color': 'transparent',
            'border-right-color': 'transparent'
          });
          tipso_bubble.removeClass('top bottom left right');
          tipso_bubble.addClass(obj.settings.position);
        }
        break;
      case 'left':
        pos_left = $e.offset().left - realHeight(tipso_bubble).width - arrow;
        pos_top = $e.offset().top + ($e.outerHeight() / 2) - (realHeight(tipso_bubble).height / 2);
        tipso_bubble.find('.tipso_arrow').css({
          marginTop: -8,
          marginLeft: ''
        });
        if (pos_left < $win.scrollLeft()) {
          pos_left = $e.offset().left + $e.outerWidth() + arrow;
          tipso_bubble.find('.tipso_arrow').css({
            'border-right-color': obj.settings.background,
            'border-left-color': 'transparent',
            'border-top-color': 'transparent',
            'border-bottom-color': 'transparent'
          });
          tipso_bubble.removeClass('top bottom left right');
          tipso_bubble.addClass('right');
        } else {
          tipso_bubble.find('.tipso_arrow').css({
            'border-left-color': obj.settings.background,
            'border-right-color': 'transparent',
            'border-top-color': 'transparent',
            'border-bottom-color': 'transparent'
          });
          tipso_bubble.removeClass('top bottom left right');
          tipso_bubble.addClass(obj.settings.position);
        }
        break;
      case 'right':
        pos_left = $e.offset().left + $e.outerWidth() + arrow;
        pos_top = $e.offset().top + ($e.outerHeight() / 2) - (realHeight(tipso_bubble).height / 2);
        tipso_bubble.find('.tipso_arrow').css({
          marginTop: -8,
          marginLeft: ''
        });
        if (pos_left + arrow + obj.settings.width > $win.scrollLeft() +
          $win.outerWidth()) {
          pos_left = $e.offset().left - realHeight(tipso_bubble).width - arrow;
          tipso_bubble.find('.tipso_arrow').css({
            'border-left-color': obj.settings.background,
            'border-right-color': 'transparent',
            'border-top-color': 'transparent',
            'border-bottom-color': 'transparent'
          });
          tipso_bubble.removeClass('top bottom left right');
          tipso_bubble.addClass('left');
        } else {
          tipso_bubble.find('.tipso_arrow').css({
            'border-right-color': obj.settings.background,
            'border-left-color': 'transparent',
            'border-top-color': 'transparent',
            'border-bottom-color': 'transparent'
          });
          tipso_bubble.removeClass('top bottom left right');
          tipso_bubble.addClass(obj.settings.position);
        }
        break;
    }
    if (pos_left < $win.scrollLeft() && (obj.settings.position == 'bottom' ||
      obj.settings.position == 'top')) {
      tipso_bubble.find('.tipso_arrow').css({
        marginLeft: pos_left - 8
      });
      pos_left = 0;
    }
    if (pos_left + obj.settings.width > $win.outerWidth() && (obj.settings.position ==
      'bottom' || obj.settings.position == 'top')) {
      diff = $win.outerWidth() - (pos_left + obj.settings.width);
      tipso_bubble.find('.tipso_arrow').css({
        marginLeft: -diff - 8,
        marginTop: ''
      });
      pos_left = pos_left + diff;
    }
    if (pos_left < $win.scrollLeft() && (obj.settings.position == 'left' ||
      obj.settings.position == 'right')) {
      pos_left = $e.offset().left + ($e.outerWidth() / 2) - (realHeight(tipso_bubble).width / 2);
      tipso_bubble.find('.tipso_arrow').css({
        marginLeft: -8,
        marginTop: ''
      });
      pos_top = $e.offset().top - realHeight(tipso_bubble).height - arrow;
      if (pos_top < $win.scrollTop()) {
        pos_top = $e.offset().top + $e.outerHeight() + arrow;
        tipso_bubble.find('.tipso_arrow').css({
          'border-bottom-color': obj.settings.background,
          'border-top-color': 'transparent',
          'border-left-color': 'transparent',
          'border-right-color': 'transparent'
        });
        tipso_bubble.removeClass('top bottom left right');
        tipso_bubble.addClass('bottom');
      } else {
        tipso_bubble.find('.tipso_arrow').css({
          'border-top-color': obj.settings.background,
          'border-bottom-color': 'transparent',
          'border-left-color': 'transparent',
          'border-right-color': 'transparent'
        });
        tipso_bubble.removeClass('top bottom left right');
        tipso_bubble.addClass('top');
      }
      if (pos_left + obj.settings.width > $win.outerWidth()) {
        diff = $win.outerWidth() - (pos_left + obj.settings.width);
        tipso_bubble.find('.tipso_arrow').css({
          marginLeft: -diff - 8,
          marginTop: ''
        });
        pos_left = pos_left + diff;
      }
      if (pos_left < $win.scrollLeft()) {
        tipso_bubble.find('.tipso_arrow').css({
          marginLeft: pos_left - 8
        });
        pos_left = 0;
      }
    }
    if (pos_left + obj.settings.width > $win.outerWidth() && (obj.settings.position == 'left' || obj.settings.position == 'right')) {
      pos_left = $e.offset().left + ($e.outerWidth() / 2) - (realHeight(tipso_bubble).width / 2);
      tipso_bubble.find('.tipso_arrow').css({
        marginLeft: -8,
        marginTop: ''
      });
      pos_top = $e.offset().top - realHeight(tipso_bubble).height - arrow;
      if (pos_top < $win.scrollTop()) {
        pos_top = $e.offset().top + $e.outerHeight() + arrow;
        tipso_bubble.find('.tipso_arrow').css({
          'border-bottom-color': obj.settings.background,
          'border-top-color': 'transparent',
          'border-left-color': 'transparent',
          'border-right-color': 'transparent'
        });
        tipso_bubble.removeClass('top bottom left right');
        tipso_bubble.addClass('bottom');
      } else {
        tipso_bubble.find('.tipso_arrow').css({
          'border-top-color': obj.settings.background,
          'border-bottom-color': 'transparent',
          'border-left-color': 'transparent',
          'border-right-color': 'transparent'
        });
        tipso_bubble.removeClass('top bottom left right');
        tipso_bubble.addClass('top');
      }
      if (pos_left + obj.settings.width > $win.outerWidth()) {
        diff = $win.outerWidth() - (pos_left + obj.settings.width);
        tipso_bubble.find('.tipso_arrow').css({
          marginLeft: -diff - 8,
          marginTop: ''
        });
        pos_left = pos_left + diff;
      }
      if (pos_left < $win.scrollLeft()) {
        tipso_bubble.find('.tipso_arrow').css({
          marginLeft: pos_left - 8
        });
        pos_left = 0;
      }
    }
    tipso_bubble.css({
      left: pos_left + obj.settings.offsetX,
      top: pos_top + obj.settings.offsetY
    });
  }
  $[pluginName] = $.fn[pluginName] = function(options) {
    var args = arguments;
    if (options === undefined || typeof options === 'object') {
      if (!(this instanceof $)) {
        $.extend(defaults, options);
      }
      return this.each(function() {
        if (!$.data(this, 'plugin_' + pluginName)) {
          $.data(this, 'plugin_' + pluginName, new Plugin(this, options));
        }
      });
    } else if (typeof options === 'string' && options[0] !== '_' && options !==
      'init') {
      var returns;
      this.each(function() {
        var instance = $.data(this, 'plugin_' + pluginName);
        if (!instance) {
          instance = $.data(this, 'plugin_' + pluginName, new Plugin(
            this, options));
        }
        if (instance instanceof Plugin && typeof instance[options] ===
          'function') {
          returns = instance[options].apply(instance, Array.prototype.slice
            .call(args, 1));
        }
        if (options === 'destroy') {
          $.data(this, 'plugin_' + pluginName, null);
        }
      });
      return returns !== undefined ? returns : this;
    }
  };
}));
;

/**
	
	Tooltip widget.
	<br />
	<br />This will automatically create a custom mouse-over tooltip on the element, using either the @title attribute for the contents of the tooltip, or a named element ID's contents. Instead of the default browser tooltip, the user will see this one.
	<br />Usage:
		
	<a href="http://www.ibm.com/some/path" title="This is my tooltip text" data-widget="tooltip">This is a link with a tooltip.</a>
	
	__Special case:__ In scenarios where you dynamically inject tooltip HTML post-load, you can initialize the widget on your injected tooltip HTML like this:
		
	$("#myTooltipelementID").tooltip();
	
	Allowed options and values. __All values are strings__ (html standards):
	<br />__data-widget__: tooltip
	<br />__data-contentid__: {String}  &nbsp; // The ID of the element to use for the tooltip's content
	
	@class IBMCore.common.widget.tooltip

**/


(function ($, IBM) {

	var me = IBM.namespace(IBM, "common.widget.tooltip"),
		tooltipWidgets = [],
		object_name = "Tooltip";

	/**
		Public jQuery plug-in definition.
		<br />Used by core v18 JS file to auto-init tooltip HTML that exist on the page on DOM ready.
		<br />If you are dynamically injecting tooltip HTML post-load, call this plug-in on your injected tooltip element.

		@method $.fn.tooltip
		@param [settings] {Object} Settings to override defaults and element's @data-xxxx attributes.
	**/
	$.fn.tooltip = function (settings) {
		return this.each(function(){
			var newToolip = createTooltip(settings);
			
			newToolip.init($(this));
		});
	};

	/**
		Called by our jQuery plug-in.
		<br />This creates a new tooltip widget and registers the instance into array of all this widget instances.
		<br />The jQuery plugin abstracts this and makes behind-the-scenes changes easy.
		
		@method createTooltip
		@private
		@param [settings] {Object} Settings to override defaults and element's @data-xxxx attributes.
		@return {Object} The widget object instance created.
	**/
	function createTooltip (settings) {
		var widget = new Tooltip(settings);
		
		tooltipWidgets.push(widget);
		
		return widget;
	}
	
	
	/**
		Tooltip object/constructor for our public jQuery plugin.
		<br />Called by "createTooltip".
		<br />You can't use this directly. Use the standard $(xxxx).tooltip() plug-in method to turn your tooltip element HTML into a tooltip widget.

		@method Tooltip
		@constructor
		@private
		@param [settings] {Object} Settings to override defaults and element's @data-xxxx attributes.
	**/
	function Tooltip (settings) {
		var me = this,
			config,
			defaults = {
				background: "#ECECEC",
				color : "#323232",
				contentid: "",
				speed: 200,
				width: null,
				maxWidth: 300
			},
			myEvents = IBM.common.util.eventCoordinator(me, object_name, [
				"ready",
				"disabled",
				"error"
			]);

	    /**
			This is a method of the "Tooltip" constructor.
			<br />Called by our public jQuery plug-in after a new tooltip object has been created and returned by "createTooltip".
			<br />Automatically inits the tooltip plug-in. 
			
			@method init
		**/
		me.init = function ($elem) {
			// If we're here, it means it's enabled, so build it/do your thing. 
			// Binds widget object to the DOM element it was init on by jQuery plugin method.
			// Keep "instance" as-is; ALL element-bound widgets will use this data attribute.
			$elem.data("widget", me);

			// Merge in configuration to use, then init plug-in with them:  JS settings override HTML which override defaults.
			config = $.extend({}, defaults, $elem.data() || {}, settings);

			// If they are using a remote tooltip (div ID), set proper config for it.
			if (config.contentid !== "") {
				config.useTitle = false;
				config.tooltipHover = true;
				config.content = $("#" + config.contentid).html();
			}

			// Init the plug in.
			$elem.tipso(config);

			// Fire an event to tell subscribers we're done.
			myEvents.publish("ready", $elem);
		};
	}

})(jQuery, IBMCore);

;

/**
	
	The twisty show/hide widget.
	<br />
	<br />This creates a basic twisty show/hide widget (the little triangle that twists when open/closed)
	<br />Usage:
		
	<ul data-widget="twisty" class="ibm-twisty">...</ul>
	
	__Special case:__ In scenarios where you dynamically inject the twisty list HTML post-load, you can initialize the widget on your injected twisty HTML like this:
		
	$("myUL").twisty();
	
	@class IBMCore.common.widget.twisty

**/

(function ($, IBM) {

	var me = IBM.namespace(IBM, "common.widget.twisty"),
		twistyWidgets = [],
		object_name = "Twisty";

	/**
		Public jQuery plug-in definition.
		<br />Used by core v18 JS file to auto-init twisty UL HTML that exist on the page on DOM ready.
		<br />If you are dynamically injecting twisty UL HTML post-load, call this plug-in on your injected twisty UL.

		@method $.fn.twisty
		@param [settings] {Object} Settings to override defaults and element's @data-xxxx attributes.
	**/
	$.fn.twisty = function (settings) {
		return this.each(function() {
			var d = createTwisty(settings);
			d.init($(this));
		});
	};

	/**
		Called by our jQuery plug-in.
		<br />This creates a new twisty widget and registers the instance into array of all this widget instances.
		<br />The jQuery plugin abstracts this and makes behind-the-scenes changes easy.
		
		@method createTwisty
		@private
		@param [settings] {Object} Settings to override defaults and element's @data-xxxx attributes.
		@return {Object} The widget object instance created.
	**/
	function createTwisty (settings) {
		var newTwisty = new Twisty(settings);
		twistyWidgets.push(newTwisty);
		return newTwisty;
	}
	
	/**
		Fire a stats event for this widget.
		
		@method fireStatsEvent
		@private 
		@param eventType {String} Type of event that happened.
		@param id {String} The ID of the widget it happened on.
	**/
	function fireStatsEvent (eventType, id) {
		IBM.common.util.statshelper.fireEvent({
			'ibmEV' : 'widget',
			'ibmEvGroup' : 'Twisty',
			'ibmEvName' : eventType,
			'ibmEvAction' : id
		});
	}
	/**
		Publishes this event if the widget was disabled and didn't init.
		
		@event disabled
	**/
	/**
		Publishes this event if there was an error creating the widget.
		
		@event error
	**/
	/**
		Publishes this event after the widget has been created successfully.
		
		@event ready
	**/
	/**
		Twisty object/constructor for our public jQuery plugin.
		<br />Called by "createTwisty".
		<br />You can't use this directly. Use the standard $(xxxx).twisty() plug-in method to turn your twisty UL into a widget.

		@method Twisty
		@constructor
		@private
		@param [settings] {Object} Settings to override defaults and element's @data-xxxx attributes.
	**/
	function Twisty (settings) {
		var me = this,
			$container,
			$listItems,
			myEvents = IBM.common.util.eventCoordinator(me, object_name, [
				"ready",
				"disabled",
				"error"
			]),
			twistyTriggerHtml = '<a class="ibm-twisty-trigger" href="#toggle"><img alt="-" src="//www.ibm.com/i/c.gif"></a>';

	    /**
			This is a method of the "Twisty" constructor.
			<br />Called by our public jQuery plug-in after a new Twisty object has been created and returned by "createTwisty".
			<br />Automatically inits the twisty plug-in merging in any manually passed settings, 
			 @data-xxxxx settings, and our default settings. 
			
			@method init
			@param $elem {jQuery selector} The jQuery selector element to init the plug-in on.
		**/
		me.init = init;
		function init ($elem) {
			try {
				if (!IBM.common.util.checkClearance("twisty")) {
					myEvents.publish("disabled");
					return false;
				}

				$elem.data("widget", me);

				$container = $elem;

				initHtml();
				initEvents();

				myEvents.publish("ready");

			} 
			catch (er) {
				myEvents.publish("error", er);
				throw er;
			}
		}

		/**
			Alters HTML for widget initialization.
			
			@method initHtml
			@private
		**/
		function initHtml () {
			$container.addClass("ibm-widget-processed");

			$listItems = $container.find("li");
			
			$listItems.each(function () {
				var $li = $(this);

				// If they coded the HTML with the new way (don't put the link in there), add it.
				if ($(" > a.ibm-twisty-trigger", $li).length === 0 && $(" > .ibm-twisty-head", $li).length === 1){
					$li.prepend(twistyTriggerHtml);
				}

				// Now adjust the HTML for the v18 way to make the twisty link/control
				$(" > a.ibm-twisty-trigger", $li).html($(" > .ibm-twisty-head", $li).html());
				$(" > .ibm-twisty-head", $li).remove();

				if ($li.data("open") !== true) {
					collapse($li);
				}
				else {
					expand($li);
				}
			});			
		}

		/**
			Sets up and binds HTML to do show/hide actions.
			
			@method initEvents
			@private
		**/
		function initEvents () {
			$container.on("click", "a.ibm-twisty-trigger, span.ibm-twisty-head", function (evt) {
				evt.preventDefault();

				var $li = $(this).closest("li");

				toggle($li);
			});
		}

		/**
			Collapses the twisty.
			
			@method collapse
			@param $li (jQuery selector) The LI that was clicked to collapse.
		**/
		me.collapse = collapse;
		function collapse ($li) {
			$li.removeClass('ibm-active');
			
			$li.find('> a.ibm-twisty-trigger')
				.find('img')
				.attr('alt', '+');	

			$li.find('> div.ibm-twisty-body').css('display', 'none');
		}

		/**
			Expands the twisty.
			
			@method expand
			@param $li (jQuery selector) The LI that was clicked to expand.
		**/
		me.expand = expand;
		function expand ($li) {
			$li.addClass('ibm-active');
			
			$li.find('> a.ibm-twisty-trigger')
				.find('img').attr('alt', '-');
			
			$li.find('> div.ibm-twisty-body').css('display', 'block');
		}

		/**
			Toggles the twisty open or closed... whatever is the opposite of it's current state.
			
			@method toggle
			@param $li (jQuery selector) The LI that was clicked to expand/collapse.
		**/
		me.toggle = toggle;
		function toggle ($li) {
			if ($li.hasClass('ibm-active')) {
				collapse($li);
				
				fireStatsEvent("collapse", $li.find('> a.ibm-twisty-trigger').next("span").text());
			}
			else {
				expand($li);

				fireStatsEvent("expand", $li.find('> a.ibm-twisty-trigger').next("span").text());
			}
		}
	}

})(jQuery, IBMCore);
;

/**

	IBM video looper widget/utility
	<br />
	<br />This allows you to easily loop a __background__ video a certain # of times.
	<br />Simply add the widget and the # of times the video should play.
	<br />__NOTE__: You must set it to autoplay, but __not__ set the video "loop" attribute.
	<br />
	<br />Usage:
		
		<video data-widget="videolooper" data-playtimes="3"......></video>
		
	<br />Allowed options and values. __All values are strings__ (html standards):
	<br />__data-widget__: videolooper
	<br />__data-playtimes__: <number>

	@class IBMCore.common.widget.videolooper

**/

(function($, IBM) {

	var me = IBM.namespace(IBM, "common.widget.videolooper"),
		videoLoopers = [],
		object_name = "Videolooper";
	
	$.fn.videolooper = function (settings) {
		return this.each(function () {
			var d = createVideoLooper(settings);
			d.init($(this));
		});
	};

	function createVideoLooper (settings) {
		var widget = new VideoLooper(settings);
		
		videoLoopers.push(widget);
		
		return widget;
	}

	function VideoLooper (settings) {
		var me = this,
			$container,
			config,
			defaults = {
				playtimes: 1
			},
			playsLeft = 1;

	    /**
			This is a method of the "Videolooper" constructor.
			<br />Called by our public jQuery plug-in after a new object has been created and returned by "create" function.
			<br />Automatically inits the plug-in on the passed element, 
			merging in any manually passed settings, @data-xxxxx settings, and our default settings. 
			
			@method init
			@param {jQuery selector} $elem The element you want to init the widget on.
		**/
		me.init = init;
		function init ($elem) {
			$elem.data("widget", me);

			$container = $elem;

			// Merge in configuration to use, then init plug-in with them:  JS settings override HTML which override defaults.
			config = $.extend({}, defaults, $container.data() || {}, settings);

			playsLeft = config.playtimes;

			$container.bind("ended", function() {
				playsLeft = playsLeft - 1;

				if (playsLeft !== 0) {
					this.play(); 
				}
			});
		}
	}
	
})(jQuery, IBMCore);;

/**

	IBM video player widget.
	<br />
	<br />This only sets up the .videoplayer() jQuery plug-in and creates the video player widget factory. That's it.
	<br />Automatically creates the proper video player widget on page load based on the presence and value of the 
	magic @data-widget="videoplayer" attribute on the element.
	<br />Each type of player is an object/class and is in it's own separate file for ease of maintenance.
	<br />This file should only be touched if there is a new type of player, in which case you just add it to the factory.
	<br />
	<br />Usage:
		
		<!-- Basic default inline video player -->
		<div data-widget="videoplayer" data-videoid="9mMzHSM2z14" data-videotype="youtube"></div>
		
		<!-- Basic default "play in an overlay" video player -->
		<p class="ibm-ind-link"><a data-widget="videoplayer" data-videodisplay="overlay" data-videoid="9mMzHSM2z14" data-videotype="youtube" class="ibm-video-link" href="https://www.youtube.com/watch?v=9mMzHSM2z14&index=1&list=WL">Watch the video</a></p>
		
		<!-- Basic default videos in a carousel via manual video list, "play in an overlay" -->
		<div data-widget="videoplayer" data-videodisplay="carousel-overlay" data-videoid="0uje575Dewc, 9mMzHSM2z14, fZ_JOBCLF-I, eKGpsM0LGyY" data-videotype="youtube"></div>
		
		<!-- Basic default videos in a carousel via YouTube playlist ID, "play in an overlay", specifying the # of columns(videos) per carousel panel -->
		<div data-widget="videoplayer" data-videodisplay="carousel-overlay" data-carouselcolumns="3" data-videoplaylistid="PLaFe0BJiho2qz2KOUVLdl1DLBA__P1K5Y" data-videotype="youtube"></div>

	<br />Allowed options and values. __All values are strings__ (html standards):
	<br />__data-widget__: videoplayer
	<br />__data-carouselcolumns__: 1 | 2 | 3 | 4 | 5 | 6
	<br />__data-customplaceholder__: true | false (default)
	<br />__data-ibmevent_<eventParamNameLowercase>__: "String value"
	<br />__data-imagesize__: large (default) | medium | thumbnail (Youtube only)
	<br />__data-maxnumvideos__: n | 20 (default)
	<br />__data-overlayplayersize__: medium (default) | large | xlarge
	<br />__data-placeholderalttext__: "String value"
	<br />__data-playervar_showinfo__: 0 | 1 (default)
	<br />__data-showimageplaybutton__: true (default) | false
	<br />__data-showvideodescription__: true | false (default)
	<br />__data-showvideoduration__: true (default) | false
	<br />__data-showvideotitle__: true (default) | false
	<br />__data-theatermode__: true | false (default)
	<br />__data-titledisplaytype__: below (default) | overlay
	<br />__data-videodisplay__: inline (default) | overlay | overlayandtrigger | carousel-inline | carousel-overlay
	<br />__data-videoid__: &lt;video\_id>[,&lt;video\_id>+]
	<br />__data-videoplaylistid__: &lt;playlist\_id>
	<br />__data-videoratio__: "16/9" (default) | "<W>/<H>"
	<br />__data-videotitleoverride__: <empty>
	<br />__data-videotype__: youtube | kaltura

	@class IBMCore.common.widget.videoplayer

**/

(function($, IBM) {

	var ibmVp = IBM.namespace(IBM, 'common.widget.videoplayer');
	
	ibmVp.videos = [];
	ibmVp.object_name = "Videoplayer";
		
	/**
		The IBM video player plug-in.
		<br />
		<br />This 

	**/
	$.fn.videoplayer = function (settings) {
		return this.each(function(){
			var thisPlayer = createVideoPlayer(this, settings);

			ibmVp.videos.push(thisPlayer);

			$(this).data("widget", thisPlayer);

			thisPlayer.init();

		});
	};

	// #2. 
	// Called by the public jQuery plug-in. Makes behind-the-scenes changes easy.
	// Inits the widget & registers the instance into array of all this widget instances and returns instance to caller.
	function createVideoPlayer(el, userSettings) {
		var defaultSettings = {
				videotype: "direct",
				width: $(el).width()
			},
			appliedSettings = $.extend(true, defaultSettings, $(el).data(), userSettings, {origEl: el}),
			playerObj = {
				appliedSettings: appliedSettings,
				init: function () {
					console.warn("Video player type is not valid on this element: ", appliedSettings.origEl);
				},
				status: "Video player type is not valid."
			};

		/** 
			Video player factory. 
			Creates and returns the proper vendor plugin object.
			This is the only thing that should be touched, and it's only when you need to add/remove a type of player from the factory.
		
			Init is called after new videoplayer() above in createVideoPlayer.
			This decides what type of sub-class/object player to create.
			That sub class/object player is responsible for everything.
		**/
		switch (appliedSettings.videotype) {
			case "youtube" : 
				playerObj = new ibmVp.youtube.Player(appliedSettings);
				break;
			
			case "qumu" : 
				playerObj = new ibmVp.qumu.Player(appliedSettings);
				break;
				
			case "kaltura" : 
				playerObj = new ibmVp.kaltura.Player(appliedSettings);
				break;
			
			case "direct" : 
				playerObj = new ibmVp.flowplayer.Player(appliedSettings);
				break;
			
			default: 
				// Do nothing (Error handled by default obj set at top of class).
				break;
		}

		return playerObj;
	}

	/**
		Common video player methods and helers.
	************************************************************************************************************/

	// Take the # of columns we're supposed to put in the carousel and return the proper class to use for each column in it.
	ibmVp.columnsToClass = function(num) {
		var className = "";

		// In most popular order for speed.
		switch (num) {
			case 6: 
				className = "ibm-col-6-1";
				break;
			
			case 5:
				className = "ibm-col-5-1";
				break;
			
			case 3: 
				className = "ibm-col-6-2";
				break;
			
			case 4: 
				className = "ibm-col-4-1";
				break;
			
			case 2: 
				className = "ibm-col-6-3";
				break;
			
			case 1: 
				className = "ibm-col-1-1";
				break;
			
			default: 
				break;
		}

		return className;
	};

	// Create an instance of an overlay, bind COMMON OVERLAY ONLY actions (like on close).
	// Then set it as an object property for common use.
	ibmVp.createOverlay = function (settings) {
		var thisOverlay = IBM.common.widget.overlay.createOverlay({
				backgroundcolor: "#000000",
				classes: settings.overlayclasses + " ibm-video-overlay",
				contentHtml: " ",
				fullwidth: settings.theatermode,
				hidexscroll: true,
				seamless: true
			});
		
		thisOverlay.init();
		
		return thisOverlay;
	};

	// Loop thru each videoid and put in columns and create placeholder divs.
	// Take @data-attr from orig el, dupe to each placeholder to set options on each video.
	// Set proper @data-videodisplay on each placeholder trigger image we made.
	// Init each video widget container DIV with .videoplayer()
	// Init carousel.
	ibmVp.createVideoCarousel = function (videoIds, appliedSettings) {
			var ids = videoIds.split(","),
				thisColumnIds,
				columns = [];

			// For each video ID in the array, put each into a ibm-col-x-x and output video widget div container for it.
			function createColumn (ids) {
				var colHtml = "";

				$.each(ids, function(){
					colHtml += '<div class="' + ibmVp.columnsToClass(appliedSettings.carouselcolumns) + '"><div data-videoid="' + this + '"></div></div>';
				});

				return colHtml;
			}

			// Splice out X number of videos for each ibm-column, build each ibm-col-x-x for it and add the column to the array of columns
			//  for the carousel HTML output.
			while (ids.length >= appliedSettings.carouselcolumns) {
				thisColumnIds = ids.splice(0, appliedSettings.carouselcolumns);
				
				columns.push('<div class="ibm-columns">' + createColumn(thisColumnIds) + '</div>');
			}

			// Add any remaining videos in a column.
			if (ids.length > 0) {
				columns.push('<div class="ibm-columns">' + createColumn(ids) + '</div>');
			}

			// Echo the carousel with video widget containers in the original element.
			appliedSettings.$origEl.html('<div data-widget="carousel">' + columns.join(" ") + '</div>');

			// Init the video widget on each container we just output.
			$("[data-videoid]", appliedSettings.$origEl).each(function(){
				var $this = $(this);

				// Copy the data-attrs from original carousel El, to this el, but then
				//  overwrite the specific data-attrs needed for this specific player.
				$.extend(true, $this.data(), appliedSettings.$origEl.data(), {
					videotype: appliedSettings.videotype,
					videodisplay: appliedSettings.videodisplay === "carousel-overlay" ? "overlayandtrigger" : "inline",
					videoid: $this.data().videoid
				});

				// Init this player
				$this.videoplayer($this.data());
			});

			// We just init each of the players in the carouse, so now init the carousel.
			$("[data-widget='carousel']", appliedSettings.$origEl).carousel({
				dots: true,
				arrows: true
			});
		};


	ibmVp.fireVideoEvent = function (data) {
		var metricsData,
			playerState = "n/a",
			ibmCoremetricsState = 0,
			currentTime = Math.floor(data.currentTime),
			duration = Math.floor(data.duration),
			percentWatched = Math.floor((currentTime / duration) * 100);

		switch (data.playerState) {
			case 0: playerState = "ended";
				
				break;
			
			case 1: playerState = "played";
				
				break;
			
			case 2: playerState = "paused";
				
				break;
			
			case 99: playerState = "error";
				break;

			default: 
		}

		if (currentTime === 0) {
			currentTime = "start";
			percentWatched = "0";
		}

		if (currentTime >= duration || data.playerState === 0) {
			currentTime = "end";
			percentWatched = "100";
		}
		
		// Add switch for Coremertics params.
		// "0"=Launch; "1"=Pause; "2"=Play;"3"=Completion
		switch (data.playerState) {
			case 0: 

				if (currentTime === "start") {
					ibmCoremetricsState = 0;
				}
				else {
					ibmCoremetricsState = 3;
				}
				
				break;
			
			case 1: 

				ibmCoremetricsState = 2;

				break;
			
			case 2: 

				ibmCoremetricsState = 1;
				
				break;
			
			default: 
		}

		metricsData = {
			ibmEV: "video player - " + data.playerType,
			ibmEvAction: playerState,
			ibmEvName: data.title,
			ibmEvModule: currentTime,
			ibmEvGroup: duration,
			ibmEvSection: percentWatched + "%",
			ibmEvLinkTitle: "n/a",
			ibmEvFileSize: "n/a",
			ibmEvTarget: "n/a",
			ibmEvVidStatus: ibmCoremetricsState,
			ibmEvVidTimeStamp: currentTime,
			ibmEvVidLength: duration
		};

		if (data.customMetricsData) {
			$.extend(true, metricsData, data.customMetricsData);
		}

		// If went to the end of the video, and fired "pause" event, don't fire pause event b/c it's really
		//   the end of the video, so just let "end" event fire and tag metrics.
		if (currentTime === "end" && data.playerState === 2) {
			return;
		}

		IBM.common.util.statshelper.fireEvent(metricsData);
	};



})(jQuery, IBMCore);;

/**

	Flowplayer video widget.
	Dependency: videoplayer.js

**/
(function($, IBM) {

	var me = IBM.namespace(IBM, 'common.widget.videoplayer.flowplayer');

	// This is the Flowplayer video widget object as instantiated by videoplayer.js - the video player factory.
	me.Player = function (settings) {
		console.log("Flowplayer player settings: ", settings);
		



		this.init = function () {


		};

		/**
			data-type=""  @string:  The type of video/hosting it is: youtube, kaltura, qumu, direct, ... etc...
			data-videoid=""  @string: The ID of the video
			data-videourl=""  @string: The URL of the video
			data-videoplaylistid=""  @string: The ID of the playlist
			data-socialsharing=""  @bool: Enable/disable "sharing"
			data-accountid=""  @string: Account/profile ID to get videos from (ala Youtube)
			data-init=""  @bool: Enable/disable auto-init of this widget
			data-captionfile=""  @string: URL of caption file to use
			data-image=""  @string: URL of image to use as placeholder
			data..... etc. You get the point.

			
		**/
	};


})(jQuery, IBMCore);
;

/**

	Kaltura video widget.
	Dependency: videoplayer.js

	Kaltura API/events:  http://www.kaltura.org/demos/kdp3/docs.html
	Reusing a player (just change loaded video, for playlist with thumbs):  http://player.kaltura.com/docs/changeMedia
		
**/
(function($, IBM) {

	var ibmKt = IBM.namespace(IBM, 'common.widget.videoplayer.kaltura'),
		api = {
			dev: {
				partnerId: 1511271,
				uiConfId: {
					title_sharing: 27801331
				}
			},
			prod: {
				partnerId: 1773841,
				uiConfId: {
					title_sharing: 27941801
				}
			},
			embedVideo: {
				dynamic: "https://cdnapisec.kaltura.com/p/{partnerId}/sp/{partnerId}00/embedIframeJs/uiconf_id/{uiConfId}/partner_id/{partnerId}"
			},	
			images: {
				video: "https://cfvod.kaltura.com/p/{partnerId}/sp/{partnerId}00/thumbnail/entry_id/{videoId}/version/100011/acv/191/width/{width}"
			}
		};

	// Flag so that multiple KT widgets on a page only load the API once for the entire page.
	ibmKt.apiStatus = "";

	/**
		Creates the API URL using the object data.

		@method createApiUrl
		@private
		@param data {Object} Object with data values to populate API template varaibles.
		@return {String} The API URL to call.
	**/
	function createApiUrl (data) {
		return data.url.replace(/\{partnerId\}/g, api.prod.partnerId)
			.replace(/\{uiConfId\}/g, getPlayerId())
			.replace(/\{videoId\}/g, data.videoId)
			.replace(/\{width\}/g, data.width)
			.replace(/\{height\}/g, data.height);
	}

	/**
		Returns the Kaltura player UID to use. 
		<br />There are different one for prod vs. dev KT environment. Manually set to dev if you need to test something 
		in Kaltura dev environment. Usually you don't need to.

		@method getPlayerId
		@private
		@return {String} The UID of the Kaltura player to use.
	**/
	function getPlayerId () {
		var id = api.prod.uiConfId.title_sharing;
		return id;
	}

	/**
		Loads the Kaltura IFRAME API for the player. Only runs once, based on empty api status/flag.

		@method loadApi
	**/
	ibmKt.loadApi = function () {
		if (ibmKt.apiStatus !== "") {
			return;
		}

		ibmKt.apiStatus = "loading";

		var apiUrl = createApiUrl({url: api.embedVideo.dynamic}),
			tag = document.createElement('script'),
			firstScriptTag = document.getElementsByTagName('script')[0];

		tag.src = apiUrl;
		firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
	};


	/**
		Player contructor object for the Kaltura video player. 
		<br />Dependency: videoplayer.js
		<br />Used by the video player factory in videoplayer.js file, which is used by the jQuery plug-in.
		<br />You can't use this directly. Use the standard $(xxxx).videoplayer() plug-in method to create a video player.

		@class IBMCore.common.widget.videoplayer.kaltura.Player
		@constructor
	**/
	ibmKt.Player = function (userSettings) {
		var me = this,
			ibmVp = IBM.common.widget.videoplayer,
			appliedPlayerVars = {},
			appliedSettings = {},
			defaults = {
				settings: {  // Make ALL LOWERCASE so they can be overridden by @data-attr (works in lowercase only).
					carouselcolumns: 6,
					customplaceholder: false,
					maxnumvideos: 20,
					overlayclasses: "ibm-common-overlay ibm-overlay-alt",
					overlayplayerwidth: 564,
					overlayplayersize: "medium", // "medium" is the preset for the above overlay params
					placeholderalttext: "",
					showimageplaybutton: true,
					showvideodescription: false,
					showvideoduration: true,
					showvideotitle: true,
					theatermode: false,
					titledisplaytype: "below",
					videodisplay: "inline",
					videoid: "",  // Single video or CSV for "manual" playlists.
					videoplaylistid: "",  // Single playlist ID.
					videoratio: "16/9",  // this is a string to make it easy for consistency.
					videotitleoverride: "",
					videotype: "kaltura"
				}
			},
			playerPlaceholderClass = "ibm-video-placeholder",
			playerVars = {
				dataPrefix: "playervar_",
				defaults: {  // These get mapped to true/false after merge.
					autoplay: 1,
					showinfo: 1
				}
			};

		// "userSettings" came in from videoplayer.js factory and include all element's @data-attrs and parent defaults.
		// Merge in the user's settings and overwrite any defaults and update appliedSettings.
		$.extend(true, appliedSettings, defaults.settings, userSettings);

		appliedSettings.id = appliedSettings.origEl.id || IBM.common.util.generateId();
		appliedSettings.playerContainerId = appliedSettings.id + "_playercontainer";
		appliedSettings.$origEl = $(appliedSettings.origEl);
		
		// Merge in the element's @data-playervars and overwrite any defaults and update appliedPlayerVars.
		// Keep the "forced" settings (don't let devs override these).
		$.extend(true, appliedPlayerVars, playerVars.defaults, getUserDefinedPlayerVars(), playerVars.force);

		convertSettingsToPlayerVars();

		// Make the vars and settings public to this object instace so they can be seen and used.
		// We use all local vars for these, so try not to change playervars or settings after this point else 
		//   the public values will be different.
		me.appliedPlayerVars = appliedPlayerVars;
		me.appliedSettings = appliedSettings;
		me.player = {status: "Kaltura player not created yet"};

		/**
			EVENTS functions (for metrics).
		************************************************************************************************************/

		/**
			Fires a metrics event when the video was played. Pass events to common metrics event. 
			<br />Uses Youtube player states:
			<br />0 = ended, 1 = played, 2 = paused, 3 = error.

			@method fireMetricsEvent
			@private
			@param playerState {Integer} The player state, using the same numbering syste Youtube uses.
		**/
		function fireMetricsEvent (playerState) {
			var eventData = {
					playerType: "kaltura",
					title: me.player.evaluate("{mediaProxy.entry.name}"),
					currentTime: me.player.evaluate("{video.player.currentTime}"),
					duration: me.player.evaluate("{mediaProxy.entry.duration}"),
					playerState: playerState
				};

			// Get any custom ibmevent tagging on the element to pass to the event fire.
			eventData.customMetricsData = IBM.common.util.statshelper.getCustomEventParams(appliedSettings.$origEl);

			ibmVp.fireVideoEvent(eventData);
		}

		/**
			Callback fired when the video is played.
			<br />Uses Youtube player states:
			<br />0 = ended, 1 = played, 2 = paused, 3 = error.

			@method onPlayerPlayed
			@private
		**/
		function onPlayerPlayed () {
			fireMetricsEvent(1);
		}

		/**
			Callback fired when the video is paused.
			<br />Uses Youtube player states:
			<br />0 = ended, 1 = played, 2 = paused, 3 = error.

			@method onPlayerPause
			@private
		**/
		function onPlayerPause () {
			fireMetricsEvent(2);
		}

		/**
			Callback fired when the video has ended.
			<br />Uses Youtube player states:
			<br />0 = ended, 1 = played, 2 = paused, 3 = error.

			@method onPlayerEnd
			@private
		**/
		function onPlayerEnd () {
			fireMetricsEvent(0);
		}

		/**
			WIDGET functions.
		************************************************************************************************************/

		/**
			Takes the @data-overlayplayersize and converts that preset to the proper width and classes needed for the 
			player and the overlay
			<br />Optional based on embed settings.

			@method setOverlayPresets
			@private
		**/
		function setOverlayPresets () {
			if (appliedSettings.overlayplayersize === "large") {
				appliedSettings.overlayplayerwidth = 745;
				appliedSettings.overlayclasses = "ibm-common-overlay ibm-overlay-alt-two";
			}
			else if (appliedSettings.overlayplayersize === "xlarge") {
				appliedSettings.overlayplayerwidth = 975;
				appliedSettings.overlayclasses = "ibm-common-overlay ibm-overlay-alt-three";
			}
			else {
				appliedSettings.overlayplayerwidth = defaults.settings.overlayplayerwidth;
				appliedSettings.overlayclasses = defaults.settings.overlayclasses;
			}
		}

		/**
			Adds the video description, name, and formatted time to the placeholder. 
			<br />Optional based on embed settings.

			@method addPlaceholderInfo
			@private
		**/
		function addPlaceholderInfo () {
			// Creates the title and descr and passes back to us to do what we want with it.
			getVideoInfo(appliedSettings.videoid, function(dataObj){
				var videoData = dataObj,
					infoHtml = "",
					durationHtml = "",
					videoTitle = appliedSettings.videotitleoverride !== "" ? appliedSettings.videotitleoverride : videoData.name,
					placeholderAlt = appliedSettings.placeholderalttext !== "" ? appliedSettings.placeholderalttext : videoTitle;

				if (!videoData) {
					return;
				}

				if (appliedSettings.showvideoduration) {
					durationHtml = '<div class="ibm-video-duration"><p class="ibm-padding-bottom-0">' + videoData.formattedTime + '</p></div>';
				}

				if (appliedSettings.showvideotitle) {
					infoHtml += '<div class="ibm-video-title ibm-bold"><p class="ibm-padding-bottom-0">' + videoTitle + '</p></div>';
				}

				if (appliedSettings.showvideodescription) {
					infoHtml += '<p class="ibm-padding-bottom-0">' + videoData.description + '</p>';
				}

				// If video title set to display overlay'd, put the info into info container, 
				//  else put under/after placeholder.
				if (appliedSettings.titledisplaytype === "overlay" && durationHtml !== "" && infoHtml !== "") {
					me.$trigger.append('<div class="ibm-video-info">' + durationHtml + infoHtml  + '</div>');
				}
				else {
					if (durationHtml !== "") {
						me.$trigger.append('<div class="ibm-video-info">' + durationHtml + '</div>');
					}
					
					$(" > div", appliedSettings.$origEl).after(infoHtml);
				}

				// Add the video title as the alt text.
				me.$trigger.children("img").attr("alt", placeholderAlt);
			});
		}

		/**
			Calculates a height for a given number using the default video apect ratio (16/9).
			@method calcHeight
			@private
			@param num {Integer} The number to use as a width to calculate the proper height for.
			@return {Integer} The number to use as a height for the given width.
		**/
		function calcHeight (num) {
			var ratioArr = appliedSettings.videoratio.split("/"),
				w = ratioArr[0],
				h = ratioArr[1];

			return num / (w/h);
		}

		/**
			Takes settings from defaults or data-attrs and converts appropriate ones to playerVars for use with KT embed API.

			@method convertSettingsToPlayerVars
			@private
		**/
		function convertSettingsToPlayerVars () {
			// Kaltura uses true/false where Youtube uses 0 and 1. Maps 0/1 to true/false for Kaltura.
			$.each(appliedPlayerVars, function(k,v){
				if (k === "autoplay" || k === "showinfo") {
					if (v === 0) {
						appliedPlayerVars[k] = false;
					}
					else if (v === 1) {
						appliedPlayerVars[k] = true;
					}
				}
			});

			// Convert combo setting "showinfo" to Kaltura's two settings.
			if (appliedPlayerVars.showinfo === true) {
				appliedPlayerVars.showtitle = true;
    			appliedPlayerVars.showshare = true;
			}
			else {
				appliedPlayerVars.showtitle = false;
				appliedPlayerVars.showshare = false;
			}
		}

		/**
			Embed the video. Builds and calls KT script which injects player into original element's child playercontainer.

			@method createInlinePlayer
			@private
			@param elementId {String} The ID where we're putting the placeholder.
			@param videoId {String} The video (ID) we're embedding the placeholder for.
		**/
		function createInlinePlayer (elementId, videoId) {
			embedVideo(elementId, videoId);  // Uses the DOM el, not the selector.
		}

		/**
			Take the video ID and get the image.
			<br />Create, bind, and replace origEl innerHTML with: a->img.
			<br />Onclick of the <a> we injected, embed the video player (and play it).
			
			@method createPlayerTrigger
			@private
			@param videoId {String} The video (ID) we're embedding the placeholder/trigger for.
		**/
		function createPlayerTrigger (videoId) {
			var useWidth = me.overlay ? appliedSettings.width : appliedSettings.$origEl.width(),
				//useHeight = calcHeight(useWidth),
				useClass = playerPlaceholderClass,
				imageUrl = createApiUrl({
					url: api.images.video,
					videoId: videoId,
					width: useWidth
					//height: useHeight
				}),
				autoPlaceholder = $('<a href="#"></a>').html('<img src="' + imageUrl + '" width="100%" height="100%" alt="" />');

			//me.$trigger = $('<a class="' + useClass + '" href="#"></a>').html('<img src="' + imageUrl + '" width="100%" height="100%" alt="" />').prepend('<span class="ibm-video-play"></span>');

			me.$trigger = appliedSettings.customplaceholder ? $("a", appliedSettings.$origEl) : autoPlaceholder;

			// Add the class to the trigger.
			me.$trigger.addClass(playerPlaceholderClass);

			if (appliedSettings.showimageplaybutton) {
				addPlaybutton(me.$trigger);
			}
		}


		function addPlaybutton ($triggerLink) {
			$("img", $triggerLink).before('<span class="ibm-play-link"></span>').parent();
		}

		/**
			Does the actual video player embed.

			@method embedVideo
			@private
			@param elementId {String} The ID where we're putting the placeholder.
			@param videoId {String} The video (ID) we're embedding the placeholder for.
		**/
		function embedVideo (elementId, videoId) {
			var useHeight = me.overlay ? calcHeight(appliedSettings.width) : calcHeight(appliedSettings.$origEl.width()),
				ktPlayerid = getPlayerId();
			
			// Set the height of the container to ensure proper sizing and placeholding (esp for overlays) because 
			//   the iframe doesn't include a height.
			$("#" + elementId).css("height", useHeight);

			// We just call kWidget here (KT API object) b/c we've already loaded the API,
			// We don't setup the widgets until the API is loaded so it's impossible to get here w/o kWidget existing.
			kWidget.embed({
				targetId: elementId,
				wid: "_" + api.prod.partnerId,
				uiconf_id: ktPlayerid,
				entry_id: videoId,
				flashvars: {
					autoPlay: appliedPlayerVars.autoplay,
					"titleLabel.plugin": appliedPlayerVars.showtitle,
					"share.plugin": appliedPlayerVars.showshare
				},
				params: {
					wmode: "transparent"
				},
				readyCallback: function (playerId) {
					me.player = $("#" + playerId).get(0);
					
					me.player.addJsListener("playerPaused", function(){
						onPlayerPause(me.player);
					});
					me.player.addJsListener("playerPlayed", function(){
						onPlayerPlayed(me.player);
					});
					me.player.addJsListener("playerPlayEnd", function(){
						onPlayerEnd(me.player);
					});
				}
			});
		}

		/**
			Takes user-defined playerVars from data-xxxxx naming convention and returns them to be merged into applied settings.

			@method getUserDefinedPlayerVars
			@private
			@return {Object} An object containing the settings to use for the video embed.
		**/
		function getUserDefinedPlayerVars () {
			return IBM.common.util.getDataAttributes(appliedSettings.$origEl, playerVars.dataPrefix);
		}

		/**
			Calls API to get video info and passes JSON to callback function.

			@method getVideoInfo
			@private
			@param videoId {String} The video (ID) we want to get info for
			@param cb {Function} The function to call and pass the returned data object to.
		**/
		function getVideoInfo (videoId, cb) {
			// Get the video info and return to sender.
			new kWidget.api({
					wid : "_" + api.prod.partnerId
				}).doRequest({
						service: "media",
						action: "get",
						entryId: videoId
					}, function(jsonObj){
						jsonObj.formattedTime = IBM.common.util.convertSecondsToHMS(jsonObj.duration);
						
						if (cb) {
							cb(jsonObj);
						}
					}
				);
		}


		/**
			This is a method of the "Player" constructor.
			<br />Called by videoplayer.js jQuery plugin after the factory returns a player object (an instance of this "Player" object).
			<br />Creates a player and injects it on the page.

			@method init
		**/
		me.init = init;
		function init () {
			if (typeof kWidget === "undefined") {
				IBM.common.util.queue.push(function(){
						return typeof kWidget !== "undefined";
					}, function(){
						ibmKt.apiStatus = "ready";
						setupPlayerWidget();
					});

				ibmKt.loadApi();
			}
			else {
				setupPlayerWidget();
			}
		}

		/**
			This is a method of the "Player" constructor.
			<br />Called onclick of the user's link, or the auto-generated image that serves as the overlay trigger. 
			<br />Public method to use to programatically open and play the associated video. Or you can just do: $("myTrigger a").click();

			@method showOverlayAndPlay
		**/
		me.showOverlayAndPlay = showOverlayAndPlay;
		function showOverlayAndPlay () {
			// Open the overlay for this player object instance.
			me.overlay.show();

			// If the overlay still has our TMP DIV, it means we haven't embedded the player yet, so embed it,
			// Else if there's no TMP DIV, it means the video is there, so just play it.
			// NOTE: HAVE to include "div" in the selector b/c YT copies the ID to the embedded iframe.
			if ($("#" + appliedSettings.playerContainerId + " > iframe").length === 0) {
				embedVideo(appliedSettings.playerContainerId, appliedSettings.videoid);
			}
			else {
				setTimeout(function(){
					me.player.sendNotification("play");
				}, 600);
			}
		}

		/**
			This is our KT player factory.
			<br />Called by init(). This is like our sub-factory. 
			<br />Based on the display type, it calls the proper functions to make the proper widget elements for that type.
			<br />This is ONLY called after KT API is loaded, so assume all kWidget APIs are available.

			@method setupPlayerWidget
			@private
		**/
		function setupPlayerWidget () {
			var playerType = appliedSettings.videodisplay;

			if (playerType.indexOf("carousel-") === 0) {
				playerType = "carousel";
			}

			switch (playerType) {
				case "inline": 
					// We inject an inline player inside the element that initiated the plug-in.

					// Create a video player trigger (placeholder image), used on both inline and overlayAndTrigger displays.
					createPlayerTrigger(appliedSettings.videoid);

					// Inject the placeholder INSIDE this element that's inside the orig container element.
					// The KT player gets injected inside this, that's why we need to give it an ID.
					$('<div id="' + appliedSettings.playerContainerId + '"></div>').appendTo(appliedSettings.$origEl.empty()).html(me.$trigger);

					// Add placeholder/trigger video info.
					addPlaceholderInfo();

					// Bind the trigger to REPLACE the original element (containers the trigger) with an embeded video player.
					me.$trigger.click(function (evt) {
						evt.preventDefault();
						createInlinePlayer(appliedSettings.playerContainerId, appliedSettings.videoid);

						// On resize, recalculate height and reset iframe@height value. Makes the player responsive and adjust height
						//  of iframe based on width of any container it's in, when the container changes width.
						$(window).resize(function(){
							var $playerContainer = $("#" + appliedSettings.playerContainerId),
								newHeightStyle = {height: calcHeight($playerContainer.width()) + "px"};

							$playerContainer.css(newHeightStyle).children("iframe").css(newHeightStyle);
						});
					});

					break;

				case "overlay": 
					// We make ONLY the overlay here.

					// Set the overlay and video embed width/heigt from the preset used.
					setOverlayPresets();

					// Get the video's info and append the duration of the video to the trigger link if they set the option.
					if (appliedSettings.showvideoduration) {
						getVideoInfo(appliedSettings.videoid, function(jsonObj){
							appliedSettings.$origEl.append(' <span class="ibm-item-note">(' + jsonObj.formattedTime + ')</span>');
						});
					}

					// Make overlay and attach to this object.
					me.overlay = ibmVp.createOverlay(appliedSettings);
					me.overlay.setHtml('<div id="' + appliedSettings.playerContainerId + '" style="margin:auto;width:' + appliedSettings.overlayplayerwidth + 'px;"></div>');

					// Bind the video to pause if the overlay is closed.
					me.overlay.subscribe("hide", "Videoplayer", function(){
						me.player.sendNotification("pause");
					});

					// If they explicitely said to show the play button on a custom trigger.
					// Add the play button span.
					if (userSettings.showimageplaybutton) {
						addPlaybutton(appliedSettings.$origEl);
					}

					// Change the width to the preset overlay player widget, instead of the width of the container on the page.
					appliedSettings.width = appliedSettings.overlayplayerwidth;

					// Bind the element (usually an <a> but can technically be anything) that was init via the plugin to open overlay.
					appliedSettings.$origEl.click(function (evt) {
						evt.preventDefault();
						showOverlayAndPlay();
					});

					break;

				case "overlayandtrigger":
					// We make both the overlay AND the trigger (image they click on to launch the overlay).

					// Set the overlay and video embed width/heigt from the preset used.
					setOverlayPresets();

					// Create a video player trigger (placeholder image), used on both inline and overlayAndTrigger displays.
					createPlayerTrigger(appliedSettings.videoid);

					// Inject the trigger INSIDE the element that init'd the plug-in.
					$('<div></div>').appendTo(appliedSettings.$origEl.empty()).html(me.$trigger);

					// Add placeholder/trigger video info.
					addPlaceholderInfo();

					// Make overlay and attach to this object.
					me.overlay = ibmVp.createOverlay(appliedSettings);
					me.overlay.setHtml('<div id="' + appliedSettings.playerContainerId + '"></div>');

					// Bind the video to pause if the overlay is closed.
					me.overlay.subscribe("hide", "Videoplayer", function(){
						me.player.sendNotification("pause");
					});


					// Change the width to the preset overlay player widget, instead of the width of the container on the page.
					// NOTE: This HAS to be after we create the trigger, else the trigger will use this width and automatically make a big play button.
					appliedSettings.width = appliedSettings.overlayplayerwidth;

					// Bind trigger -> open overlay and play.. dupe what overlay above does just on a different element.
					me.$trigger.click(function (evt) {
						evt.preventDefault();
						showOverlayAndPlay();
					});

					break;

				case "carousel":
					// This creates a div element in a carousel for each video ID.
					// Used for both types of carouse. The only differnece is the videodisplay, and it is 
					//   determined using the passed appliedSettings in the ibmVp.createVideoCarousel function.
					// Then it inits the videoplayer plug-in on each. 
					// Then it inits the carousel.

					// It's just as if the dev custom coded the elements themselves, then say "displaytype=overlaywithtrigger".
					if (appliedSettings.videoplaylistid !== "") {
						console.log("Video playlist for Kaltura aren't setup yet.");
						/**
						// Get video info from videoinfo API using CSV of IDs.
						$.getJSON(api.playlistVideos.replace("{playlistId}", appliedSettings.videoplaylistid).replace("{maxResults}", appliedSettings.maxnumvideos)).done(function (jsonObj) {
							var videoIds = "";

							$.each(jsonObj.items, function(){
								videoIds += "," + this.contentDetails.videoId;
							});

							videoIds = videoIds.substring(1);

							// Take CSV of video IDs and generate placeholder divs in a carousel, then init both.
							ibmVp.createVideoCarousel(videoIds, appliedSettings);
						});
						**/
					}
					else if (appliedSettings.videoid.indexOf(",") > -1) {
						// Take CSV of video IDs and generate placeholder divs in a carousel, then init both.
						ibmVp.createVideoCarousel(appliedSettings.videoid, appliedSettings);
					}

					break;

				default: 
					console.info("Video player display type unknown: ", appliedSettings.$origEl);
			}
		}

		// Map common player actions to an abstracted API for cross-player ease of use.
		// Safety check to make sure the lower level function is there before calling it.
		me.playVideo = function () {
			if (me.player.sendNotification) {
				me.player.sendNotification("doPlay");
			}
		};

		me.playVideoAt = function (timesec) {
			if (me.player.sendNotification) {
				me.player.sendNotification("doSeek", timesec);
			}
		};

		me.pauseVideo = function () {
			if (me.player.sendNotification) {
				me.player.sendNotification("doPause");
			}
		};

		me.stopVideo = function () {
			if (me.player.sendNotification) {
				me.player.sendNotification("doStop");
			}
		};

	};


})(jQuery, IBMCore);
;

/**

	Qumu video widget.
	Dependency: videoplayer.js

**/
(function($, IBM) {

	var me = IBM.namespace(IBM, 'common.widget.videoplayer.qumu');

	// This is the Qumu video widget object as instantiated by videoplayer.js - the video player factory.
	me.Player = function (settings) {
		console.log("Qumuplayer player settings: ", settings);


		this.init = function () {


		};

		/**
			data-type=""  @string:  The type of video/hosting it is: youtube, kaltura, qumu, direct, ... etc...
			data-videoid=""  @string: The ID of the video
			data-videourl=""  @string: The URL of the video
			data-videoplaylistid=""  @string: The ID of the playlist
			data-socialsharing=""  @bool: Enable/disable "sharing"
			data-accountid=""  @string: Account/profile ID to get videos from (ala Youtube)
			data-init=""  @bool: Enable/disable auto-init of this widget
			data-captionfile=""  @string: URL of caption file to use
			data-image=""  @string: URL of image to use as placeholder
			data..... etc. You get the point.

			
		**/
	};


})(jQuery, IBMCore);
;

/**
	
	Youtube video player widget subclass.
	
	Dependency: videoplayer.js
	
	Youtube API documentation URLs: 
		IFRAME api reference: 
			https://developers.google.com/youtube/iframe_api_reference
		
		PlayerVars parameters: 
			https://developers.google.com/youtube/player_parameters#Parameters
		
		JS API (used to "externally" control a video player): 
			https://developers.google.com/youtube/js_api_reference
		
		Data API v2 (DEPRECATED, what v17 used): 
			https://gdata.youtube.com/feeds/api/videos/<videoID>?v=2&alt=json&callback=someCallbackName
		
		Data API v3 (need to use key):  
			https://developers.google.com/youtube/v3/
		
		Get a video's image/thumb: 
			http://i.ytimg.com/vi/<videoID>/hqdefault.jpg  or "maxresdefault.jpg"
		
		Get info (title, descr, duration) about a video (accepts CSV list of videoIDs): 
			https://www.googleapis.com/youtube/v3/videos?part=contentDetails%2C+snippet&id=<videoid>&key=<apikey>
		
		Get list of videos from a playlist ID:
			https://www.googleapis.com/youtube/v3/playlistItems?part=contentDetails&maxResults=<maxNum>&playlistId=<playlistid>&key=<apikey>

	API NOTE: 
		The API key is owned by Michael Santelia. Keys to use can be generated and daily usage limits can be checked from 
		 the Google developer console:

		https://console.developers.google.com/project

		The API limit is 50 MILLION units per 24 hours. Each video request, depending on data requested is ~30 units worth.
		If there are issues or we hit the limit, contact Michael Santelia to check the quota. 
		We can always create multiple keys and randomize which one is used to spread out the usage.

		
**/
/**

	Process flow:
		For each DOM element that has data-widget=video and is youtube, one of these object is created 
		  and attached to it via: $EL.data("widget").player
		  If there is an overlay object it's at: $EL.data().widget.overlay and the trigger is at: $EL.data.widget.trigger

		After the new object is created, .init() is run. Init loads the YT api if it doesn't exist already (glob var), 
		   and then creates the video players for inline and overlay players.
		Each video player creates a new YT player object, which injects a YT iframe and replaces the $EL that was tagged for a video widget and the rest is history.
		If the player is in an overlay, we do an extra step (before) and create an overlay, inject it, then embed the YT Player in the overlay.

**/
(function($, IBM) {

	var ibmYt = IBM.namespace(IBM, 'common.widget.videoplayer.youtube');
	
	// Flag so that multiple YT widgets on a page only load the API once for the entire page.
	ibmYt.apiStatus = "";

	/**
		Take Youtube video duration string and format it to standard HH:MM:SS time stamp.

		@method formatVideoDuration
		@private
		@param isoFormatedDuration {String} The video duration value from the Kaltura API.
		@return {String} The formatted duration in standard formatting: HH:MM:SS.
	**/
	function formatVideoDuration (isoFormatedDuration) {
		var array = isoFormatedDuration.match(/(\d+)(?=[MHS])/ig) || [],
			formatted = array.map(function (item) {
		    	if (item.length < 2) {
		    		return '0' + item;
		    	}
		    	return item;
			}).join(':');

		if (formatted.indexOf(":") === -1) {
			formatted = "00:" + formatted;
		}

		return formatted;
	}

	/**
		Loads the Youtube IFRAME API. Only runs once, based on empty api status/flag.

		@method loadApi
	**/
	ibmYt.loadApi = function () {
		if (ibmYt.apiStatus !== "") {
			return;
		}

		//console.log("Requesting YT iframe API");

		ibmYt.apiStatus = "loading";

		var tag = document.createElement('script'),
			firstScriptTag = document.getElementsByTagName('script')[0];
		tag.src = "https://www.youtube.com/iframe_api";
		firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
	};


	/**
		Player contructor object for the Youtube video player. 
		<br />Dependency: videoplayer.js
		<br />Used by the video player factory in videoplayer.js file, which is used by the jQuery plug-in.
		<br />You can't use this directly. Use the standard $(xxxx).videoplayer() plug-in method to create a video player.

		@class IBMCore.common.widget.videoplayer.youtube.Player
		@constructor
	**/
	ibmYt.Player = function (userSettings) {
		var me = this,
			ibmVp = IBM.common.widget.videoplayer,
			ytKey = "AIzaSyBTFvNiIb-zSVRn1_awMe7rldBa8zhjXwA",
			api = {
				images: {
					video: {
						thumbnail: "//i.ytimg.com/vi/{videoId}/default.jpg",
						medium: "//i.ytimg.com/vi/{videoId}/hqdefault.jpg",
						large: "//i.ytimg.com/vi/{videoId}/maxresdefault.jpg"
					}
				},
				playlistVideos: "https://www.googleapis.com/youtube/v3/playlistItems?part=contentDetails&maxResults={maxResults}&playlistId={playlistId}&key=" + ytKey,
				videoInfo: "https://www.googleapis.com/youtube/v3/videos?part=contentDetails,snippet&id={videoId}&key=" + ytKey,
				videoDuration: "https://www.googleapis.com/youtube/v3/videos?part=contentDetails,snippet&id={videoId}&key=" + ytKey
			},
			appliedPlayerVars = {},
			appliedSettings = {},
			defaults = {
				events: {
					onStateChange: onPlayerStateChange,
					onError: onPlayerError
				},
				settings: {  // Make ALL LOWERCASE so they can be overridden by @data-attr (works in lowercase only).
					carouselcolumns: 6,
					customplaceholder: false,
					imagesize: "large",
					maxnumvideos: 20,
					overlayclasses: "ibm-common-overlay ibm-overlay-alt",
					overlayplayerwidth: 564,
					overlayplayersize: "medium", // "medium" is the preset for the above overlay params
					placeholderalttext: "",
					showimageplaybutton: true,
					showvideodescription: false,
					showvideoduration: true,
					showvideotitle: true,
					theatermode: false,
					titledisplaytype: "below",
					videodisplay: "inline",
					videoid: "",  // Single video or CSV for "manual" playlists.
					videoplaylistid: "",  // Single playlist ID.
					videoratio: "16/9",  // this is a string to make it easy for consistency.
					videotitleoverride: "",
					videotype: "youtube"
				}
			},
			playerPlaceholderClass = "ibm-video-placeholder",
			playerVars = {
				dataPrefix: "playervar_",
				defaults: {
					//autohide: 1,
					autoplay: 1,
					hl: IBM.common.meta.page.pageInfo.language.toLowerCase(),
					iv_load_policy: 3,
					listType: "playlist",
					origin: document.location.protocol + "//" + document.location.host,
					rel: 0,
					showinfo: 1
				},
				force: {
					controls: 1,
					modestbranding: 0,
					theme: "dark"
				}
			};

		// "userSettings" came in from videoplayer.js factory and include all element's @data-attrs and parent defaults.
		// Merge in the user's settings and overwrite any defaults and update appliedSettings.
		$.extend(true, appliedSettings, defaults.settings, userSettings);

		appliedSettings.id = appliedSettings.origEl.id || IBM.common.util.generateId();
		appliedSettings.$origEl = $(appliedSettings.origEl);

		// Merge in the element's @data-playervars and overwrite any defaults and update appliedPlayerVars.
		// Keep the "forced" settings (don't let devs override these).
		$.extend(true, appliedPlayerVars, playerVars.defaults, getUserDefinedPlayerVars(), playerVars.force);


		// Make the vars and settings public to this object instace so they can be seen and used.
		// We use all local vars for these, so try not to change playervars or settings after this point else 
		//   the public values will be different.
		me.appliedPlayerVars = appliedPlayerVars;
		me.appliedSettings = appliedSettings;

		// If they specified a playlist, make sure to add it to the player vars also so the list option
		//  shows in the top left corner.
		if (me.appliedSettings.videoplaylistid !== "") {
			me.appliedPlayerVars.list = me.appliedSettings.videoplaylistid;
		}
		
		me.player = {status: "YT.player not created yet"};

		/**
			EVENTS functions (for metrics).
		************************************************************************************************************/

		/**
			Fires a metrics event when this video player state changes (hits play, pause, ended, etc).
			<br />Uses Youtube player states:
			<br />0 = ended, 1 = played, 2 = paused, 3 = error.

			@method onPlayerStateChange
			@private
			@param event {Object} The player state change event object.
		**/
		function onPlayerStateChange (event) {
			var eventData = {
					playerType: "youtube",
					title: event.target.getVideoData().title,
					currentTime: event.target.getCurrentTime(),
					duration: event.target.getDuration(),
					playerState: event.data
				};

			// Get any custom ibmevent tagging on the element to pass to the event fire.
			eventData.customMetricsData = IBM.common.util.statshelper.getCustomEventParams(appliedSettings.$origEl);

			ibmVp.fireVideoEvent(eventData);
		}

		/**
			Fires a metrics event when the video player throws an error (invalid param, video 404, not allowed to be embedded, etc).

			@method onPlayerError
			@private
			@param event {Object} The player state change event object.
		**/
		function onPlayerError (event) {
			var eventData = {
					title: event.target.getVideoData().title,
					currentTime: "0",
					duration: event.target.getDuration(),
					playerState: 99  // Our error code
				};

			// Get any custom ibmevent tagging on the element to pass to the event fire.
			eventData.customMetricsData = IBM.common.util.statshelper.getCustomEventParams(appliedSettings.$origEl);

			ibmVp.fireVideoEvent(eventData);
		}


		/**
			WIDGET functions.
		************************************************************************************************************/


		/**
			player and the overlay
			Takes the @data-overlayplayersize and converts that preset to the proper width and classes needed for the 
			<br />Optional based on embed settings.

			@method setOverlayPresets
			@private
		**/
		function setOverlayPresets () {
			if (appliedSettings.overlayplayersize === "large") {
				appliedSettings.overlayplayerwidth = 745;
				appliedSettings.overlayclasses = "ibm-common-overlay ibm-overlay-alt-two";
			}
			else if (appliedSettings.overlayplayersize === "xlarge") {
				appliedSettings.overlayplayerwidth = 975;
				appliedSettings.overlayclasses = "ibm-common-overlay ibm-overlay-alt-three";
			}
			else {
				appliedSettings.overlayplayerwidth = defaults.settings.overlayplayerwidth;
				appliedSettings.overlayclasses = defaults.settings.overlayclasses;
			}
		}

		/**
			Adds the video description, name, and formatted time to the placeholder. 
			<br />Optional based on embed settings.

			@method addPlaceholderInfo
			@private
		**/
		function addPlaceholderInfo () {
			// Creates the title and descr and passes back to us to do what we want with it.
			getVideoInfo(appliedSettings.videoid, function(dataObj){
				if (!dataObj.items[0]) {
					return;
				}

				var infoHtml = "",
					durationHtml = "",
					videoTitle = appliedSettings.videotitleoverride !== "" ? appliedSettings.videotitleoverride : dataObj.items[0].snippet.title,
					placeholderAlt = appliedSettings.placeholderalttext !== "" ? appliedSettings.placeholderalttext : videoTitle;

				if (appliedSettings.showvideoduration) {
					durationHtml = '<div class="ibm-video-duration"><p class="ibm-padding-bottom-0">' + dataObj.formattedTime + '</p></div>';
				}

				if (appliedSettings.showvideotitle) {
					infoHtml += '<div class="ibm-video-title ibm-bold"><p class="ibm-padding-bottom-0">' + videoTitle + '</p></div>';
				}

				if (appliedSettings.showvideodescription) {
					infoHtml += '<p class="ibm-padding-bottom-0">' + dataObj.items[0].snippet.description + '</p>';
				}

				// If video title set to display overlay'd, put the info into info container, 
				//  else put under/after placeholder.
				if (appliedSettings.titledisplaytype === "overlay" && durationHtml !== "" && infoHtml !== "") {
					me.$trigger.append('<div class="ibm-video-info">' + durationHtml + infoHtml  + '</div>');
				}
				else {
					if (durationHtml !== "") {
						me.$trigger.append('<div class="ibm-video-info">' + durationHtml + '</div>');
					}
					
					$(" > div", appliedSettings.$origEl).after(infoHtml);
				}

				// Add the video title as the alt text.
				me.$trigger.children("img").attr("alt", placeholderAlt);
			});
		}

		/**
			Calculates a height for a given number using the default video apect ratio (16/9).
			@method calcHeight
			@private
			@param num {Integer} The number to use as a width to calculate the proper height for.
			@return {Integer} The number to use as a height for the given width.
		**/
		function calcHeight (num) {
			var ratioArr = appliedSettings.videoratio.split("/"),
				w = ratioArr[0],
				h = ratioArr[1];

			return num / (w/h);
		}

		/**
			Wrap the original element in a div since we REPLACE it with the youtube player and attach the player widget object to it.
			<br />Then embed the video, replacing the original element (that the plugin was called on).

			@method createInlinePlayer
			@private
			@param $el {jQuery DOM selector} The element where we're putting the placeholder.
			@param videoId {String} The video (ID) we're embedding the placeholder for.
		**/
		function createInlinePlayer ($el, videoId) {
			//appliedPlayerVars.autoplay = 1;
			embedVideo($el, videoId);  // Uses the DOM el, not the selector.
		}

		/**
			Take the video ID and get the image.
			<br />Create, bind, and replace origEl innerHTML with: a->img.
			<br />Onclick of the <a> we injected, embed the video player (and play it).
			
			@method createPlayerTrigger
			@private
			@param videoId {String} The video (ID) we're embedding the placeholder/trigger for.
		**/
		function createPlayerTrigger (videoId) {
			var useImageSize = api.images.video[appliedSettings.imagesize] || api.images.video.large,
				autoPlaceholder = $('<a href="#"></a>').html('<img src="' + useImageSize.replace('{videoId}', videoId) + '" width="100%" height="100%" alt="" />');

			//me.$trigger = $('<a class="' + useClass + '" href="#"></a>').html('<img src="' + api.images.video.large.replace('{videoId}', videoId) + '" width="100%" height="100%" alt="" />').prepend('<span class="ibm-video-play"></span>');
			
			// If they are using a custom placeholder, set the trigger to their <a>.
			// Otherwise, use the auto placeholder.
			me.$trigger = appliedSettings.customplaceholder ? $("a", appliedSettings.$origEl) : autoPlaceholder;

			// Add the class to the trigger.
			me.$trigger.addClass(playerPlaceholderClass);

			if (appliedSettings.showimageplaybutton) {
				addPlaybutton(me.$trigger);
			}
		}

		
		function addPlaybutton ($triggerLink) {
			$("img", $triggerLink).before('<span class="ibm-play-link"></span>').parent();
		}

		/**
			Does the actual video player embed.

			@method embedVideo
			@private
			@param $ell {jQuery DOM selector} The element where we're putting the placeholder.
			@param videoId {String} The video (ID) we're embedding the placeholder for.
		**/
		function embedVideo ($el, videoId) {
			var useHeight = me.overlay ? calcHeight(appliedSettings.width) : calcHeight(appliedSettings.$origEl.width()) ;
			
			YT.ready(function(){
				var player = new YT.Player($el[0], {
					videoId: videoId,
					width: appliedSettings.theatermode ? appliedSettings.width : "100%",
					height: useHeight,
					playerVars: appliedPlayerVars,
					events: defaults.events
				});
				
				me.player = player;
			});
		}

		/**
			Takes user-defined playerVars from data-xxxxx naming convention and returns them to be merged into applied settings.

			@method getUserDefinedPlayerVars
			@private
			@return {Object} An object containing the settings to use for the video embed.
		**/
		function getUserDefinedPlayerVars () {
			return IBM.common.util.getDataAttributes(appliedSettings.$origEl, playerVars.dataPrefix);
		}

		/**
			Calls API to get video info and passes JSON to callback function.

			@method getVideoInfo
			@private
			@param videoId {String} The video (ID) we want to get info for
			@param cb {Function} The function to call and pass the returned data object to.
		**/
		function getVideoInfo (videoId, cb) {
			// Get the duration and inject it into the placeholder we just injected.
			$.getJSON(api.videoInfo.replace('{videoId}', videoId)).done(function (jsonObj) {
				if (jsonObj.items.length > 0) {
					jsonObj.formattedTime = formatVideoDuration(jsonObj.items[0].contentDetails.duration);
				}

				if (cb) {
					cb(jsonObj);
				}
			});
		}

		/**
			Called by videoplayer.js jQuery plugin after the factory returns a player object (an instance of this "Player" object).
			<br />If YT API doesn't exist on the page already; include it, wait for it to be available, then create this player widget.
			<br />Else if we've already included the API, create this player widget.

			@method init
		**/
		me.init = init;
		function init () {
			if (typeof YT === "undefined") {
				IBM.common.util.queue.push(function(){
						return typeof YT !== "undefined";
					}, function(){
						ibmYt.apiStatus = "ready";
						setupPlayerWidget();
					});

				ibmYt.loadApi();
			}
			else {
				setupPlayerWidget();
			}
		}

		/**
			Called onclick of the user's link, or the auto-generated image that serves as the overlay trigger. 
			<br />Public method to use to programatically open and play the associated video. Or you can just do: $("myTrigger a").click();

			@method showOverlayAndPlay
		**/
		me.showOverlayAndPlay = showOverlayAndPlay;
		function showOverlayAndPlay () {
			// Open the overlay for this player object instance.
			me.overlay.show();

			// If the overlay still has our TMP DIV, it means we haven't embedded the player yet, so embed it,
			// Else if there's no TMP DIV, it means the video is there, so just play it.
			// NOTE: HAVE to include "div" in the selector b/c YT copies the ID to the embedded iframe.
			if ($("div#" + appliedSettings.id + "-tmpcon")[0]) {
				//appliedPlayerVars.autoplay = 1;
				embedVideo($("div#" + appliedSettings.id + "-tmpcon"), appliedSettings.videoid);
			}
			else {
				setTimeout(function(){
					me.player.playVideo();
				}, 600);
			}
		}

		/**
			This is our YT player factory.
			<br />Called by init(). This is like our sub-factory. 
			<br />Based on the display type, it calls the proper functions to make the proper widget elements for that type.
			<br />This is ONLY called after KT API is loaded, so assume all kWidget APIs are available.

			@method setupPlayerWidget
			@private
		**/
		function setupPlayerWidget () {
			var playerType = appliedSettings.videodisplay;

			if (playerType.indexOf("carousel-") === 0) {
				playerType = "carousel";
			}

			appliedSettings.$origEl.addClass("ibm-video-player-con");

			switch (playerType) {
				case "inline": 
					// We inject an inline player inside the element that initiated the plug-in.

					// Create a video player trigger (placeholder image), used on both inline and overlayAndTrigger displays.
					createPlayerTrigger(appliedSettings.videoid);

					// Inject the placeholder INSIDE this element that's inside the orig container element. 
					// The YT player object REPLACES this. 
					$('<div></div>').appendTo(appliedSettings.$origEl.empty()).html(me.$trigger);

					// Add placeholder/trigger video info.
					addPlaceholderInfo();

					// Bind the trigger to REPLACE the original element (containers the trigger) with an embeded video player.
					me.$trigger.click(function (evt) {
						evt.preventDefault();
						createInlinePlayer($(" > div", appliedSettings.$origEl), appliedSettings.videoid);

						// On resize, recalculate height and reset iframe@height value. Makes the player responsive and adjust height
						//  of iframe based on width of any container it's in, when the container changes width.
						$(window).resize(function(){
							var $playerIframe = $(me.player.getIframe()),
								newHeight = calcHeight($playerIframe.parent().width());

							$playerIframe.attr("height", newHeight + "px");
						});
					});

					break;

				case "overlay": 
					// We make ONLY the overlay here.
					// The trigger is the element they put the widget on. It has to be on the link.

					// Set the overlay and video embed width/heigt from the preset used.
					setOverlayPresets();

					// Get the video's info and append the duration of the video to the trigger link if they set the option.
					if (appliedSettings.showvideoduration) {
						getVideoInfo(appliedSettings.videoid, function(jsonObj){
							appliedSettings.$origEl.append(' <span class="ibm-item-note">(' + jsonObj.formattedTime + ')</span>');
						});
					}

					// Make overlay and attach to this object.
					me.overlay = ibmVp.createOverlay(appliedSettings);
					me.overlay.setHtml('<div id="' + appliedSettings.id + '-tmpcon"></div>');

					// Bind the video to pause if the overlay is closed.
					me.overlay.subscribe("hide", "Videoplayer", function(){
						me.player.pauseVideo();
					});

					// If they explicitely said to show the play button on their implied custom trigger (use userSettings),
					//  add the play button class and span.
					if (userSettings.showimageplaybutton) {
						appliedSettings.$origEl.addClass(playerPlaceholderClass);
						addPlaybutton(appliedSettings.$origEl);
					}

					// Change the width to the preset overlay player widget, instead of the width of the container on the page.
					appliedSettings.width = appliedSettings.overlayplayerwidth;

					// Bind the element (usually an <a> but can technically be anything) that was init via the plugin to open overlay.
					appliedSettings.$origEl.click(function (evt) {
						evt.preventDefault();
						showOverlayAndPlay();
					});

					break;

				case "overlayandtrigger":
					// We make both the overlay AND the trigger (image they click on to launch the overlay).

					// Set the overlay and video embed width/heigt from the preset used.
					setOverlayPresets();

					// Create a video player trigger (placeholder image), used on both inline and overlayAndTrigger displays.
					createPlayerTrigger(appliedSettings.videoid);

					// Inject the trigger INSIDE the element that init'd the plug-in.
					$('<div></div>').appendTo(appliedSettings.$origEl.empty()).html(me.$trigger);

					// Add placeholder/trigger video info.
					addPlaceholderInfo();

					// Make overlay and attach to this object.
					me.overlay = ibmVp.createOverlay(appliedSettings);
					me.overlay.setHtml('<div id="' + appliedSettings.id + '-tmpcon"></div>');

					// Bind the video to pause if the overlay is closed.
					me.overlay.subscribe("hide", "Videoplayer", function(){
						me.player.pauseVideo();
					});

					// Change the width to the preset overlay player widget, instead of the width of the container on the page.
					// NOTE: This HAS to be after we create the trigger, else the trigger will use this width and automatically make a big play button.
					appliedSettings.width = appliedSettings.overlayplayerwidth;

					// Bind trigger -> open overlay and play.. dupe what overlay above does just on a different element.
					me.$trigger.click(function (evt) {
						evt.preventDefault();
						showOverlayAndPlay();
					});

					break;

				case "carousel":
					// This creates a div element in a carousel for each video ID.
					// Used for both types of carouse. The only differnece is the videodisplay, and it is 
					//   determined using the passed appliedSettings in the ibmVp.createVideoCarousel function.
					// Then it inits the videoplayer plug-in on each. 
					// Then it inits the carousel.

					// It's just as if the dev custom coded the elements themselves, then say "displaytype=overlaywithtrigger".
					if (appliedSettings.videoplaylistid !== "") {
						// Get video info from videoinfo API using CSV of IDs.
						$.getJSON(api.playlistVideos.replace("{playlistId}", appliedSettings.videoplaylistid).replace("{maxResults}", appliedSettings.maxnumvideos)).done(function (jsonObj) {
							var videoIds = "";

							$.each(jsonObj.items, function(){
								videoIds += "," + this.contentDetails.videoId;
							});

							videoIds = videoIds.substring(1);

							// Take CSV of video IDs and generate placeholder divs in a carousel, then init both.
							ibmVp.createVideoCarousel(videoIds, appliedSettings);
						});
					}
					else if (appliedSettings.videoid.indexOf(",") > -1) {
						// Take CSV of video IDs and generate placeholder divs in a carousel, then init both.
						ibmVp.createVideoCarousel(appliedSettings.videoid, appliedSettings);
					}

					break;

				default: 
					console.info("Video player display type unknown: ", appliedSettings.$origEl);
			}
		}

		// Map common player actions to an abstracted API for cross-player ease of use.
		// Safety check to make sure the lower level function is there before calling it.
		me.playVideo = function () {
			if (me.player.playVideo) {
				me.player.playVideo();
			}
		};

		me.playVideoAt = function (timesec) {
			if (me.player.playVideo) {
				me.player.seekTo(timesec);
				me.player.playVideo();
			}
		};

		me.pauseVideo = function () {
			if (me.player.pauseVideo) {
				me.player.pauseVideo();
			}
		};

		me.stopVideo = function () {
			if (me.player.stopVideo) {
				me.player.stopVideo();
			}
		};
	};


})(jQuery, IBMCore);
;

/**
	
	Intercept Surveys widget.
	
	<br />
	<br />An intercept pops up a small window inviting users to participate in a single- or multi-page survey, 
	<br />or to answer the one or two questions presented in the overlay (known as a "quick poll").
	<br />Intercepts can be used internally (w3) or externally (www), to target users around the world.
	
	<br />Documentation: http://tealeaf03.atl.dst.ibm.com/standards/UE_MT/feedback/surveys.htm.	
	
	<br />Usage:
	
	// Paste below configuration code to HTML page. 
	
	IBMCore.common.util.config.set({
		opinionlab: {
		  intercept: {
	         percent: 90,
	         start: "Apr 01 2015",
	         stop: "Apr 31 2015",
	         invitation: {
	            title: "Tell IBM what you think",
	            content: "Would you like to take 1 minute to test this survey?",
	            yes_label: "Yes",
	            no_label: "No Thanks"
	         },
	         survey: {
	            type: "asm",
	            id: "11320",
	            width: 535,
	            height: 430
	         }
	      }
	   }
	});
	
	
	@class IBMCore.common.widget.ccfintercept

**/


// JSlint config so it ignores all the consoles in this file.
/* global console */

(function($, IBM) {

    var me = IBM.namespace(IBM, "common.widget.opinionlabccfintercept"),
        defaults = {
            global_minimum_wait: 30,
            interceptDisp: "pageLoad",
            surveyDisp: "immediate",
            anon: "true",
            anonData: {
                userName: "",
                userEmail: "",
                emailInfoLoaded: true
            },
            percent: 25,
            start: "Jan 01 2015",
            stop: "Dec 31 2099",
            presentDelay: 3,
            invitation: {
                title: "Tell IBM what you think",
                content: "Would you please take 1 minute to take this survey?",
                yes_label: "Yes",
                no_label: "No thanks"
            },
            survey: {
                type: "asm",
                id: "11320",
                width: 533,
                height: 417,
                metaData: ""
            }
        },
        survey = null,
        invitation = null,
        invitationStatus = '',
        now = new Date(), // days fefore ANY intercept can be seen again
        settings = null,
        myEvents = IBM.common.util.eventCoordinator(me, 'opinionlabccfintercept', [
            "exceptionDataLoaded"
        ]),
        watermarkImage = '<div style="background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIkAAACJCAYAAAAYJBvJAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAALB1JREFUeNrsfQdcU+f6/wFCJoEACXvJEBAVFHChIlqtAmJV8NYusXW23uttq/56q7VaO7S3w3pbR3Fr1ap1VUVRQBGRDYqAAmGGEbIHYZP/+4Sk/5QCQQwV9Lyfz5EkJx4O5/2+z/N95muQiWH7MHy8qEOJjnZ0KNDBRUcZOtjoqEGHBB0t/kqlkoA/Jxwg6OChoxwdJeioRocMHa0AEPgiDhIcIBoJUqqWIDKNBNF8GQfJiwuQRrUEKetJguAgwSUIT5cE0QzDofwXE3x86G0YZqDEJ78/AAGCWowODjqkPQFkSIOE8v77XpaxsYsVa9b4VmIYtbWffwshOJhpeuHCbD6LZYqWEkE5gPfb4uPDQDNkpBw8EqRaDZDWngAyZEFiYG1NNAoOHgavPTZsGNe4YsXY8n4ChfHDD7MoY8c62f/2W1ghk2mF7D5jfU8iaenSYabvvz/VaP36CYUYZirXUvN/gzTsSlLZWhxEI0E6ervAkAMJdcuW0VYZGdEkLy9bCZfbAp8Fb9o0onXFCr/+AKV4zZrbrQpFG8PFhT7+zJnpjwYAKPL0dBH8tJs+3anM3d25FsPISj1KwycgqRozl6P2g/QqQYYsSCjz5o2CnxsnTcrb+vLLjzKuXlVNQEg/gdKenMyLi46+19zQ0G7l5kadeOZMiDZQYCLNU1KiqlkshrSf6qg1P19Wk5BQBa/dFy92Rvdo0gDSxNOTqTrv6+uSi2EWEv0aEtoSpB77s6OsTxJkSIIE1AzB0pKmmlwGg2YjFPKKN25M15zvD1Act2zxmrlnjz+JRjOC99pAabCyopmsWjWR6OBgrvznPwNBVaAladTTvZkhbiOfPNlOjABGROCyrqxcYXzs2EyxtzeTvX17nkrqvfYas87S0pKPYcTSVasyU778Mi9m+fKyJgQQPUqSrhIE+EeRFkntkwTRDKMVGDZ3yNBztNoVfn5M2rBhjJFTptAEKSl1fs7OLVaRkR41bHYT3cKCYOvvbxF36pTQrLFRQcewNgMdoGN8993LLS0typ2vv15SzeG0u44eTWXY2BAtXnrJIfP0aa4kOZkjMDAgHfroI64ZhjXbowdPxrC/rEDTmJiplPHjXelz5rjmZGXJXZYtG0FksWgUFxdz2zff9FLa2VEbFYoOcwcHqsLIiFiblFRvh64lycwUMTCsCREsmQ36adw5wfomqewuHOSJfofBYI/dmHz7bQBp+nRPxBtaizdsSBUJBMrguLg5fxLniFMs8/Iq/DIhYbi9uzvpp+joIoeEhDx/DBMZdzOhmkFGq90MEcrHd++Kv168uNwFw8SBy5bZzt682RPO17PZitjIyJRmgaAFXcTADT1kdEJG6uaaYisrE5uzZ+eaIW4Dquv0kiXZzUqlke877wwLDA011/6usK6udfe4cXfRH1FljYDXjCQIXLO3e+0nSdW2YiT9AcigVzdgntKiosaCiqE4OjI89++fKTAzMzs+Y8ad8txcOXznQVKS7MRXX3FH+/sbsezsjJrQBBXk5LShJWOMxHdvggSTxMXVwU/PoCBG0IIFph5orikXL+bDZ41yeUdRYWF7sUBAdsCwhiCEGXfEQUk9TCShvr4pecGCWwAsUF1RR46M7VAqDeJXrcr5JiQkK+nUKT5cE75rYWNj7IEsHiT7qaqFgCSengHSb5I6pNQNmI3GkZHeaJUR9v/735V2I0eawMN1DQuze3TtWn3mN9+UnPv++/rqiorWNz/7zCHknXdsjIyNDU9s21ZblZoq9kELFk1uo1E34hvIqEIma5Pl5ysUrq6mDC8v8zGzZ5tjzs40nw8+8CaamZF/XreOc+7bb3nOCDje6ECqoYnYiyqASaYpFM25V67wQFWZWVuTRoaHW9VnZvIYeXnV3Bs3ahNOnRKQnZxM7Dw8KCQGg5h26hSoHAWtc3IHmqT2W40ZDhaJoe3QAoAwtm6dSZ861e1+fLz0UUKC+EhUVA6XzW6EVbrwyBF/+/Hj6eMwrG7NDz/Yogkh1qFzXy9ZUp585Eg9mlQBAoiC0GV1gvlsmZPzOvgsHGNjF9H+97+pBT/+yC64fh0eLDZywQJHmpOTWWFysiTzwgXRaHT9QLQqrZBKMNABaPObNyOsjx8PZhgYNCdERt7RSJR5hw8HEsePt0JSShokEJS3JiWVaP4fMoVpYhW+9EpSy7Q8qU8lQQaVJLG4ePEVoqsrS+7mZpF/8WK9iYmJgVlo6DBDY2MjKw8Pk4rUVJEjm11Vdfkyhzlzpj2sUvTXE/lxcTUNBw8WJF++LP7lu+9EjeXlMmQf88YikMDK15YiQFIt9uwJl9XXN6f99hvf1tOTxhw1ylJOpVLi1qx5mHrpklDa2mq078MPa+L37+chIimaiPT6cKRiyL2oAgC4xa5d4UglmpCdnc1NZ81yLP3110r26dNV1jNnAoBJw8LC7LNu3BA6GhoqRu/dO9mISiXeOH5cVJOeLkLgkSA7uGWwkNRBBxKVt9HAwJCTlsZT2NmZ52dltQTt2DHq/u7dZWVJSTzH0FAHsomJke/cucyyzEwxs7iYW3TlSl2lQkH89bPPuBZo9TgivkARChsQKOSgYkYi1eA4dSrd+saNKCGa3Pr0dAlMMm39+hGkMWMcLn//fa1QLDYY+/LLjPtJSXIjGo1o5+tLlZ87VypJSqqlikRSBAzRGAQ0pGoUugBivHixV4e5uUnc3r11jqNG0U0RKKxmzrQrPX26Eg4ASkFmZtPNo0dFLIVCRjA2bnlUVNRxfscOLiLCIi80mWCF6UHFlKo5SE1/zNxBad3AAzaPiQlv4vEU8fPmJQuVSvLiu3enEalUAr+0tOHSwoWpJu7uNBDXILbBYohbuvSeaWpqFRLRRDgAIMMAJOhhoadlAJID1AJt374gkzlzfOD33Pnii4cG+/Y9cFu71tn2ww+DxFxuCwNJldzYWEH8r79KPzx8eNiDa9f4SStWZCJrSGCKHq4KVDrMZ+A1oLbgdfLBg1W/bNlSP9zfn7T6+HFvMrpfUDc3IyOT4XyhQEAB83kCmky41zwMM29CCxRZShIgw8QnJ63dSRCNitGE+zv0NVfPjJO0KpWGCOgGVGS1TDh7NgTdiDIhOjoFwMB0daWFnz07UVZS0nAxOjoDPgOgWEZGDq9CGHBFD3YSejhIVMuRedAOk0lQAwRGxcqVGeXx8SBysSkbN44EB1vWDz/UKvj8RgAIWBkp1641hC9frjJNH967pxAhixjuAUS/iQ6AwJBlZQnbGhtb4fWwqVOtrC0sOlhZWaXXoqPTNN5b+zVrfDoEgiaEpJopiN+AjwVMXsRz+Og9SJKnBYh2LEY73N+hz7l6ZuqmsaKiqSA7W2I9Z44ziGhbJJZz9+4tZycl8d3DwlS63GHmTJu8vXtLQfWIlUrSwfXra1jo4bigh4tmt9WoF2uj7O5dIX3mTCequTkRTSKrSi43KD1/vspp+nQbUGGBc+aYMZ2cyEBSf/nkk1p0TQla2VJqHy0NRUVFc15WlswuNNTJHFldXjNnWgBnYhUX1xVkZUkFSDL+snFjLQJFwwh0bVu1dQT3DL8DDsKTO856SxjSq4oZFOoGIp9IkZI4Eya4zjp0aCJJLaJ/j4y8R9dSM5rPWtUOLSSepUiCyHqbTG1VAFKDYmKikpixn31W9PD8eZ7fu++6NXd0GN05eVIoQaoNrXApUgVcZBXJevNXAIeibNwYYOTiwhTeuVNd8N//lkjc3KzCDh8er7nXu1FRtyz4fAlIPDmyXHpzwOlBxZRgfcgHGbIg6StQsm/dkl9ZvToPqZdaxEEUoAp0rXYwc8EBt97PL7dRqTRe8b//OY1GZBbOXdm6tbjowIHyZiRFQb2gla5A6ksGPpW+Ak/b03shIuJOO4NBnX/kSADc/+0DB6qFW7emIa4kB8BppIYezVwNSS3uQlI7BmqenglIwF8B0VyYyPrExIq8r74qFJqZmUUcPjxOGyjGFhakvOJiIxDZoNPB2tDFFWC1Q/gdeMHGsDA2s7SUY29p2b4oOXm6Joh3dtmyHGJcHBs4AgM9YFofYjzMpKTXDSkU40P//ncpWEeLP/nE1s7NjXwfkd47iPRajx9vZh8V5XZ03TrOODR5QWi1w7X1GKzrKkGqBoKkDgriCo4n+ttvT9BEc61CQpxnxMXNbhYK235bsiRLQ/oc3nrLvaO4WIyWbvVEtHp0ObQ0oyk/Xy7IyKgFQKzeudPe1tKyY7hAwO1obGyBIGDS77/Lb8XFtaMnb4D4TXNfSCph0iQWAASceXHnzjWJExI4sStWZMG54ZMnW9RimAkxLa2mdN26VD+kthzVFpeeAdI1YWhASOozBwmIbMry5QEgpjdNm1bwQXBwMUwcnPNZt24EPz1dfCk6Oj3l9On6899/L4DPwQJwU1sxvUkP6jffBJL27p0iYLFMH23cmK36v35+tFeTk0PGV1a+QWEyKWkXLghj3nuv3AZdD63yFqM+EsdmgUAlEazd3CiB06eTPcGPIhZXw9/RJJe3C9GfBqplvNpq6S3Go4dYTJW+PKmDTt2AX8Ty2LEF8Bp8Ff8ODHzkhR6qo4cH4fX4eJWu/zYkJMuJza4EH0IDIn3D0cPw0GEmduUKMHEFhw4VleXmNvq+957nMD8/Ewj6Pbh9W7Zn1apKNMF8NJn1yJpp6LMlg+6HERv7irmPjyW8L75xo9be05NKdXIyO7Z5Myfz8OGacKQGRndOHqZnCaIdixlwkvpMJUnj7dtC4B/wGnwV7+3d6+hiadnqXlxcCRMLVkgBm60ik/4YJoQVCY4yXX4E6ltv+YP/Y+/SpY9Lc3MbjKlUQoerq7VEKFT+GhGRvmv+/Lx1kyY9+nnVqnIkkYTo2jx3HZKp64B7KHjrrducBw9ggjAPZK4DQBAQ5WkXL0qQepEykcDRM0C6i8VI/04J8scC/ztUTIe9vWlzXp44bcmSDPf9+8nes2ZZQ46FZ0DANKqJiREBTezdU6cEILJBTFuglWLQR+kE3EaIiC7FwcHEFamXtKtXxRa2tpTpn346PDY8PNkyK6sYEV9DmGikZhptOv0VvUqmFqXSULBzZzFEZ+GewJ9hzeOJ08LDb8a/9JKnoKODIheL2yuysyEcIBuB1I9l/+MvfYnF1DwLCfK3qBtIGIJ8EM37x+fPV9xcu7Yw+Oef/UfOns1SEU2kCq7s2VN/edcuHqiCEPRAXDofkm6vLZp8Vk7OayRLS1VeRk5srGDPypWVP1dWjgGVtjMwMBVdrxqZuA1qr2yHQR8sI3id8dVX95v37MmHewGgwMxAljuaNRqaMSqY0OiXtiELSaExzQ30B5Aei7efhatiQD2u9B07QqT19c2lDx82sZycyExvb4bJiBGmcStW3Kd7e5taubvTCESioVAoxKquXKkGh5Z6UpS9maOU9et92v38LIWpqWIxgWDAmjzZTuVlffy4LWzVKkuGjQ0p8cQJQUFSkgwSiWzVEeHeJpE4f74dceVKX0NEfA2NjQ3tp0yxYTc0GMmysiCe0wb/H6QcSAxIOwSvL/AasLooOsD3FGZu9bNSMQMOEpAg5PXrA0mOjuZntmypOvH557xGsbh5ZEgIg4WAAQC5joBi6u1NB6A4DR9OYjg4GEvj4lTpfD2BBPwrkJNKHjfOmTZxohNp/ny3ksuXa+t5vA77MWMYjug6ZDqdkHr+vABc7cM6E4YkpjqirCBBLI4fX9hOo1GSDh6sVZLJRKSyjMGd3xUohmqOok43VBrqV8Vw1Y6y0i5m7jMtUtQ7SIAnmG3aNN2YyTSB9ywPD2rZ77/XUO7dKxMic9E1OJgFwBBKpR05n31WAJKFbmNDObJ1K7e9tlYO4rsnUsnYty8Uqae2Ux9/XGHt4UGBQKCUQKBk7tlTkXT4MLesrKzth2XLqopu3BC6dYb7+U6dyUe9PmTSe+95QRrB3ZMn689s384vPHWqymP6dHOQSN0BRY+P65nEYp4pSLRTDuMOHuR5TpxoChnsEPyquXy5yig5mcNpaDDgy+WE09u21SGuIJH9/nvZnevXZfz8fDla+VLQ7935GIBQkqdMcc26fFkolEgMgxYutIT8VqWxsbHL+PF0zpEjbGVuLnhlpYhICkchkKBrNVL64K8A1QWSyczOjnI3JqYGmch1DGdnI1ZgoBWcB6BkFxS0tLPZEsj9MNQvQAY0YWhQEVdNyiG8vnPwIOfEli3crvkVSZGRt6kCgbwc0RUk/w1HoskE1zgf/XfwRYAHFI7uVj7U0ULKIRBduB7kgxz66KOaH+7fH1Vx/77s17lz08H/oSl50JVYDBIPc3U1lV25Uieur+8Ynp0dRWUyKUB46+Liyh2Dg63rOJx2rlBImBQebgrm9c2IiNuQEM18ekumu+JtkCC1Wo6yDmyQDL35SaToYTdUVqqcSQGLFtl5+/sTzbOyyq9q5VfQ33prBDjK0GTypqLVCn4QiG+ARxWtfimYp9oAATIJua+GX389QcJg0CsTEjhkdfyFLxIZvrt7tyO8zr55UyZGQAMfC70Pmeeq8spjxxZYbt36kkNS0quSSZMc0jdtyoH7BB+O15tvDodc10wk4a59+22lStoolQZoqZuJVJRE7xJEu+xhUAFEL5IEJtIwKMih+uDBMnZ9vTHU0wIgYMUDQGhpaZym8ePtWVFRHhD8mogeBiQM6SKTQFIhxqPxop6cOzeVIBQ2BB89OsF+1Cgzzfeyrl4V7l61qhJJJR4yd2vBktF1z1C2aWBhQYeSB03W2/klSzL5bHaT93vvDReIxQbleXlNYyZPJo+ZMYMO3Gf32rWVlefPc8IwrHy4yhrWm5n7p7qYAPSdQaJl9AMSk337gmjqNEGYSKiprS8ubgk7e3YiAAUe/rXo6FRyWlp1PYaR++pqhwHhfnBqnfr881qxWIwJExJqQkNDMQMGg5TP5ZoYOziYpl+6JOkQiSDPVRqI1IAXsga0rwvmMuSgtCMVokr2AV4TFTUKyja/CgnJ5QiFxI3nzrlCNBfu9eySJVmy9HSB6bhxlnN37/alW1mR4DpxMTF1Z7dtq/VFEzsNScB+qpuuEuQv4f4A9b0PNpD0W90ABwGACMvK5LVoBYI7/KVDhybRkOUCYX5NSQFIEAAIZGf11dUO6gA8qSWZmQ13zp2TyxISqsJfe404ae/eyQ6zZtmK4+OrRUeO5I8SiSrQpFWBA65rrigAxPzChQjGuXPzylksSygAN1m9egIARKU+zMxoDiJR3fXIyLuae408csSf7uFBc5RK+ZVnzxazU1KEH02b9ggAgq4vHI0Os6dPWu7Wkxrw9AHBwQcSk7VrJ8LPra+8UqbBvabOxG3hQtuLkZGptw4cqAYVAxIEkcl2WIG6EnsarayovLg4VR3M6NmzmSP8/Y3BWjHLzeWovsRkmsL1kPgSIXDUoZvgD+smWGfo6WlmiFSKoq2NIJ83z4fDZJrnLF2a2IIkHpz/8PhxNzNLS0N3gYCbEhWVCECBBKfc4mJj2aNHDfXbtz+MffXVdNPS0lqkHqs1+SzG/c9JbdQiqX8q3g7Qr1n9bExgcI4R333XV0IkGkmQJQFOJOMFC1wlUinW2NSkBHP0+ObNVfbe3jQweV2QySjk8ZoLvvuuGKkCGWR+9eYk0wAEormPsrMl3JQUKcnX18x02DCzoFdfZRk6O9Ps33jDjcRi0S799BOvNjdXFS+xVxNdg268svKCAkXezZu8UpGIOOfTT4ebz5rlkPXTTxWPk5KE7mFhdpDn6jhzpnXB5ctcB4FAWIiId9KZM2JLNJlwv+qk5UZEqsFrq7r/p8hJ7dHM7Q4gW7ZsGTqSBEgpMzf3NYi/0MaOdbT7+OOg8gkT3BDjIhWuXZu6f9q0tIg1a6xUuZ2HD9fLudxGyA+5fuKE5EJMDORsNEOZgqeOnFTVjQQEqFzrDV5eDpAfWrZ9e15NXp7KWvJesMDJ1NubBUnLiYcPC5AV1GDWQ9aXqlQDqRnIKwFJQS4oUOV9mA8bZhJ89mywtKREocnAt3Fzo8BntUjK2PL5ollIdYHEgFRGsJKgwAtem/YvLtNdwlCxNkCsKyuHRLs3Qm8xErMdO2YZkslEqEuBlL2K/PwmDhLHs8PCnIzS07kB8AARuUMHtjkx0ccWEcBTn35aEXfokBjKGqHUUi1BOnrjNhCoa5BIOsBFS7CxofORYPF49Ih7LywsvsLNzWnEa685xv/yi0RcWqoAVztIEfMeQGI0bZq9sb29hfe1a3NpLBa59MKFst/eeisLclCBTM9FpBo4EwAFVCP70aPWLD7fFAFEAoFAXTGefkqQCqxLG8yhApBerRvI9KIvWjQGnFb/XbmyzsvNrX3BRx/Z+Lz8ssoL2cjnNz785JMMs6Ag6+FvvKFq1XDr1CnBqQ0bKhBAhAhAPKdeXOzaKkb7M8gr4Tx4IDEsK+O2FRTwORkZcjSRHdDkBQqcdCUtN02ZYmMXExMKRBre/xQdXSxFxNd53DgTqCF+2hzaJwRIfZdYjKSrBHF0cvrrBYaKCWz83/+Ot/jHP3xLcnIU0traprGhoRZdvwM9y3YHBibT3NzoPKWSyi0tbYEaWqhU81Bni/cqxjZv9pOyWEwjFxcWy82Npil90B5QZIUIZxpU3wPx1ZW03Ozjw3CKjV2kec8pKWn+NSoqw1MgqFNOmGCjycqHrHb21q056JpNmsju35HVjgDyp2cypEGiiIhwGfbjj7O0PxPV1bX+tGEDl1tR0fK/27dd4bP/8/PL8RYKq2lq8Q8qBjynuh44cIeq27flhRhmhuSwGVIx1B2Fhf7gUT24fbvIa+RIoxa5vPW3DRtK/dADR8Dj9cU/gb5gKHj99ZElRKJN2Pr1TgA8SGC+Exl5awJ6n5WY2GQxY4bz8Q0bKsdhWC1c17KPSU79IKl/qovpTsUMBZD0yElaLl2qvs7j3TZduNAbo9FIiadPSx4mJsrRA22Y/vLLf/QNqxMKCehhtwQiFWOI6U7soWg5tGgCgUK+cWMO/erVWvBxyMvL3ck+PhYcZJlk7d5dC22inDvJo858VOA2YJYbUCikaiQhqg8dKvrl4UPhm0eP+kICc2ROjqo7UpVAUBS3YUM+MqGb0fTI6U+fLNSTimF3kSBDtidxj9YNZFox792rLFm3LjV+9eqcMW5uTR/v3Elfsno1MXT7di/4zu/79vFJ6HtQPkBUB9V0ZX4BB2knk8l5167xyJaW1Ml79wYxV60ajiarta20VJUh7z16tBECh2Qa0uPT0YMe3oeKPQguKtF1BTU1rTeuXcNGz5lDt8vIYF9Rx440que3AwcakURqDFTnuuo5qx0AUq5l5kq6UzFDbRB6OaEEtQFV9hMjIijumzcP10hI+KcAmaOnvviCi1akmNnHmhjSv/41Gn4eWb++0sTRkTpq9mwM2j+0u7nZKubMaRTk50vFJBI3Ydeu6jGdK12hq8AJrDBIhpaUl8v2vf8+Z9ry5baf5OaOg3Oyigrp5SlTEo9Onny7zc/PPiU+vtUeSSWQIH1RiU8Ri6kZamZuv0CiAQr4CJovXarIMzVNoYaHeyna2oyvHjggLExMhLYJYsg+t+lDUA1GB41Ghp+z1q51gKRlsJw4aJWFr1zJSqitleUcOcJW7N4NwDMc1gffitoDSwYXvkF7e/OG8+e9/7BykPSgOzubSgMCnCwyM8uJ8fGiUPQnAVF10U/xVE+NdIekmfvUbnnwHSiOHy+Nf/XV1FNvvHFfnphYiQhf9TS1KuiryOZ8+eUD+AkAgQ6Ev+7YwfMYOVLVDqowN7edJxBgUBA+Sd3Eri9tGVry8+USZCqbqoNxRdnZjf+ZN68859YtVaS2XCikQO4KAp4E3TMfUhJM9Zu03LVHmUwtQTqw52T0OQoMDi/oWCxV9/gCjyccT+Kqhn5ohrt2hbi+8sow7c+hfuXziIgSiJFMRg8drquL24DqQqrGtPrAgceFv/8u4QcGDpPQ6YygRYssgDz7I5M94+pV8YFVq0oRr6mEGA9RP0G0JzZzextD2gQeiKHsXHK06lmzRngtWeImk0qVKWfOCB8nJIih/cMUZJKCC7834GlnwP0hoVJTeYmrV+eOQ7zJc/58Z/gs++pV4dH//KfaUiQSgMQDv83fYOY+MUl9YUECZJL02muukA8i1CpywjqfrhF6opRCDGNUYRgdsslsEUeAPBNndf1Kb9eGTDXYVWJbSMiD4JUr7aa++ioT+svXJSRUtyckVBADAlic1lbT7Ph4BbqubCyaTFAxJv0L8feFpHbrScVB0suAjDLa4sX+UIWv8soiq6N0x44s4pUr5Qy1eoK+JJDfAQeABD6HSewqQbqrpoN+7WDSXtqzhxe1bp1NJgIItNaaGBZmtsvJKQ76jTSpe4+AY8+ps09q2wDUxRT1V8UMNZDovRYYAAJlD8fff78YeqtCG23CvHk+ZZ6eDmL1zg8ABvByQkDNRW3mdqdiCMHBw5gffDCZevjwTNvHj5dwg4KcahMSKlUdlxFAQKUA53D18lIBUmhhYY6sljboDYL4DR9ItYn+Saqmy2Gtlpn73JBUvYME8kzkVlY0zW5QsPJBgjxISJAq6XQKhOKh7KGDSqW4rls3Gj1ZuvwJ6o8b6+oaVKtt+nSHto4Ow4yWFqvEL78s05x3HjvWdMOlS57Wbm5UyHXlClVOX5UjsDvJpAcz9y+NdJ8XM3fAQEIJDx9lfe5ceOt//hPY9q9/jaq4fl0In/uFhTGhlTf4QQ7885/lvlOnmtBsbCiPEQ8RPEG2uSwlhfsHYUXSgzBihDW/qKj5xsqVaSClLG1sCGY2NqTrMTFcIKlQvK2nwm1dZu4LIUH65EzDdJihIDVMnJzMhq9ePRoSexJ/+SWRdvNmjetLL6kSiLore2h5AmA2X7tWzV+8WFgrEBiPmjqVvmTbNvtrxsbyxgsXShJWrkyXOTpap8XHQ7eiZsQ/ZFDHA469vyEW0/IiSJCnJq5APglHjsyyDglRmZwQF9kbGZnnYWAgnnn0aKDdU5Y9qBxlCFAFyKDJwDCrsH37Ro2ZM0fVRAaSr02trckn5s5NVRQXyxAioYNiI7SsoKj7uuqZpGpnlOk1FvNcWzfwZ8DecfbvvRegaVgHqYuxkZF3iQJBQ8dLL7kZOjiYpV68KO2t7KE7Pwg47sSHDlVAiSZCkyEPOjQiw8knJiZohDrpCRxwByIicqEk0xfDxCT9Osr0aua+kCCBiTTw8WHV3b8vT7x6tZUREeH66tatKomiKk8wMmoXsdnSk0uXPgZrw7bTFG3QFVTTtMxq4vMbL44dex3KMKzUHYSAHMP2ZgbLlvk2UKn0G8eOSWxEovrpaALBAadHFdPVk6odi9E7BxnS+SS9WTSaxjRmixZhhtOm1V18552HsUZGzXM2bx4OeaRwjltTo6rAh1oVTRxGV56JcWioKg0y4dgxHlIzFtBhQAMSAJc3kkZl+/dnV6BfPQoBXJPVPkCe1K6xmBd2j+onAglkzwNARIgTlBYWtkB8xGPmTJvQmBjDpOXLs449eCAJ2rRpRC2H03F448Z6NIkG4MjSpQrAQwsbImoccPdu3VL9n66RWgDKcHWYX6l+T9FvuF+7ePu5SBj6201gYmSkKtno+NattSQ6naDZLgx4wpSYGH8jNlt0NSLiTuy77953FolqYWuRvpikHVxuy8O3347XFE6t/PZbe4alpYEBSN4u3zVWdxvSFHoNAEnV3nn7hTFznxok4GonffPNOGFVVTPUwtAYDKORU6aY3vz555qbJ06o9uWFLHqvjRtHoglsRjyBMxMdPn2ImagccEuXusnu3hXGLlmiyiJzcHcnRZ09G1jBZDIHYsfvHkjqXxrpvugSpM8gATIJ1f2MRYv8bp07p4gJC8sNWbRIZd7ePnpUwLKwaIeeHr98/TVvzwcf1EPcxKYzsafXZnPaW51Zbd06Y2x29nyWqytJ0xUavKhBZ85MezQwW8Pr3HkbB0gfQaLaXfvnn1VloFB0lZGerkQmjMycwVA9wG9yc319Z89mFt6+LUr48UfocihE5+VdeYIqKowsIrBQwLzVAE9JoZBST5/mAsigY7P/5s1jKtLT5WfVQIHCqUw+3xQ2KRggCaLtSX1hYjF6BQlktWvIpNLERLX7E2zNUbVtWwbsZacimVeuSE588QUUbYs19TbaZi4Agnnnzmv0jz6aloNh5rCztvHcuaqko3M7dlTvWbeufnNgYC74PcDf4rZ0qWtTejrv/Lx5yedWry6A30nUX8W9tgThY3/eeRuXIP0BycN5826AdxNeL16/3sopIEDVLM/w7l3uxYCA65/4+WUeWr26FBJ7IG/DpZu2EtT33w+AUtGUkye5WFSUl4jJpMNeM3DO1N6eYodANw1NkjA2VrXLpcv48Qy0nInWRUW1szozyvq8+UA/JUgNLkGewgSm83jyOwsX3p545kwI+D/ePHZsdGx0dCM1LY3ti2Eia6GwETgIuMOBh3RnjrYpO7tY+oSGWlu8/bYDJzWVVZWYyIFOv3NWrLCiEwjNxnFxCs9XXrGH7539+ut6dD0jyNK36UP/1X4CpLQbKwaXIP3xuCo7ZbAxkEcNUFQJP/PmJXkUFVVBEzxNy8qeJrJ+xAgrz3Pnwonq2tzvo6NL5QkJlcuuXvWzHTmSof3d8v+f68qZiv4r/emzyXoycwcsFvM8elx7VTcw8ZCU7MXn19/TavSSXlRE5qnJpAHW+17v5kymgQYgMKI2bbInWloSr4eGJt89eLAKao2L0XFl3z7epxERZZDr6qZOFhoAM7e0G0cZrmKeRpJ0J1HA2gAyCVzBrQ/Jxc0AxB9/DLmXlUWIWL/eUVObGx8ZecdIIFBUIK2G5H/nBkmI00C431M/IOkai2EPRoA8VwE+DVDAHAVyCmSyL8VTkFIAGfIPMMzCOCDA+i3EazTtH25HRt5mCgQStUiD9pqt4En9OzY1HCwc5LnKcdWoHjBxnXX0HenCjJUQhIOmel6ZmYXQjVHT19VqzZrRUMcDVpFXZ7CuaQBqc9ndcBCcpA4ESLT5h84964KDme1WVmRwnGkCcVadDWganJBlBDuFwxZqJ7du5QqeMFvtCSVIOdalkS7OQQZQ3fRlaNo/ECwsTNobG1uLdu26r/jpp0LtlliabV7zMYwxgPvm/i0JQ7i6eVK0WVsTobKutaPDKOPMmTrIbvf+v/8LIGzbFoTkPa1Z/btA/YBUGeBNDbW3RcU9qYMFJOTVq1VpBL998QXncV5eK5BTcNnLyGQ6YeXKUWg5U1q1gAJF27r6uvaTg2i3f3juireHNEiaxGKVyRr+0UfOb3z2mSNsdVaUmiqf/I9/sDBbW2h5RZfof8+/rtFc7VgMTlIHA0hAxRjPn28P0V3uzp1s2FUTdnmAZKRL+/aJ/IKCVA43TkVFB7dz3zrDAQBIVwmCJwwNFuKqXfNbeekSu2TNmgyz11938f/qqwna34Miqo9DQorGYlhtSP+b9/eFpP5pU8OhIkGey0RoGJDrCvkgDTxeU/GtW9KkQ4cUMz7/PKAhJaX20IwZd0d9+OEIKOK+ERPD42RnQ99VaL0tNRuYWEw59px2GBoykkS9e6Zvzbp1uRDlVe3be+9eZBuJRDn5+ee1wdHR1rDdu+b7pyIj02rT06VSdTkntJWA7kVQ3U/Xb/sH7XB/9VCTIM+VJLG4cCGCYG9vQWUyWYXR0SnQjN+CTCZRLC0pb+/cqerlCv3JOEVFze5jxlBZs2c7SdPTc/wwTAD75vbUVkJPJBXPah8MxLXu5MnHKsRPn+7guH9/MBRIPf722/tSdWba3cuXZetDQysep6erOgBk3bnTDFuNQEdGl17aSujRzMVJ6rNWN7Ww49XKlWODNm4cCe8Lrl+vz16+PFWM1EkxEjRrL13yodLphtBmAlIQv4iIKBmPJm8qIpS62mv2EyClQ5WkDlV1Y9gdBzE9cSJEbGVlAr1EoMZFuW/fg8TPPy+A81BjMyYmZgICQMuKd981gk6KABBo/7BzyRJVPojLwOSDaEgqG8NzUp+tJLFEpBQ4CLSxSl6w4JY7n88Hr2gFsnpbV6zwC9m0aQR8796hQ5X1n36agWaPUGJhYVsnFBoigMhGIS4C5Zj0QdqjDJckepAkGg4CbawCz5yZAYlG4CxTbS3288+5D8+dg3gI5jlnjm0+UjdmsMmxUFgxG63yGWgCkU6S6DlhCI/FDDaQ8HftKr77xRcP4TXkfEBuqzZQjLKyKtSzaID4iglEd8dimCiws+ZGoefSSzwWMxhBwuzCQTRAKfX0tIddvl1Xr1Zt8ZqTkCBTqlNL+ppn0g8O8pdNDXEJMkisG4jWIoZI5b/8sufsnTv9NLt6awbkqG5asKDSSSSC2hiOS+ek6hsg2irmua3NHbL5JKBCYOKtr19/BLuEQxmm5lzqlSsSBJAqM5FIBEnLmv4heiapePH2UPGTQBZZHYaRcxFBlfn7O2dlZYGvvQ3MXD9EX6Cpv64+8P2UIHpppItLkr/JmQZAgSa90LMMHGjkznzVJpAgA9RpuUTbzB3sGysPxBhysRtwqQOZBe8pEFVoLEPQz8R1F4v5024PLyJABuMgPMEXlZj+Jq2nrPY/YjE4QIYgSPQpTTEdxdv+ysEmcHGQPCuAaMdi/iic8sfx8UKDROemhjhAXmyQ9NSjrAaXIDhIejJz2bgEwUHSE0DYXQCCS5AXHCS6GukCQPBo7gsMkt4ShnAVg4NE987bOEBebJDo3O0BB8iLDRKdsRgcIC82SHAzFwfJE5NUHCA4SHqUIBU4ScVB0hNA6nGSioNEF0ktw0kqDhKcpOIg6beK6brzNi5BXnCQ9CVhCI/FvMAgwROGcJA8EUktx81cHCR9Jam4mYuDBI/F4KN3kPRGUmU4ScVB0lvCEK5icJD0GIvBVQwOkr8ApF7LiqnFzVwcJN2RVDwWg48/gaQnkoo7yvDxB0h6i8XgAMGHCiR48TY+dIIEj8XgQydIynEzFx+6QKLtScUlCD7+MqCxnhWmbsWNu9rx0RNISLgEwYcukBjgAMFHryDB8YEPXeP/CTAAf3oHi2QB+X0AAAAASUVORK5CYII=) no-repeat scroll 0px 0px transparent; height: 136px; width: 135px; z-index: 9999; position: absolute;">&nbsp;</div>',
        url_whitelist_path = "//www.ibm.com/common/scripts/ccf/ccf-intercept-whitelist.js";



	/**
		Callback from subscription to translations 'dataReady' event publisher. Checks if footer is enabled and runs init if so.
		
		@method autoInit
	**/
	me.autoInit = function () {
		if (IBM.common.util.config.isEnabled("opinionlab.intercept")) {
			$(function(){
				me.init();
			});
		}
	};

    /**
     * Initial function which is available to developers to initialize the intercept. 
     * 
     * 1) Loading white list data
     * 2) Validating given configuration's
     * 3) If validation is sucess then create Intercept survey invitation
     *  
     */
    me.init = init;
    function init() {

        settings = $.extend(true, defaults, IBM.common.util.config.get("opinionlab").intercept);
        settings.cookie_name = "ccf-" + settings.survey.type + ":" + settings.survey.id;
        settings.presentDelay = settings.presentDelay * 1000; // set default as 3 seconds if presentDelay param is not configured

        // This is only for v18 developers to test with local white list file, it should not list this parameter anywhere in documentation		
        if (typeof settings.user_whitelist_path !== 'undefined') {
            url_whitelist_path = settings.user_whitelist_path;
        }


        // Loading whitelist data.
        getWhitelistExceptionData();

        myEvents.subscribe('exceptionDataLoaded', "opinionlabccfintercept", function() {

            if (validateSettings() && makeSurveyURL()) {

                invitation = createInvitation();
                survey = createSurvey();

                // Binding all events for invitation panel
                bindInvitationEvents();

                // If not exit survey 
                if (settings.interceptDisp !== "pageExit" && settings.interceptDisp !== "siteExit") {

                    // Making delay for showing invitation
                    // Default is 3 seconds
                    setTimeout(function() {
                        invitation.show();
                    }, settings.presentDelay);

                    // If exit survey
                } else {
                    exitPageOplabTrigger();
                }
            }
        });
    }


    /** Private Functions **/
    function getWhitelistExceptionData() {
        $.getScript(url_whitelist_path + "?callback=?");
    }

    function exitPageOplabTrigger() {

        var mastheadLinks = "#ibm-masthead a",
            footerLinks = "#ibm-footer-module a",
            customLinks = "a.ibm-intercept-exit-survey",
            redirectStatus = false,
            clickedOnLink = false,
            pageLink = {
                url: ""
            };

        // Diff function for arrays.
        // Does array deltas (removes items from one array that exist in another.)
        Array.prototype.diff = function(a) {
            return this.filter(function(i) {
                return a.indexOf(i) < 0;
            });
        };

        function tagAllLinks() {

            // If the abandon link has a valid URL:
            //   Stop the click action.
            //   Store the URL for later use.
            //   Show (try) the survey & goto the URL after survey complete (or a no-show).
            $(mastheadLinks).click(function(evt) {
                var ul_tag = evt.currentTarget.parentElement.parentElement;
                if (evt.currentTarget.href !== "" && evt.currentTarget.href.substr(0, 1) !== "#" && ul_tag.id !== "ibm-menu-links") {

                    clickedOnLink = true;

                    evt.preventDefault();
                    pageLink.target = evt.currentTarget.target;
                    pageLink.url = evt.currentTarget.href;
                    //removeWindowExitEvents();
                    launchExitSurvey();
                }
            });

            $(footerLinks).click(function(evt) {
                if (evt.currentTarget.href !== "" && evt.currentTarget.href.substr(0, 1) !== "#") {
                    evt.preventDefault();
                    clickedOnLink = true;
                    pageLink.target = evt.currentTarget.target;
                    pageLink.url = evt.currentTarget.href;
                    //removeWindowExitEvents();
                    launchExitSurvey();
                }
            });

            $(customLinks).click(function(evt) {

                if (evt.currentTarget.href !== "" && evt.currentTarget.href.substr(0, 1) !== "#") {
                    evt.preventDefault();
                    clickedOnLink = true;
                    pageLink.url = evt.currentTarget.href;
                    pageLink.target = evt.currentTarget.target;
                    //removeWindowExitEvents();
                    launchExitSurvey();
                }
            });

            windowExitEvents();
        }

        function showOverlay() {
            if (invitationStatus === "") {

                invitation.show();
                invitation.subscribe('hide', 'Overlay', function(e) {
                    if (invitationStatus === "opt-in") {
                        redirectStatus = true;
                        survey.subscribe('hide', 'Overlay', function(e) {
                            redirectStatus = false;
                            redirectPage();
                        });
                    } else {
                        redirectPage();
                    }
                });

            } else {

                survey.show();
                survey.subscribe('hide', 'Overlay', function(e) {
                    redirectStatus = false;
                    redirectPage();
                });
            }
        }

        function launchExitSurvey() {

            var launchedSurvey = validateSettings();
            // If we tried to launch the survey and it returned false, that means no survey so just goto link.
            // Else, wait for survey's overlay to close (opacity = 0) then goto the link URL they clicked on in the first place.
            if (launchedSurvey === false) {
                redirectStatus = false;
                redirectPage();
            } else {

                showOverlay();

                windowExitEvents();
            }
        }

        function redirectPage() {

            if (!redirectStatus) {

                redirectStatus = true;
                removeWindowExitEvents();

                if (pageLink.url !== "") {
                    if (pageLink.target === "") {
                        window.location.href = pageLink.url;
                    } else {
                        window.open(pageLink.url, pageLink.target);
                    }
                }
            }
        }

        function removeWindowExitEvents() {
            window.onbeforeunload = null;
            $(window).unbind('beforeunload');
        }

        function windowExitEvents() {

            $(window).bind('beforeunload', function(e) {
                showOverlay();
                return settings.invitation.title;
            });

            setTimeout(function() {
                window.onbeforeunload = function(e) {
                    showOverlay();
                    return settings.invitation.title;
                };
            }, 500);
        }

        // Wait 2 seconds after onready to let all widgets init so we can bind links in them also.
        $(function() {
            tagAllLinks();
        });

        return {
            status: "loaded"
        };

    }

    /**
     * Creating Intercept Survey Invitation overlay.
     *  
     * It will pop up on the page loading, and asking for participating to the survey.
     * 
     *  1) If User clicks on yes button, means they wish to participate on survey then, open survey overlay and hide invitation overlay
     *  2) If user clicks on no button, means they do not wish to participate on survey.
     *  3) Create a cookie on hiding of the invitation overlay, as global barrier for 30 days to restrict them to participate on another survey from IBM.com.  
     * 
     */
    function createInvitation() {

        var template = '<div>' + getExceptionImage() + '<div data-slide="main" class="overlay-content-slide active" style="display: block;"> <div class="ibm-title"> <h2 class="ibm-bold ibm-h4">{{title}}</h2> </div><div style="" class="ibm-container ibm-alternate"> <div class="ibm-container-body"> <p>{{content}}</p><p style="padding-bottom: 3px;padding-top: 8px;">Your feedback is anonymous</p></div></div><div style="text-align: right;" class="ibm-buttons-row"> <div class="ibm-rule"> <hr> </div><a data-action="opt-in" class="ibm-btn-pri" href="javascript:;">{{yesLabel}}</a> &nbsp;&nbsp; <a data-action="opt-out" class="ibm-btn-sec" href="javascript:;">{{noLabel}}</a> &nbsp;&nbsp; </div><a data-slide-target="about" data-action="change-slide" href="javascript:;">About feedback at IBM</a> </div><div data-slide="about" style="display: none;" class="overlay-content-slide"> <div class="ibm-title"> <h2 class="ibm-bold">Ongoing Web Feedback at IBM</h2> </div><div style="" class="ibm-container ibm-alternate"> <div class="ibm-container-body"> <p> IBM collects opt-in feedback from IBM web users on a broad and continual basis throughout it\'s web sites. All feedback submitted are reviewed only by IBM employees or IBM affiliates and no feedback is shared outside of IBM for any reason. See IBM\'s <a data-action="close-overlay" target="_ibm_privacy_policy" href="http://www.ibm.com/privacy/us/en/?lnk=flg-priv-usen">privacy policy</a> and <a target="_ibm_tou" data-action="close-overlay" href="http://www.ibm.com/legal/us/en/?lnk=flg-tous-usen">terms of use</a> for further detail. </p><p> IBM may use a third party to collect or process feedback. Any such party is also bound by the IBM policy. Currently we use opinionlab for feedback processing. <br><a data-slide-target="leaving" data-action="change-slide" class="ibm-external-link" href="javascript:;">opinionlab</a> </p><p> Your input is very valuable to us and although we read every comment that is sent to IBM in an effort to continuously improve our web sites for you, we generally do not reply to comments from this system unless otherwise stated. Thank you for participating in the IBM web feedback program. </p></div></div><div class="ibm-buttons-row"> <div class="ibm-rule"> <hr> </div><a data-slide-target="main" data-action="change-slide" class="ibm-btn-sec" href="javascript:;">Back to Feedback</a> </div></div></div>',
            html = template.replace('{{title}}', settings.invitation.title).replace('{{content}}', settings.invitation.content).replace('{{yesLabel}}', settings.invitation.yes_label).replace('{{noLabel}}', settings.invitation.no_label),
            overlay = IBM.common.widget.overlay.createOverlay({
                backgroundcolor: '#ffffff',
                contentHtml: html,
                fullwidth: false,
                classes: 'ibm-overlay ibm-overlay-alt'
            });

        overlay.init();

        overlay.subscribe('hide', 'Overlay', function(e) {
            var cookie_value = '{"date": ' + new Date().getTime() + ',"type": "' + settings.survey.type + '","id": "' + settings.survey.id + '"}',
                global_expires = settings.global_minimum_wait * 24 * 60 * 60;

            IBM.common.util.storage.setItem("ccf-global-intercept", cookie_value, global_expires);

        });


        return overlay;
    }

    /**
     * Creating Intercept Survey overlay.
     *  
     * It will pop up after user clicks on yes button from invitation overlay, which will load the survey with in IFRAME from external/internal sources.
     * 
     * 1) Create a cookie on hiding of the survey overlay, as local barrier till end date for the survey, to restrict them to participate on current survey again.  
     * 
     */
    function createSurvey() {

        var template = '<div><iframe src="{{survey_url}}" width="{{survey_width}}" height="{{survey_height}}" frameborder="0"></iframe></div>',
            html = template.replace('{{survey_width}}', settings.survey.width)
            .replace('{{survey_height}}', settings.survey.height)
            .replace('{{survey_url}}', settings.survey.url),
            overlay = IBM.common.widget.overlay.createOverlay({
                backgroundcolor: '#ffffff',
                contentHtml: html,
                classes: 'ibm-overlay ibm-overlay-alt',
                height: settings.survey.height,
                width: settings.survey.width
            });

        overlay.init();

		$("#" + overlay.getId()).css({
			width: settings.survey.width + 70
		});

        overlay.subscribe('show', 'Overlay', function(e) {

            /**
             * Tracking by coremetrics code for intercept shown
             */
            IBM.common.util.statshelper.fireEvent({
                "ibmEV": "ol survey",
                "ibmEvGroup": settings.survey.type,
                "ibmEvModule": settings.survey.id,
                "ibmEvAction": "intercept shown"
            });


            var cookie_value = '{"date": ' + new Date().getTime() + ',"type": "' + settings.survey.type + '","id": "' + settings.survey.id + '"}',
                diffDays = Math.round(Math.abs((new Date().getTime() - new Date(settings.stop).getTime()) / (24 * 60 * 60 * 1000))),
                expires = diffDays * 24 * 60 * 60;

            IBM.common.util.storage.setItem(settings.cookie_name, cookie_value, expires);
        });

        return overlay;
    }

    /**
     * Events created for invitation overlay form,
     * 
     * 1) Yes button: 				If user clicks on yes button, then open survey overlay
     * 2) No button: 				If user clicks on no button, then hide the invitaiton overlay
     * 3) About feedback at IBM: 	If user clicks on 'About feedback at IBM', then show the IBM privaly policy window on the invitation overlay.
     * 
     */
    function bindInvitationEvents() {

        var $overlay = $("#" + invitation.getId());

        $('[data-action]', $overlay).on('click', function(evt) {

            var $self = $(this),
                action = $self.data('action'),
                target;

            switch (action) {
                case "change-slide":
                    invitationStatus = "change-slide";
                    target = $self.data("slide-target");
                    $("div.overlay-content-slide", $overlay).css("display", "none");
                    $("div.overlay-content-slide[data-slide='" + target + "']", $overlay).css("display", "block");
                    invitation.setHeight($("div.overlay-content-slide[data-slide='" + target + "']", $overlay).height);
                    break;

                case "opt-out":
                    invitationStatus = "opt-out";
                    invitation.hide();
                    break;

                case "opt-in":

                    invitationStatus = "opt-in";

                    /**
                     * Tracking by coremetrics code for if user clicks yes button 
                     */
                    IBM.common.util.statshelper.fireEvent({
                        "ibmEV": "ol survey",
                        "ibmEvGroup": settings.survey.type,
                        "ibmEvModule": settings.survey.id,
                        "ibmEvAction": "intercept yes clicked"
                    });

                    invitation.hide();

                    if (settings.surveyDisp !== "pageExit" && settings.surveyDisp !== "siteExit") {
                        survey.show();
                    } else {
                        exitPageOplabTrigger();
                    }

                    break;

            }
        });
    }

    /**
     * Creating survey URL.
     * 
     * Based on the survey type, survey URL will vary from different sources. 
     * This function is making URL for the particular survey based on the survey type.
     * 
     * 1) Creating survey URL
     * 2) Adding metadata with the URL if user given in configuration (This is now only appicable to ASM survey's, rest of the survey type meta information will add up later) 
     * 
     * */
    function makeSurveyURL() {
        var url = "",
            metadata;

        switch (settings.survey.type) {

            case "asm":
                metadata = getASMMetaData();
                metadata = metadata.length > 0 ? "&" + metadata : "";
                url = "//survey.opinionlab.com/survey/s?s=" + settings.survey.id + metadata;
                break;

            case "efm":
                url = "//ucdsurvey1.torolab.ibm.com/ss2/wsb.dll/s/" + settings.survey.id;
                break;

            case "spss":

                /**
                 * @TODO:
                 * 
                 * SPSS URL needs to add here. It is not yet receieved from Ben. 
                 * 
                 */

                break;

            case "OLcard":


                /**
                 * @TODO:
                 * 
                 * Here needs to add code for Opinionlab feedback overlay. 
                 *  
                 */

                break;

            case "userzoom":

                url = "https://s.userzoom.com/m/" + settings.survey.id;
                break;

            case "sg":

                url = "http://www.surveygizmo.com/" + settings.survey.id;
                break;

            case "comment_card":

                /**
                 * @TODO:
                 * 
                 * Here needs to add load custom comment card on the overlay. 
                 *  
                 */

                break;

            case "customB":
                url = settings.survey.url;
                break;
        }

        if (url === null) {
            console.warn("Intercept survey type is unknown: " + settings.survey.type);
            return false;
        }

        settings.survey.url = url;

        return true;
    }

    /** 
     * Creating ASM survey type meta data format.
     * 
     * 1) Every variable should start with 'opdata_'
     * 
     */
    function getASMMetaData() {
        var anonymousData = "",
            metadata = settings.survey.metaData,
            variables,
            variable,
            m;

        if (metadata !== "" && typeof metadata !== "undefined") {
            variables = metadata.split("&");
            for (m = 0; m < variables.length; m++) {
                variable = variables[m].split("=");
                anonymousData += "opdata_" + variable[0] + "=" + variable[1] + "&";
            }
        }

        anonymousData = anonymousData.length > 0 ? anonymousData.slice(0, -1) : anonymousData; // removing leading "&"
        return anonymousData;
    }


    /**
     * Validation function.
     * 
     * Which is validating the configuration's which developer has given in HTML page.
     * 
     * */
    function validateSettings() {

        if (window.location.host.indexOf(".ibm.com") < 0) {
            console.warn("Survey intercept only with ibm.com");
            return false;
        }
        if (!settings.survey) {
            console.warn("No intercept survey was defined.");
            return false;
        }
        if (!settings.survey.type) {
            console.warn("No intercept survey type was defined.");
            return false;
        }
        if (!settings.survey.id) {
            console.warn("No intercept survey id was defined.");
            return false;
        }
        if (!settings.percent) {
            console.warn("No intercept percent was defined.");
            return false;
        }
        if (!settings.invitation) {
            console.warn("No intercept invitation was defined.");
            return false;
        }

        /** 
         * Checking global barrier
         * 
         * Global barrier which is creating for restrict users to participate from another survey from IBM.com
         * Whcih is creating for 30 days from the day when users got invitation from IBM.com
         * Validation needs to check if the global barrier is set and if invitation status is not set
         *
         */
        var global_barrier = IBM.common.util.storage.getItem("ccf-global-intercept"),
            last_date,
            has_local_barrier,
            avail_date,
            random,
            has_percent_barrier;

        if (global_barrier !== null && invitationStatus === "") {
            global_barrier = (new Function("return " + global_barrier))();
            last_date = new Date(global_barrier.date);
            avail_date = new Date(last_date.getTime() + (settings.global_minimum_wait * 24 * 60 * 60 * 1000));
            console.log("An intercept survey was last seen " + datestamp(last_date) + ".\nThe earliest another one may be seen is " + datestamp(avail_date));
            return false;
        }

        /** 
         * Checking local barrier
         * 
         * Local barrier which is creating for restrict users to participate from the same survey again with in the survey duration
         * Whcih is creating till the end of survey duration from the day when users has completed survey form.
         * 
         */
        has_local_barrier = IBM.common.util.storage.getItem(settings.cookie_name) !== null;
        if (has_local_barrier) {
            console.log("This survey (" + settings.survey.type + ":" + settings.survey.id + ") has already been seen.");
            return false;
        }

        /** 
         * Percent
         * 
         * Which is measuring the percentage of visitors, by page, to ask to take the survey.
         * Exception required for a percentage above 25%. 
         * A "testing only" flag will be added to the invitation when the percentage exceeds 25% (useful for testing your code).
         * 
         */
        random = (Math.random() * 100);
        has_percent_barrier = (random < settings.percent);

        if (!has_percent_barrier) {
            // do nothing... maybe they will get it next time. For now, let the devs know what just happened
            console.log("Survey was all ready, but did not pass the " + settings.percent + "% barrier. Current percent is " + random);
            return false;
        }

        /** 
         * Prevent Count
         * 
         * Which is calculating number of times a visitor must visit the page before an intercept may be shown.
         * 
         */
        if (!checkPreventCount()) {
            return false;
        }

        /**
         * Referral URL
         * 
         * Which is allow to show the intercept invitation if the visitor is coming from the given referer URL's.
         * 
         */
        if ((typeof(settings.referrerURL) !== "undefined" && settings.referrerURL.length > 0) && !checkReferrerStatus()) {
            console.warn("Intercept: Referrer URL is not matching.");
            return false;
        }

        /**
         * Exculde URL
         * 
         * Which will prevents intercept invitation to display to visitors if they are  coming from listed URL's.
         */
        if ((typeof(settings.excludeURL) !== "undefined" && settings.excludeURL.length > 0) && checkExcludeURLStatus()) {
            return false;
        }

        /**
         * Exit configuration's
         * 
         * Which will display the intercept invitation on the page load and display on page exit, 
         * if developer has set up the interceptDisp/surveyDisp as pageExit/siteExit.
         *  
         */
        if (!checkExitConfigurations()) {
            return false;
        }


        /**
         * Time frame validation
         * 
         * Which is validating the time frame (start/stop) given in the configurations.
         *   
         */
        if (!checkTimeFrames()) {
            return false;
        }

        /**
         * Custom B validation
         * 
         * If developer has choosen the survey type as customB, then it should get exception request from white list file
         *   
         */
        if (settings.survey.type === "customB") {
            if (checkCustomBExceptionStatus() === false) {
                return false;
            }
        }

        return true;
    }

    /**
     * Water mark image
     * 
     * If the percent parameter is above 25% and exception is not granded, then red flag should show with invitaiton overlay.
     * 
     */
    function getExceptionImage() {
        var watermark_content;

        // set watermark - Add a limit to the percent parameter 
        if (settings.percent > 25 && !checkPercentageExceptionStatus()) {
            watermark_content = watermarkImage;
        } else {
            watermark_content = "";
        }
        return watermark_content;
    }

    /**
     * Percent Exception status
     * 
     * If the percent parameter is above 25%, then checking for exception from given whitelist file
     * 
     */
    function checkPercentageExceptionStatus() {

        var is_valid = false,
            href = window.location.href,
            i,
            exception_data;

        for (i = 0; i < settings.exception.data.length; i++) {

            exception_data = settings.exception.data[i];

            if (exception_data['for'] === "percentage") {
                if (typeof exception_data.limit !== "undefined" && exception_data.limit >= settings.percent) {

                    is_valid = checkExceptionStatus(exception_data, href);
                    if (is_valid) {
                        break;
                    }
                }
            }
        }

        return is_valid;
    }

    /**
     * Prevent Count
     * 
     * Number of times a visitor must visit the page before an intercept may be shown
     * 
     * 1) Increasing the count each time visit and storing to cookie.
     * 2) Intercept will launch when the count is equal to preventCount in config var.
     * 
     */
    function checkPreventCount() {
        var diffDays,
            expires,
            preventCount,
            prevent_cookie_name,
            prevent_cookie_value;

        // prevent the intercept presentation until user has visited number of times. Item no: 7
        if (typeof settings.preventCount !== "undefined") {
            // validating prevent value
            if (!(!isNaN(parseFloat(settings.preventCount)) && isFinite(settings.preventCount))) {
                console.warn("Invalid prevent count.");
                return false;
            }
            preventCount = settings.preventCount;
            prevent_cookie_name = "ccf-prevent-intercept-" + settings.survey.type + ":" + settings.survey.id;

            if (IBM.common.util.storage.getItem(prevent_cookie_name) === null) {
                diffDays = Math.round(Math.abs((new Date().getTime() - new Date(settings.stop).getTime()) / (24 * 60 * 60 * 1000)));
                expires = diffDays * 24 * 60 * 60;
                IBM.common.util.storage.setItem(prevent_cookie_name, 1, expires);
            }

            prevent_cookie_value = IBM.common.util.storage.getItem(prevent_cookie_name);
            if (prevent_cookie_value < preventCount) {
                prevent_cookie_value++;
                diffDays = Math.round(Math.abs((new Date().getTime() - new Date(settings.stop).getTime()) / (24 * 60 * 60 * 1000)));
                expires = diffDays * 24 * 60 * 60;
                IBM.common.util.storage.setItem(prevent_cookie_name, prevent_cookie_value, expires);
                return false;
            }
        }
        return true;
    }

    /**
     * Referral URL status
     * 
     * Which is checking the referrer URL is matching with any of the URL from given list Referrer URL's. If yes, then show the invitation else not.
     * 
     */
    function checkReferrerStatus() {
        var referrerStatus = false,
            urls = settings.referrerURL,
            len = urls.length,
            i = -1,
            href = document.referrer;

        while (++i < len && !referrerStatus) {
            if (url_check_equals(urls[i], href)) {
                referrerStatus = true;
            }
        }
        return referrerStatus;
    }

    /**
     * Exculde URL status
     * 
     * Which is checking the referrer URL is matching with any of the URL from given list Exclude URL's.  If no, then show the invitation else not.
     * 
     */
    function checkExcludeURLStatus() {
        var excludeStatus = false,
            urls = settings.excludeURL,
            len = urls.length,
            i = -1,
            href = document.referrer;

        while (++i < len && !excludeStatus) {
            if (url_check_equals(urls[i], href)) {
                excludeStatus = true;
            }
        }
        return excludeStatus;
    }

    /**
     * 
     * Time frame status
     * 
     * Checking defined start and stop date are valid and with in 10 - 60 days
     * checking end date is passed or not
     * If end date is ending with more than 60 days calculating 60 days from starting date and rewriting the end time
     * 
     */
    function checkTimeFrames() {

        var start = new Date(settings.start),
            end = new Date(settings.stop),
            delta = (end - start) / (1000 * 60 * 60 * 24),
            min_delta = 10,
            max_delta = 60;

        if (isNaN(start.getTime())) {
            console.warn("Invalid start date.");
            return false;
        }

        if (isNaN(end.getTime())) {
            console.warn("Invalid stop date.");
            return false;
        }

        // overwrite the end date if survey is too short
        if (delta < min_delta) {
            end = new Date(start.getTime() + (min_delta * 24 * 60 * 60 * 1000));
            console.warn("Survey duration was too short. Minimum of " + min_delta + " days.\nOverwrote survey end to " + datestamp(end));
        }

        // overwrite the end date if survey is too long
        if (delta > max_delta) {
            end = new Date(start.getTime() + (max_delta * 24 * 60 * 60 * 1000));
            console.warn("Survey duration was too long. Maximum of " + max_delta + " days.\nOverwrote survey end to " + datestamp(end));
        }

        if (now < start) {
            console.log("Survey is not yet within the active timeframe.");
            return false;
        }

        if (now > end) {

            if (!checkDurationExceptionStatus()) {
                console.log("Survey has passed the active timeframe.");
                return false;
            }

            console.log("Survey has passed the active timeframe. But duration exception granded.");
            return true;
        }
        return true;
    }

    /**
     *  Duration Exception
     *  
     *  Exception giving to some URL's to use intercept more than 60 days
     * 
     */

    function checkDurationExceptionStatus() {

        var is_valid = false,
            href = window.location.href,
            i,
            exception_data;

        for (i = 0; i < settings.exception.data.length; i++) {

            exception_data = settings.exception.data[i];
            if (exception_data['for'] === "duration") {

                is_valid = checkExceptionStatus(exception_data, href);
                if (is_valid) {
                    break;
                }
            }

        }

        return is_valid;
    }

    /** 
     * Exit configuration's
     * 
     * If interceptDisp = "pageExit" then surveyDisp "immediate" and "pageExit" are equivalent
     * If interceptDisp = "siteExit" then surveyDisp is always "siteExit".
     * 
     */
    function checkExitConfigurations() {

        if (settings.interceptDisp === "pageExit" && settings.surveyDisp !== "immediate") {
            settings.surveyDisp = "immediate";
            console.warn("Survey display should be immediate or page exit");
        }
        if (settings.interceptDisp === "siteExit" && settings.surveyDisp !== "immediate") {
            settings.surveyDisp = "immediate";
            console.warn("Survey display should be site exit");
        }
        if (settings.interceptDisp === "siteExit" || settings.surveyDisp === "siteExit") {
            if (typeof(settings.exitURL) === "undefined" || settings.exitURL.length <= 0) {
                console.warn("Intercept: Exit URL is empty.");
                return false;
            }

            if (!checkExitURLStatus()) {
                console.warn("Intercept: Exit URL is not matching.");
                return false;
            }
        }
        return true;
    }

    // Placeholder, needs defining or the call to it removed.
    function checkExitURLStatus() {

    }

    /**
     * Custom B validation
     * 
     * If developer has choosen the survey type as customB, then it should get exception request from white list file.
     *   
     */
    function checkCustomBExceptionStatus() {
        var is_valid = false,
            href = settings.survey.url,
            i,
            exception_data;

        for (i = 0; i < settings.exception.data.length; i++) {
            exception_data = settings.exception.data[i];
            if (exception_data['for'] === "customB") {
                is_valid = checkExceptionStatus(exception_data, href);
                if (is_valid) {
                    break;
                }
            }
        }
        return is_valid;
    }

    /**
     * Exception status
     * 
     * Exception can be granted for the application URL or survey ID.
     *   
     */
    function checkExceptionStatus(exception_data, href) {

        var is_valid = false,
            k,
            exception_for;

        if (exception_data.type === "URL") {

            if (typeof exception_data.value === "string" && url_check_equals(exception_data.value, href)) {
                is_valid = true;
                exception_for = exception_data['for'];

            } else {

                for (k = 0; k < exception_data.value.length; k++) {

                    if (url_check_equals(exception_data.value[k], href)) {
                        is_valid = true;
                        exception_for = exception_data['for'];
                        break;
                    }
                }
            }

        } else if (exception_data.type === "ID") {

            if (typeof exception_data.value === "string" && url_check_equals(exception_data.value, href)) {
                is_valid = (settings.survey.id === exception_data.value);
                exception_for = exception_data['for'];

            } else {
                for (k = 0; k < exception_data.value.length; k++) {
                    if (url_check_equals(exception_data.value[k], href)) {
                        is_valid = (settings.survey.id === exception_data.value[k]);
                        exception_for = exception_data['for'];
                        break;
                    }
                }
            }
        }

        return is_valid;
    }

    /**
     * @TODO: 
     * 
     * Whitelist file already created and uploaded to below URL's, there its using ibmweb as object name based on v17 code base.
     * It needs to change once v18 is completed with all development.
     * 
     * http://www.ibm.com/common/scripts/ccf/ccf-intercept-whitelist.js
     * http://w3.ibm.com/w3/js/ccf/ccf-intercept-whitelist.js
     *  
     */

    window.ibmweb = window.ibmweb || {};
    window.ibmweb.dynnav = window.ibmweb.dynnav || {};
    window.ibmweb.dynnav.ccfintercept = window.ibmweb.dynnav.ccfintercept || {};

    window.ibmweb.dynnav.ccfintercept.callback_whitelist = function(urls) {

        /** Unused, why are these here?
		var is_valid = false,
			len = urls.length,
			i = -1,
			href = window.location.href, exception_for = "percentage";
		**/

        settings.exception = {};
        settings.exception.data = urls;

        myEvents.publish('exceptionDataLoaded');
        //settings.whitelist_status = true;		
    };


    /** Miscelloanous Functions */

    function url_check_equals(regexUrl, url) {
        var is_valid = false,
            check = new RegExp("^" + regexUrl + "$", "i"),

            match = url.match(check);
        if (match && match.index === 0) {
            is_valid = true;
        }
        return is_valid;
    }

    function datestamp(timestamp) {
        var a,
            y,
            h,
            m,
            mm,
            d,
            dd,
            ret = '',
            then,
            now;

        if (timestamp === null) {
            return null;
        }

        then = new Date(timestamp);
        now = new Date();

        // If it's the same day, skip the date
        if (!(now.getFullYear() === then.getFullYear() && now.getMonth() === then.getMonth() && now.getDate() === then.getDate())) {
            // date
            y = then.getFullYear();
            m = then.getMonth() + 1;
            mm = (m < 10 ? '0' : '') + m;
            d = then.getDate();
            dd = (d < 10 ? '0' : '') + d;

            ret += mm + "/" + dd + "/" + y + ' ';
        }

        // time
        h = then.getHours();
        m = then.getMinutes();
        mm = (m < 10 ? '0' : '') + m;

        a = (h > 12) ? 'pm' : 'am';
        h = ((h + 11) % 12) + 1;

        ret += h + ":" + mm + a;

        return ret;
    }


	// Wait until meta is ready and has setup all config.sets
	IBM.common.meta.subscribe("dataReady", "opinionlabccfintercept", me.autoInit).runAsap(me.autoInit);


})(jQuery, IBMCore);;

/**
	
	This file simply subscribes to DOM ready event and dynamically injects the Notice/Choice JS file (notice-choice.js)
	 if the page meets the specified criteria and adds the proper form fields based on the page's settings.
	
**/
(function ($, IBM) {
	
	/**
		Automatically run on DOM ready.
		<br />Validates if we need to fetch the NC script file and simply injects it. It's set for autorun, so 
		it's expecting META to be ready.

		@method init
	**/
	function autoInit () {
		var ddPageinfo = IBMCore.common.meta.page.pageInfo,
			ncForm = "";

		// Check if they have the proper settings before we .getscript the NC JS file.
		// First they need the proper NC and ID object that tells us where the form and the placeholder div is.
		if (ddPageinfo.nc && ddPageinfo.nc.id) {
			// Onload, check if the form and placeholder exists, then include extra JS if so.
			$(function(){
				ncForm = ddPageinfo.nc.id.form ? $("#" + ddPageinfo.nc.id.form) : ($(".nc_register_form")[0] || $("#registerform"));

				// Validate that the form and the placeholder div exist on the page
				if (ncForm.length === 0 || $("#" + ddPageinfo.nc.id.privacyDiv).length === 0) {
					return;
				}

				$.ajax({
					url: "//1.www.s81c.com/common/v18/js/notice-choice.js",
					//url: "/v18/js/notice-choice.js",
					dataType: "script",
					cache: true
				});
			});
		}
	}

	// META and DD object are requirement for us. Wait until meta is ready to init.
	IBM.common.meta.subscribe("dataReady", "NoticeChoice", autoInit);

})(jQuery, IBMCore);
;

/**
	
	This is required as part of our contract with monotype fonts. 
	This needs to be included in v18 as part of every page to track usage.
	
**/
(function ($, IBM) {
	$(function(){
		if ($("body").hasClass("ibm-type")) {
			window.MTIProjectId = "17a8a64a-6097-4e87-91d6-24cc74ebfec9";

			setTimeout(function() {
				$.ajax({
					url: "//fast.fonts.net/t/trackingCode.js",
					dataType: "script",
					cache: true
				});
			}, 1000);
		}
	});
})(jQuery, IBMCore);
;

/**
	
	This is for Kevin Eagan & John Rosato for Alexa certification.
	In order to certify to Alexa that John's account is the owner of the ibm.com site and to get better metrics, 
	we need this on all pages.
	
**/
(function ($, IBM) {
	$(function(){
		window._atrk_opts = {
			atrk_acct: "7mO0l1aoHvD0cv", 
			domain: "ibm.com",
			dynamic: true
		};

		setTimeout(function() {
			$.ajax({
				url: "https://d31qbv1cthcecs.cloudfront.net/atrk.js",
				dataType: "script",
				cache: true
			});
		}, 1000);
	});
})(jQuery, IBMCore);
;

/**

	This is the init (controller) for WWW & W3 common onload functions and bindings.
	<br />
	<br />This file is SHARED and used for BOTH WWW and W3 builds.
	<br />If a widget is specific for WWW or W3, put it in the www/init.js  or  w3/init.js file.
	<br />
	<br />What to put in here: Anything that's a common widget or magic data-attribute instantiated thing should go in here.
	<br />
	<br />How it works: There are two functions that run onload. One runs, the other runs if content widgets are enabled (default).
	<br />This allows for a global config setting to disable the auto-init of all content space widgets. 
	<br />Developers can disable widgets in two ways: On the element using @data-init="false" or globally using: config.contentwidgets.enabled = false.

	@class Other IBM - common init

**/

(function ($, IBM) {

	/** 
		Called on DOM ready. Always.
		<br />Only put stuff in here that should *always* run on DOM ready of a v18 page (which will be minimal).
		<br />DO NOT put widgets/magic class bindings in here. Put them in the conditional onload function.

		@method alwaysRunOnload
		@private
	**/
	function alwaysRunOnload () {
		// Placeholder/Future use.
	}
	
	
	/** 
		Called on DOM ready only if contentwidgets are enabled (default setting).
		<br />Anything in here will only run if content space widgets are enabled for the page. (default).
		
		@method runOnloadIfWidgetsEnabled
		@private
	**/
	function runOnloadIfWidgetsEnabled () {
		// Init these widgets on the elements that tell us they want to be converted to a widget, but that aren't disabled.
		// They are in A-Z order, except certain ones have been shuffled to the bottom b/c they can be used in other widget.

		if (IBM.common.widget.dyntabs) {
			$("div[data-widget=dyntabs]:not([data-init=false])").dyntabs();
		}
		
		if (IBM.common.widget.expertise) {
			IBM.common.widget.expertise.autoInit();
		}
		
		if (IBM.common.widget.formvalidator) {
			$("form[data-formvalidator=enable]:not([data-init=false])").each(function(){
				IBM.common.widget.formvalidator.init(this);
			});
		}
		
		if (IBM.common.widget.hiresimageswap) {
			$("[data-widget=hiresimageswap]:not([data-init=false])").hiresimageswap();
		}

		// Map old jumpform to this for existing users. Remove legacy mapping soon.
		if (IBM.common.widget.selectlistnav) {
			$("[data-widget=selectlistnav]:not([data-init=false]), [data-widget=jumpform]:not([data-init=false])").selectlistnav();
		}
		
		if (IBM.common.widget.leavingibm) {
			$("[data-widget=leavingibm]:not([data-init=false])").leavingibm();	
		}

		if (IBM.common.widget.masonry) {
			$("[data-widget=masonry]:not([data-init=false])").each(function(){
				IBM.common.widget.masonry.init(this);
			});
		}

		if (IBM.common.widget.overlay) {
			$("[data-widget=overlay]:not([data-init=false])").overlay();
		}

		// Checkbox has to come AFTER overlay b/c there's some binding issue going on and checkbox no workie (for now until we sort it out).
		// Checkbox has to be BEFORE datatable else only the first page of paginated table results get init'd.
		if (IBM.common.widget.checkboxradio) {
			$("form input:checkbox:not([data-init=false]), form input:radio:not([data-init=false]), table input:checkbox:not([data-init=false]), table input:radio:not([data-init=false])").each(function(){
				IBM.common.widget.checkboxradio.init(this);
			});
		}

		if (IBM.common.widget.datatable) {
			$("table[data-widget=datatable]:not([data-init=false])").each(function(){
				IBM.common.widget.datatable.init(this);
			});
		}
		
		if (IBM.common.widget.parallaxscroll) {
			$("[data-widget=parallaxscroll]:not([data-init=false])").each(function(){
				IBM.common.widget.parallaxscroll.init(this);
			});
		}

		if (IBM.common.widget.rssdisplay) {
			$("[data-widget=rssdisplay]:not([data-init=false])").rssdisplay();
		}

		if (IBM.common.widget.scrollable) {
			$("[data-widget=scrollable]:not([data-init=false])").scrollable();
		}

		if (IBM.common.widget.setsameheight) {
			$("[data-widget=setsameheight]:not([data-init=false])").setsameheight();
		}

		if (IBM.common.widget.showhide) {
			$("[data-widget=showhide]:not([data-init=false])").showhide();
		}

		if (IBM.common.widget.stepindicator) {
			$("div[data-widget=stepindicator]:not([data-init=false])").stepindicator();
		}

		if (typeof window.SyntaxHighlighter !== "undefined") {
			$("[data-widget=syntaxhighlighter]:not([data-init=false])").syntaxhighlighter();
		}

		if (IBM.common.widget.tooltip) {
			$("[data-widget=tooltip]:not([data-init=false])").tooltip();
		}
		
		if (IBM.common.widget.twisty) {
			$("[data-widget=twisty]:not([data-init=false])").twisty();
		}
		
		if (IBM.common.widget.videoplayer) {
			$("[data-widget=videoplayer]:not([data-init=false])").videoplayer();
		}
		
		if (IBM.common.widget.videolooper) {
			$("[data-widget=videolooper]:not([data-init=false])").videolooper();
		}

		// Putting carousel last since it's a container that can hold other widget and should init after they have.
		if (IBM.common.widget.carousel) {
			$("div[data-widget=carousel]:not([data-init=false])").carousel();
		}

		// Form widgets that can be used in some of the widgets above, wait until the widgets above have init'd and
		// possible created some of these form elements, so we can then turn them into widgets.

		if (IBM.common.widget.selectlist) {
			$("div.dataTables_length > label > select:not([data-init=false]), form select:not([data-init=false]), table select:not([data-init=false])").each(function(){
				IBM.common.widget.selectlist.init(this);
			});
		}

		if (IBM.common.widget.fileinput) {
			$("input:file[data-widget=fileinput]:not([data-init=false])").fileinput();
		}
		
		if (IBM.common.widget.tablesrowselector) {
			$("table[data-tablerowselector=enable]:not([data-init=false])").tablesrowselector();
		}
		
		// END runOnloadIfWidgetsEnabled
	}
	
	
	/** 
		Runs on DOM ready
		<br />Calls alwaysRunOnload(), then if content space widgets are enabled (default) it calls runOnloadIfWidgetsEnabled()
		<br />Allows us to disable all auto-init content space widgets via a single config setting.
	**/
	$(function(){
		// Always run this group onload.
		alwaysRunOnload();
		
		// If widgets are enabled (default) run this group which auto-inits them all.
		if (IBM.common.util.config.get("contentwidgets.enabled") === true) {
			runOnloadIfWidgetsEnabled();
		}
	});

})(jQuery, IBMCore);
;

/**

	This is the init (controller) for WWW onload functions and bindings.
	<br />
	<br />This file is for WWW SPECIFIC onload stuff ONLY.
	<br />If a widget is common and applies to both WWW and W3, put it in the common/init.js file.
	<br />
	<br />What to put in here: Anything that's a WWW widget or magic data-attribute instantiated thing should go in here.
	<br />
	<br />How it works: There are two functions that run onload. One runs, the other runs if content widgets are enabled (default).
	<br />This allows for a global config setting to disable the auto-init of all content space widgets. 
	<br />Developers can disable widgets in two ways: On the element using @data-init="false" or globally using: config.contentwidgets.enabled = false.

	@class Other IBM - www init

**/

(function ($, IBM) {

	/** 
		Called on DOM ready. Always.
		<br />Only put stuff in here that should *always* run on DOM ready of a v18 page (which will be minimal).
		<br />DO NOT put widgets/magic class bindings in here. Put them in the conditional onload function.

		@method alwaysRunOnload
		@private
	**/
	function alwaysRunOnload () {
	
	}
	
	
	/** 
		Called on DOM ready only if contentwidgets are enabled (default setting).
		<br />Anything in here will only run if content space widgets are enabled for the page. (default).
		
		@method runOnloadIfWidgetsEnabled
		@private
	**/
	function runOnloadIfWidgetsEnabled () {
		
	}
	
	
	/** 
		Runs on DOM ready
		<br />Calls alwaysRunOnload(), then if content space widgets are enabled (default) it calls runOnloadIfWidgetsEnabled()
		<br />Allows us to disable all auto-init content space widgets via a single config setting.
		
		@method
		@private
	**/
	$(function(){
		// Always run this group onload.
		alwaysRunOnload();
		
		// If widgets are enabled (default) run this group which auto-inits them all.
		if (IBM.common.util.config.get("contentwidgets.enabled") === true) {
			runOnloadIfWidgetsEnabled();
		}
	});

})(jQuery, IBMCore);
;

/**

	Used for testing/timing events and optimizing JS code performance.
	<br />
	<br />jstimer-start.js is at the top of JS build file. This file is at the end of the JS build file.
	<br />This file uses the jsStart timer as a reference + event subscriptions to test performance of key page items' rendering.

	@class Other IBM - jstimer-end
	
**/

(function ($, IBM) {
	
	function setTimelineStamp (txt) {
		if (console.timeStamp) {
			console.timeStamp(txt);
		}
	}

	// Set a note for the console.log.
	IBM.performance._note = "Times are in MS";

	// Convert to IBM var and delete global one.
	IBM.performance.jsStart = window.v18JsStart;
	IBM.performance.jsEnd = new Date().getTime();
	
	// Function to always do the math for us when we need time elapsed from the start of the JS file run.
	var getTimeFromStart = function () {
			return (new Date().getTime() - IBM.performance.jsStart);
		},
		getOnreadyTime = function () {
			IBM.performance.startToDocReady = getTimeFromStart();
			setTimelineStamp("jQuery DocReady");
		};
	
	// META data loaded.
	IBM.performance.getMetaTime = function () {
		IBM.performance.startToMetaLoaded = getTimeFromStart();
	};
	
	// Translations loaded.
	IBM.performance.getTranslationTime = function () {
		IBM.performance.startToTranslationsLoaded = getTimeFromStart();
	};
	
	// Masthead main links injected on page.
	IBM.performance.getMastheadMainLinksReady = function () {
		IBM.performance.onReadyToMastheadMainLinks = getTimeFromStart();
		setTimelineStamp("Masthead main links created");
	};
	
	// Masthead main links injected on page.
	IBM.performance.getMobilemenuReady = function () {
		IBM.performance.onReadyToMobilemenuLinks = getTimeFromStart();
		setTimelineStamp("Mobile menu created");
	};
	
	// Group masthead times.
	IBM.performance.showRunTimes = function () {
		if (IBM.common.util.config.isEnabled("errorchecking")) {	
			setTimeout(function () {
				console.info(
					"v18 JS KPIs (from JS start):\n" + 
					"  - Meta data ready: " + IBM.performance.startToMetaLoaded + "ms\n" + 
					"  - Translations ready: " + IBM.performance.startToTranslationsLoaded + "ms\n" + 
					"  - jQuery DocReady: " + IBM.performance.startToDocReady + "ms\n" + 
					"  - Masthead main links onscreen: " + IBM.performance.onReadyToMastheadMainLinks + "ms\n" + 
					"  - Mobile menu created: " + IBM.performance.onReadyToMobilemenuLinks + "ms\n"
				);
			}, 20);
		}
	};


	////
	//  Performance tests:
	////
	
	// Get the onReady time elapse from JS start run.
	$(function(){ 
		getOnreadyTime();
	});

	//How long it takes to process the entire www|w3.js file.
	IBM.performance.startToEnd = getTimeFromStart();
	
	// How long it takes meta to be set.
	IBM.common.meta.subscribe("dataReady", "JSperf", IBM.performance.getMetaTime).runAsap(IBM.performance.getMetaTime);

	// How long it takes translations to be available.
	IBM.common.translations.subscribe("dataReady", "JSperf", IBM.performance.getTranslationTime).runAsap(IBM.performance.getTranslationTime);
	
	// Masthead times use the translation "dataAndDomeReady" subscription b/c that's when masthead JS starts (mastehad init() subscribes to it).
	// How long it takes masthead main links to show on screen.
	IBM.common.module.masthead.subscribe("ready", "JSperf", IBM.performance.getMastheadMainLinksReady).runAsap(IBM.performance.getMastheadMainLinksReady);
	
	IBM.common.module.mobilemenu.subscribe("ready", "JSperf", IBM.performance.getMobilemenuReady).runAsap(IBM.performance.getMobilemenuReady);
	
	// Whatever's last needs to run this callback.
	IBM.common.module.mobilemenu.subscribe("ready", "JSperf", IBM.performance.showRunTimes).runAsap(IBM.performance.showRunTimes);


})(jQuery, IBMCore);
;

/**

	Temp script to check for migration errors.
	<br />Don't worry, it runs post-load and via timeout so doesn't affect onscreen page load.
	<br />
	
	@class Other IBM - errorchecking
	
**/

(function ($, IBM) {
	
	// Do some basic error checking for common required elements or things that the page developer is doing wrong.
	// We will remove this file eventually, but just for now it helps developers debug while they migrate.

	function checkForErrors () {
		var tmp = {};

		// Required elements checking.
		if (!window.digitalData) {
			console.error("IBM v18: This page is missing the required digitalData JS object. You must include that on the page.");
		}

		if (!IBM.common.meta.page.pageInfo.version || IBM.common.meta.page.pageInfo.version !== "v18") {
			console.log(IBM.common.meta.page);
			console.error("IBM v18: The 'digitalData' object's 'version' value is incorrect (digitalData.page.pageInfo.version). It needs to be \"v18\"");
		}

		if (IBM.common.meta.page.pageInfo.ibm.siteID === "IBMTEST") {
			console.warn("IBM v18: The 'digitalData' object's 'siteID' is set to 'IBMTEST'. Do not use this in production.");
		}

		if ($("#ibm-search-module").length === 0) {
			console.error("IBM v18: The masthead search form is missing. It is a required element.");
		}

		if ($("li#ibm-home").length === 1) {
			console.error("IBM v18: The IBM logo HTML in the masthead is incorrect. Correct it so it displays properly.");
		}

		// Warning notices, optional/suggested elements
		if (!IBM.common.meta.page.pageInfo.ibm.siteID) {
			console.warn("IBM v18: This page is missing a siteID value. Consider adding the proper value for better metrics tracking and reporting.");
		}

		// Deprecated element checking.
		if ($("#ibm-content-sidebar").length === 1) {
			console.error("IBM v18: This page is using the deprecated 'div.ibm-content-sidebar' element. You must use the normal 5-col grid instead.");
		}

		if ($("#ibm-content + nav #ibm-navigation").length === 1) {
			console.error("IBM v18: This page is using deprecated left nav HTML placement that causes bad accessibilty. You must use the new left nav placement. It goes BEFORE #ibm-content, not after it.");
		}

		tmp = $(".ibm-standalone-link");
		if (tmp.length > 0) {
			console.error("IBM v18: This page has " + tmp.length + " instances of 'ibm-standalone-link' which has been sunset. Change this class to the proper one: 'ibm-ind-link'.", tmp);
		}

		tmp = $(".ibm-feature-link");
		if (tmp.length > 0) {
			console.error("IBM v18: This page has " + tmp.length + " instances of 'ibm-feature-link' which has been sunset. Remove this class, it does nothing.", tmp);
		}

		tmp = $(".ibm-standalone-acc");
		if (tmp.length > 0) {
			console.error("IBM v18: This page has " + tmp.length + " instances of 'ibm-standalone-acc' which has been sunset. Change this to use the new ibm-icononly classes", tmp);
		}

		tmp = $("p:not([class]) > a[class*='-link']:not([class*='ibm-inlinelink']):not([class='ibm-feature-link'])");
		if (tmp.length > 0) {
			console.error("IBM v18: This page has " + tmp.length + " icon links that are missing the parent P 'ibm-ind-link' class. Correct the icon links by adding the parent class.", tmp);
		}
	}

	// Wait till DOM loaded, and then push to back of the queue and delay 1 second b/c this shit doesn't matter, 
	//  it's just error checking helpers for devs.
	$(function () {
		if (IBM.common.util.config.isEnabled("errorchecking")) {
			setTimeout(checkForErrors, 1000);
		}
	});

})(jQuery, IBMCore);
